<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="tcp_check_req中首先解析数据包的选项，如果有时间戳选项的话则会根据时间戳调用tcp_paws_reject进一步进行PAWS检查，判断是否发生序列号回绕（如果发生回绕后面可能会回复挑战ack），tcp_paws_reject代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP三次握手-接收ack (二)">
<meta property="og:url" content="http://example.com/2025/09/20/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="tcp_check_req中首先解析数据包的选项，如果有时间戳选项的话则会根据时间戳调用tcp_paws_reject进一步进行PAWS检查，判断是否发生序列号回绕（如果发生回绕后面可能会回复挑战ack），tcp_paws_reject代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-20T14:00:00.000Z">
<meta property="article:modified_time" content="2025-09-22T12:41:50.803Z">
<meta property="article:author" content="zhangm">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="TCP建连">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/09/20/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%BA%8C%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP三次握手-接收ack (二) | 日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日拱一卒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/20/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP三次握手-接收ack (二)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-20 22:00:00" itemprop="dateCreated datePublished" datetime="2025-09-20T22:00:00+08:00">2025-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-22 20:41:50" itemprop="dateModified" datetime="2025-09-22T20:41:50+08:00">2025-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/09/20/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/09/20/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>tcp_check_req</code>中首先解析数据包的选项，如果有时间戳选项的话则会根据时间戳调用<code>tcp_paws_reject</code>进一步进行PAWS检查，<strong>判断是否发生序列号回绕（如果发生回绕后面可能会回复挑战<code>ack</code>）</strong>，<code>tcp_paws_reject</code>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">tcp_paws_reject</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tcp_options_received *rx_opt,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> rst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tcp_paws_check(rx_opt, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RST segments are not recommended to carry timestamp,</span></span><br><span class="line"><span class="comment">       and, if they do, it is recommended to ignore PAWS because</span></span><br><span class="line"><span class="comment">       &quot;their cleanup function should take precedence over timestamps.&quot;</span></span><br><span class="line"><span class="comment">       Certainly, it is mistake. It is necessary to understand the reasons</span></span><br><span class="line"><span class="comment">       of this constraint to relax it: if peer reboots, clock may go</span></span><br><span class="line"><span class="comment">       out-of-sync and half-open connections will not be reset.</span></span><br><span class="line"><span class="comment">       Actually, the problem would be not existing if all</span></span><br><span class="line"><span class="comment">       the implementations followed draft about maintaining clock</span></span><br><span class="line"><span class="comment">       via reboots. Linux-2.2 DOES NOT!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       However, we can relax time bounds for RST segments to MSL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如果当前报文是一个 RST 报文，并且当前时间已经超过了之前保存的时间戳记录时间（ts_recent_stamp）加上 PAWS 的 MSL 时间（60秒），那么就返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (rst &amp;&amp; !time_before32(ktime_get_seconds(),</span><br><span class="line">                  rx_opt-&gt;ts_recent_stamp + TCP_PAWS_MSL))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">tcp_paws_check</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tcp_options_received *rx_opt,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> paws_win)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里一个是上一次发送数据包的时间戳（比如说这是在处理三次握手的ack则这个第一个值就是syn包的时间戳），一个是当前数据包的时间戳 paws_win为0  </span></span><br><span class="line">    <span class="keyword">if</span> ((s32)(rx_opt-&gt;ts_recent - rx_opt-&gt;rcv_tsval) &lt;= paws_win)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//时间超过24天也通过</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!time_before32(ktime_get_seconds(),</span><br><span class="line">                    rx_opt-&gt;ts_recent_stamp + TCP_PAWS_24DAYS)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some OSes send SYN and SYNACK messages with tsval=0 tsecr=0,</span></span><br><span class="line"><span class="comment">     * then following tcp messages have valid values. Ignore 0 value,</span></span><br><span class="line"><span class="comment">     * or else &#x27;negative&#x27; tsval might forbid us to accept their packets.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//上一次发包时间没有记录也通过</span></span><br><span class="line">    <span class="keyword">if</span> (!rx_opt-&gt;ts_recent)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_paws_check</code>来真正检查数据包是否发生回绕，如果当前报文上一次发送数据包的时间戳小于当前数据包的时间戳 或者超过24天，则认为序列号没有发生回绕，直接返回否<code>true</code>则返回<code>false</code>。</p>
<p>之后<code>tcp_check_req</code>中处理纯<code>syn</code>包的重传，首先调用<code>__tcp_oow_rate_limited</code>判断是否需要限制速率(为了防止频繁<code>ack</code>的攻击？)，如果不需要限制则回复一个<code>synack</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理纯syn包的重传，这里其实就是重新调用了一下send_synack</span></span><br><span class="line"><span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tcp_rsk(req)-&gt;rcv_isn &amp;&amp;</span><br><span class="line">    flg == TCP_FLAG_SYN &amp;&amp;</span><br><span class="line">    !paws_reject) &#123;</span><br><span class="line">    <span class="comment">//这里传入了last_oow_ack_time,也就是上次发送synack的时间，需要进行安全相关的检查</span></span><br><span class="line">    <span class="comment">//如果检查通过了直接重传synack包并重新设置synack定时器</span></span><br><span class="line">    <span class="keyword">if</span> (!tcp_oow_rate_limited(sock_net(sk), skb,</span><br><span class="line">                  LINUX_MIB_TCPACKSKIPPEDSYNRECV,</span><br><span class="line">                  &amp;tcp_rsk(req)-&gt;last_oow_ack_time) &amp;&amp;</span><br><span class="line"></span><br><span class="line">        !inet_rtx_syn_ack(sk, req)) &#123;<span class="comment">//重传synack</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> expires = jiffies;</span><br><span class="line"></span><br><span class="line">        expires += reqsk_timeout(req, TCP_RTO_MAX);</span><br><span class="line">        <span class="keyword">if</span> (!fastopen)</span><br><span class="line">            mod_timer_pending(&amp;req-&gt;rsk_timer, expires);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            req-&gt;rsk_timer.expires = expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//外面什么也不做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述<code>tcp_oow_rate_limited</code> 用来限制对syn或者ack包的频繁响应</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">tcp_oow_rate_limited</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> mib_idx, u32 *last_oow_ack_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Data packets without SYNs are not likely part of an ACK loop. */</span></span><br><span class="line">    <span class="comment">//对于有数据包，且不是syn包直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((TCP_SKB_CB(skb)-&gt;seq != TCP_SKB_CB(skb)-&gt;end_seq) &amp;&amp;</span><br><span class="line">        !tcp_hdr(skb)-&gt;syn)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//是否需要限制的检查</span></span><br><span class="line">    <span class="keyword">return</span> __tcp_oow_rate_limited(net, mib_idx, last_oow_ack_time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __tcp_oow_rate_limited(<span class="keyword">struct</span> net *net, <span class="type">int</span> mib_idx,</span><br><span class="line">                   u32 *last_oow_ack_time)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Paired with the WRITE_ONCE() in this function. */</span></span><br><span class="line">    u32 val = READ_ONCE(*last_oow_ack_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">        s32 elapsed = (s32)(tcp_jiffies32 - val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= elapsed &amp;&amp;</span><br><span class="line">            <span class="comment">//读取系统参数并和上面的间隔比较 这个系统参数默认是500毫秒</span></span><br><span class="line">            elapsed &lt; READ_ONCE(net-&gt;ipv4.sysctl_tcp_invalid_ratelimit)) &#123;</span><br><span class="line">            NET_INC_STATS(net, mib_idx);</span><br><span class="line">            <span class="comment">//收到限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">/* rate-limited: don&#x27;t send yet! */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Paired with the prior READ_ONCE() and with itself,</span></span><br><span class="line"><span class="comment">     * as we might be lockless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//更新这个值</span></span><br><span class="line">    WRITE_ONCE(*last_oow_ack_time, tcp_jiffies32);</span><br><span class="line">    <span class="comment">//没有限制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">/* not rate-limited: go ahead, send dupack now! */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后<code>tcp_check_req</code>中处理交叉<code>syn</code>攻击的情况，<strong>也就是说如果数据包中有<code>ack</code>标志，但是确认号不对</strong><strong>，这里直接返回监听<code>sk</code>，外面会回复<code>rst</code>报文，具体代码如下所示</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flg &amp; TCP_FLAG_ACK) &amp;&amp; !fastopen &amp;&amp;</span><br><span class="line">    (TCP_SKB_CB(skb)-&gt;ack_seq !=</span><br><span class="line">     tcp_rsk(req)-&gt;snt_isn + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> sk;</span><br></pre></td></tr></table></figure>

<p>之后<code>tcp_check_req</code>中<strong>处理数据包不在接收窗口内的情况，此时会回复一个挑战ack</strong>，返回NULL默默丢弃数据包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (paws_reject || !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,</span><br><span class="line">                  tcp_rsk(req)-&gt;rcv_nxt, tcp_rsk(req)-&gt;rcv_nxt + req-&gt;rsk_rcv_wnd)) &#123;</span><br><span class="line">    <span class="comment">/* Out of window: send ACK and drop. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flg &amp; TCP_FLAG_RST) &amp;&amp; <span class="comment">//没有rst段，回一个挑战ack</span></span><br><span class="line">        !tcp_oow_rate_limited(sock_net(sk), skb,</span><br><span class="line">                  LINUX_MIB_TCPACKSKIPPEDSYNRECV,</span><br><span class="line">                  &amp;tcp_rsk(req)-&gt;last_oow_ack_time))</span><br><span class="line">        req-&gt;rsk_ops-&gt;send_ack(sk, skb, req);</span><br><span class="line">    <span class="keyword">if</span> (paws_reject)</span><br><span class="line">        NET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//默默丢弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户set sockopt设置rskq_defer_accept 则默默丢弃不带数据的ack，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req-&gt;num_timeout &lt; READ_ONCE(inet_csk(sk)-&gt;icsk_accept_queue.rskq_defer_accept) &amp;&amp;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;end_seq == tcp_rsk(req)-&gt;rcv_isn + <span class="number">1</span>) &#123;</span><br><span class="line">    inet_rsk(req)-&gt;acked = <span class="number">1</span>;</span><br><span class="line">    __NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDEFERACCEPTDROP);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//外层什么也不做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上述一系列操作都通过了的话，<strong>则会调用<code>syn_recv_sock</code>，这个函数是关键（这里会创建新的sock，针对全连接队列长度做处理， 设置<code>GSO</code>,地址， 网口，<code>ipid</code>，<code>tos</code>，<code>mss</code>等信息），syn_recv_sock具体代码如下所示</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端被动打开 收到ack会调用</span></span><br><span class="line"><span class="keyword">struct</span> sock *<span class="title function_">tcp_v4_syn_recv_sock</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> request_sock *req,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> dst_entry *dst,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> request_sock *req_unhash,</span></span><br><span class="line"><span class="params">                  <span class="type">bool</span> *own_req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_request_sock</span> *<span class="title">ireq</span>;</span></span><br><span class="line">    <span class="type">bool</span> found_dup_sk = <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">newinet</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">newtp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">tcp_md5_addr</span> *<span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">key</span>;</span></span><br><span class="line">    <span class="type">int</span> l3index;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">    <span class="comment">//注意三次握手完成的数量如果大于了 listen设置的第二个参数，这里直接goto</span></span><br><span class="line">    <span class="comment">//最外层会返回NULL 等于什么也不做</span></span><br><span class="line">    <span class="keyword">if</span> (sk_acceptq_is_full(sk))</span><br><span class="line">        <span class="keyword">goto</span> exit_overflow;</span><br><span class="line">    <span class="comment">//创建一个新的sock并初始化一些列字段</span></span><br><span class="line">    newsk = tcp_create_openreq_child(sk, req, skb);</span><br><span class="line">    <span class="keyword">if</span> (!newsk)</span><br><span class="line">        <span class="keyword">goto</span> exit_nonewsk;</span><br><span class="line">    <span class="comment">//这里设置了GSO的类型</span></span><br><span class="line">    newsk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">    <span class="comment">//将sock关联skb的dst</span></span><br><span class="line">    inet_sk_rx_dst_set(newsk, skb);</span><br><span class="line"></span><br><span class="line">    newtp             = tcp_sk(newsk);</span><br><span class="line">    newinet           = inet_sk(newsk);</span><br><span class="line">    ireq              = inet_rsk(req);</span><br><span class="line">    <span class="comment">//设置地址，网口，ipotion，多播等字段</span></span><br><span class="line">    sk_daddr_set(newsk, ireq-&gt;ir_rmt_addr);</span><br><span class="line">    sk_rcv_saddr_set(newsk, ireq-&gt;ir_loc_addr);</span><br><span class="line">    newsk-&gt;sk_bound_dev_if = ireq-&gt;ir_iif;</span><br><span class="line">    newinet-&gt;inet_saddr   = ireq-&gt;ir_loc_addr;</span><br><span class="line">    inet_opt          = rcu_dereference(ireq-&gt;ireq_opt);</span><br><span class="line">    RCU_INIT_POINTER(newinet-&gt;inet_opt, inet_opt);</span><br><span class="line">    newinet-&gt;mc_index     = inet_iif(skb);</span><br><span class="line">    newinet-&gt;mc_ttl       = ip_hdr(skb)-&gt;ttl;</span><br><span class="line">    newinet-&gt;rcv_tos      = ip_hdr(skb)-&gt;tos;</span><br><span class="line">    inet_csk(newsk)-&gt;icsk_ext_hdr_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (inet_opt)</span><br><span class="line">        inet_csk(newsk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;</span><br><span class="line">    <span class="comment">//设置ipid 这里是随机生成的</span></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;newinet-&gt;inet_id, get_random_u16());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set ToS of the new socket based upon the value of incoming SYN.</span></span><br><span class="line"><span class="comment">     * ECT bits are set later in tcp_init_transfer().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//默认不开启这个系统选项，决定是否使用使用客户端syn包的tos</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_reflect_tos))</span><br><span class="line">        newinet-&gt;tos = tcp_rsk(req)-&gt;syn_tos &amp; ~INET_ECN_MASK;</span><br><span class="line">    <span class="comment">//如果是第三次握手这里一定是空的</span></span><br><span class="line">    <span class="keyword">if</span> (!dst) &#123;</span><br><span class="line">        <span class="comment">//调用查路由的接口</span></span><br><span class="line">        dst = inet_csk_route_child_sock(sk, newsk, req);</span><br><span class="line">        <span class="keyword">if</span> (!dst)</span><br><span class="line">            <span class="keyword">goto</span> put_and_exit;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* syncookie case : see end of cookie_v4_check() */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置GSO能力</span></span><br><span class="line">    sk_setup_caps(newsk, dst);</span><br><span class="line">    <span class="comment">//这里设置了拥塞算法</span></span><br><span class="line">    tcp_ca_openreq_child(newsk, dst);</span><br><span class="line">    <span class="comment">//如果用户没有显示配置mtu则拿到设备的mtu 后计算mss</span></span><br><span class="line">    tcp_sync_mss(newsk, dst_mtu(dst));</span><br><span class="line">    <span class="comment">//从dst_metric_advmss （用户配置或者是1460）和用户显式设置的 MSS 之间取一个更小的合法值。</span></span><br><span class="line">    newtp-&gt;advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));</span><br><span class="line">    <span class="comment">//上述计算的两个mss中选个最小值，给延迟ack使用！</span></span><br><span class="line">    tcp_initialize_rcv_mss(newsk);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">    l3index = l3mdev_master_ifindex_by_index(sock_net(sk), ireq-&gt;ir_iif);</span><br><span class="line">    <span class="comment">/* Copy over the MD5 key from the original socket */</span></span><br><span class="line">    addr = (<span class="keyword">union</span> tcp_md5_addr *)&amp;newinet-&gt;inet_daddr;</span><br><span class="line">    key = tcp_md5_do_lookup(sk, l3index, addr, AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcp_md5_key_copy(newsk, addr, AF_INET, <span class="number">32</span>, l3index, key))</span><br><span class="line">            <span class="keyword">goto</span> put_and_exit;</span><br><span class="line">        sk_gso_disable(newsk);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//将新创建的sock加入bhash中， 因为bhash是管理端口的，新创建的sock也理所应当被管理</span></span><br><span class="line">    <span class="keyword">if</span> (__inet_inherit_port(sk, newsk) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> put_and_exit;</span><br><span class="line">    <span class="comment">//将新创建的sock加入ehahs中，同时移除了原本存在的req</span></span><br><span class="line">    *own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash),</span><br><span class="line">                       &amp;found_dup_sk);</span><br><span class="line">    <span class="keyword">if</span> (likely(*own_req)) &#123;</span><br><span class="line">        <span class="comment">//syn相关的选项</span></span><br><span class="line">        tcp_move_syn(newtp, req);</span><br><span class="line">        ireq-&gt;ireq_opt = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newinet-&gt;inet_opt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!req_unhash &amp;&amp; found_dup_sk) &#123;</span><br><span class="line">            <span class="comment">/* This code path should only be executed in the</span></span><br><span class="line"><span class="comment">             * syncookie case only</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            bh_unlock_sock(newsk);</span><br><span class="line">            sock_put(newsk);</span><br><span class="line">            newsk = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里返回了新创建的sock</span></span><br><span class="line">    <span class="keyword">return</span> newsk;</span><br><span class="line"></span><br><span class="line">exit_overflow:</span><br><span class="line">    NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);</span><br><span class="line">exit_nonewsk:</span><br><span class="line">    dst_release(dst);</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    tcp_listendrop(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">put_and_exit:</span><br><span class="line">    newinet-&gt;inet_opt = <span class="literal">NULL</span>;</span><br><span class="line">    inet_csk_prepare_forced_close(newsk);</span><br><span class="line">    tcp_done(newsk);</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中首先调用<code>sk_acceptq_is_full</code>判断全连接队列是否满了，如果满了的话直接返回返回NULL，否则则会调用</p>
<p><code>tcp_create_openreq_child</code>创建一个新的<code>sock</code>并初始化序列号具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//三次握手服务端接收ack会调用，这里第一个参数是监听sk吧 主要工作就是完成初始化</span></span><br><span class="line"><span class="keyword">struct</span> sock *<span class="title function_">tcp_create_openreq_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> request_sock *req,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请一个sock结构，并初始化相关字段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span> =</span> inet_csk_clone_lock(sk, req, GFP_ATOMIC);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_request_sock</span> *<span class="title">ireq</span> =</span> inet_rsk(req);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_request_sock</span> *<span class="title">treq</span> =</span> tcp_rsk(req);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">newicsk</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">oldtp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">newtp</span>;</span></span><br><span class="line">	u32 seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!newsk)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	newicsk = inet_csk(newsk);</span><br><span class="line">	newtp = tcp_sk(newsk);</span><br><span class="line">	oldtp = tcp_sk(sk);</span><br><span class="line">	<span class="comment">//smc相关</span></span><br><span class="line">	smc_check_reset_syn_req(oldtp, req, newtp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now setup tcp_sock */</span></span><br><span class="line">	newtp-&gt;pred_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置上一次更新的rcv_nxt</span></span><br><span class="line">	seq = treq-&gt;rcv_isn + <span class="number">1</span>;</span><br><span class="line">	newtp-&gt;rcv_wup = seq;</span><br><span class="line">	WRITE_ONCE(newtp-&gt;copied_seq, seq);</span><br><span class="line">	<span class="comment">//这里设置了下一个接收的序号</span></span><br><span class="line">	WRITE_ONCE(newtp-&gt;rcv_nxt, seq);</span><br><span class="line">	<span class="comment">//初始化接受了多少个段</span></span><br><span class="line">	newtp-&gt;segs_in = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	seq = treq-&gt;snt_isn + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//下一个等待确认的序号</span></span><br><span class="line">	newtp-&gt;snd_sml = newtp-&gt;snd_una = seq;</span><br><span class="line">	WRITE_ONCE(newtp-&gt;snd_nxt, seq);</span><br><span class="line">	newtp-&gt;snd_up = seq;</span><br><span class="line">	<span class="comment">//这里初始化了tsq队列！</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;newtp-&gt;tsq_node);</span><br><span class="line">	INIT_LIST_HEAD(&amp;newtp-&gt;tsorted_sent_queue);</span><br><span class="line">	<span class="comment">//更新接收窗口 fastpath会用到？？</span></span><br><span class="line">	tcp_init_wl(newtp, treq-&gt;rcv_isn);</span><br><span class="line"></span><br><span class="line">	minmax_reset(&amp;newtp-&gt;rtt_min, tcp_jiffies32, ~<span class="number">0U</span>);</span><br><span class="line">	<span class="comment">//设置最后一个数据包接收的时间</span></span><br><span class="line">	newicsk-&gt;icsk_ack.lrcvtime = tcp_jiffies32;</span><br><span class="line"></span><br><span class="line">	newtp-&gt;lsndtime = tcp_jiffies32;</span><br><span class="line">	newsk-&gt;sk_txhash = READ_ONCE(treq-&gt;txhash);</span><br><span class="line">	<span class="comment">//重传计数</span></span><br><span class="line">	newtp-&gt;total_retrans = req-&gt;num_retrans;</span><br><span class="line">	<span class="comment">//这里初始化了多个定时器</span></span><br><span class="line">	tcp_init_xmit_timers(newsk);</span><br><span class="line">	WRITE_ONCE(newtp-&gt;write_seq, newtp-&gt;pushed_seq = treq-&gt;snt_isn + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//保活定时器，这里会启动吗？</span></span><br><span class="line">	<span class="keyword">if</span> (sock_flag(newsk, SOCK_KEEPOPEN))</span><br><span class="line">		inet_csk_reset_keepalive_timer(newsk,</span><br><span class="line">					       keepalive_time_when(newtp));</span><br><span class="line"></span><br><span class="line">	newtp-&gt;rx_opt.tstamp_ok = ireq-&gt;tstamp_ok; <span class="comment">//是否支持时间戳选项</span></span><br><span class="line">	newtp-&gt;rx_opt.sack_ok = ireq-&gt;sack_ok;		<span class="comment">//是否支持sack选项</span></span><br><span class="line">	newtp-&gt;window_clamp = req-&gt;rsk_window_clamp; <span class="comment">//窗口大小，从req直接赋值tcp_select_initial_window</span></span><br><span class="line">	newtp-&gt;rcv_ssthresh = req-&gt;rsk_rcv_wnd;  <span class="comment">//慢启动的初始值tcp_select_initial_window</span></span><br><span class="line">	newtp-&gt;rcv_wnd = req-&gt;rsk_rcv_wnd;			<span class="comment">//设置接收窗口的大小</span></span><br><span class="line">	newtp-&gt;rx_opt.wscale_ok = ireq-&gt;wscale_ok; <span class="comment">//是否支持窗口缩放</span></span><br><span class="line">	<span class="keyword">if</span> (newtp-&gt;rx_opt.wscale_ok) &#123;<span class="comment">//保存窗口缩放因子</span></span><br><span class="line">		newtp-&gt;rx_opt.snd_wscale = ireq-&gt;snd_wscale; </span><br><span class="line">		newtp-&gt;rx_opt.rcv_wscale = ireq-&gt;rcv_wscale;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		newtp-&gt;rx_opt.snd_wscale = newtp-&gt;rx_opt.rcv_wscale = <span class="number">0</span>;<span class="comment">//不支持窗口u缩放</span></span><br><span class="line">		newtp-&gt;window_clamp = min(newtp-&gt;window_clamp, <span class="number">65535U</span>); <span class="comment">//设置为最大65535</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////这里计算了发送窗口大小，是接受的窗口大小和缩放因子计算得到</span></span><br><span class="line">	newtp-&gt;snd_wnd = ntohs(tcp_hdr(skb)-&gt;window) &lt;&lt; newtp-&gt;rx_opt.snd_wscale;</span><br><span class="line">	<span class="comment">//最大窗口大小</span></span><br><span class="line">	newtp-&gt;max_window = newtp-&gt;snd_wnd;</span><br><span class="line">	<span class="comment">//如果开启了时间戳选项，更新相关字段，并修改tcp头的长度</span></span><br><span class="line">	<span class="keyword">if</span> (newtp-&gt;rx_opt.tstamp_ok) &#123;</span><br><span class="line">		newtp-&gt;rx_opt.ts_recent = READ_ONCE(req-&gt;ts_recent);</span><br><span class="line">		newtp-&gt;rx_opt.ts_recent_stamp = ktime_get_seconds();</span><br><span class="line">		newtp-&gt;tcp_header_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) + TCPOLEN_TSTAMP_ALIGNED;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		newtp-&gt;rx_opt.ts_recent_stamp = <span class="number">0</span>;</span><br><span class="line">		newtp-&gt;tcp_header_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是否冲传过syn ack</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;num_timeout) &#123;</span><br><span class="line">		newtp-&gt;undo_marker = treq-&gt;snt_isn;<span class="comment">//记录synaack的序列号这意味着，后续任何对序列号​​大于等于​​ snt_isn的数据的确认，都可能用于判断此次 SYN-ACK 重传是否必要</span></span><br><span class="line">		newtp-&gt;retrans_stamp = div_u64(treq-&gt;snt_synack,<span class="comment">//重传的时间戳</span></span><br><span class="line">					       USEC_PER_SEC / TCP_TS_HZ);</span><br><span class="line">	&#125;</span><br><span class="line">	newtp-&gt;tsoffset = treq-&gt;ts_off;<span class="comment">//记录时间戳偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">	newtp-&gt;md5sig_info = <span class="literal">NULL</span>;	<span class="comment">/*XXX*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &gt;= TCP_MSS_DEFAULT + newtp-&gt;tcp_header_len)</span><br><span class="line">		newicsk-&gt;icsk_ack.last_seg_size = skb-&gt;len - newtp-&gt;tcp_header_len; <span class="comment">//记录最后一个段的大小</span></span><br><span class="line">	newtp-&gt;rx_opt.mss_clamp = req-&gt;mss; <span class="comment">//协商的mss</span></span><br><span class="line">	tcp_ecn_openreq_child(newtp, req); <span class="comment">//是否支持ecn</span></span><br><span class="line">	newtp-&gt;fastopen_req = <span class="literal">NULL</span>;</span><br><span class="line">	RCU_INIT_POINTER(newtp-&gt;fastopen_rsk, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	newtp-&gt;bpf_chg_cc_inprogress = <span class="number">0</span>;</span><br><span class="line">	tcp_bpf_clone(sk, newsk);</span><br><span class="line"></span><br><span class="line">	__TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newsk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_create_openreq_child</code><strong>中首先调用<code>inet_csk_clone_lock</code>拿到<code>sock</code></strong>，之后<strong>初始化<code>sock</code>中的各个字段，例如下个待接收的接收的序列号，待确认的序列号，初始化<code>rtt</code>，初始化定时器，设置支持的选项</strong>等。上述通告<code>inet_csk_clone_lock</code>拿到<code>sock</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sock *<span class="title function_">inet_csk_clone_lock</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="keyword">struct</span> request_sock *req,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="type">gfp_t</span> priority)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//申请一个sock初始化各个字段 copy listensock部分字段到sock中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span> =</span> sk_clone_lock(sk, priority);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newsk) &#123;</span><br><span class="line">		<span class="comment">//拿到inet_connection_sock</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">newicsk</span> =</span> inet_csk(newsk);</span><br><span class="line">		<span class="comment">//注意这里将新申请的sock的状态设置为了TCP_SYN_RECV，在外层的处理tcp_rcv_state_process中会设置为TCP_ESTABLISHED</span></span><br><span class="line">		inet_sk_set_state(newsk, TCP_SYN_RECV);</span><br><span class="line">		<span class="comment">//清空bind相关的指针</span></span><br><span class="line">		newicsk-&gt;icsk_bind_hash = <span class="literal">NULL</span>;</span><br><span class="line">		newicsk-&gt;icsk_bind2_hash = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//设置端口号</span></span><br><span class="line">		inet_sk(newsk)-&gt;inet_dport = inet_rsk(req)-&gt;ir_rmt_port;</span><br><span class="line">		inet_sk(newsk)-&gt;inet_num = inet_rsk(req)-&gt;ir_num;</span><br><span class="line">		inet_sk(newsk)-&gt;inet_sport = htons(inet_rsk(req)-&gt;ir_num);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* listeners have SOCK_RCU_FREE, not the children */</span></span><br><span class="line">		<span class="comment">//新创建的sock不想要rcu机制释放</span></span><br><span class="line">		sock_reset_flag(newsk, SOCK_RCU_FREE);</span><br><span class="line">		<span class="comment">//管理多播的链表</span></span><br><span class="line">		inet_sk(newsk)-&gt;mc_list = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//设置mark</span></span><br><span class="line">		newsk-&gt;sk_mark = inet_rsk(req)-&gt;ir_mark;</span><br><span class="line">		atomic64_set(&amp;newsk-&gt;sk_cookie,</span><br><span class="line">			     atomic64_read(&amp;inet_rsk(req)-&gt;ir_cookie));</span><br><span class="line">		<span class="comment">//初始化重传相关字段</span></span><br><span class="line">		newicsk-&gt;icsk_retransmits = <span class="number">0</span>;</span><br><span class="line">		newicsk-&gt;icsk_backoff	  = <span class="number">0</span>;</span><br><span class="line">		newicsk-&gt;icsk_probes_out  = <span class="number">0</span>;</span><br><span class="line">		newicsk-&gt;icsk_probes_tstamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Deinitialize accept_queue to trap illegal accesses. */</span></span><br><span class="line">		<span class="comment">//子套接字没有监听队列，memset一下</span></span><br><span class="line">		<span class="built_in">memset</span>(&amp;newicsk-&gt;icsk_accept_queue, <span class="number">0</span>, <span class="keyword">sizeof</span>(newicsk-&gt;icsk_accept_queue));</span><br><span class="line"></span><br><span class="line">		inet_clone_ulp(req, newsk, priority);</span><br><span class="line">		<span class="comment">//调用安全相关钩子</span></span><br><span class="line">		security_inet_csk_clone(newsk, req);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newsk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inet_csk_clone_lock</code>中调用<code>sk_clone_lock</code>完成实际的申请动作，<code>sk_clone_lock</code>中的工作就是从<code>slab</code>中申请一个<code>sock</code>结构，完成初始化队列，**拷贝监听<code>sock</code>的部分字段到新申请的<code>sock</code>**中等工作。</p>
<p>之后回到<code>inet_csk_clone_lock</code>中，和外面类似，也是进行了一系列初始化的工作，例如设置新创建<code>sock</code>的端口号，<em><strong>*注意这里设置</strong></em>*<code>sock</code><strong><strong>的状态为</strong></strong><code>TCP_SYN_RECV</code>********，最最外层（<code>int tcp_rcv_state_process</code>中）的处理完成后会设置<code>TCP_ESTABLISHED</code>，可以发现这个状态存在的时间很短。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TCP/" rel="tag"># TCP</a>
              <a href="/tags/TCP%E5%BB%BA%E8%BF%9E/" rel="tag"># TCP建连</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/09/18/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="TCP三次握手-接收ack (一)">
      <i class="fa fa-chevron-left"></i> TCP三次握手-接收ack (一)
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/09/22/TCP%E8%A2%AB%E5%8A%A8%E6%89%93%E5%BC%80%E6%8E%A5%E6%94%B6ack%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="TCP三次握手-接收ack (三)">
      TCP三次握手-接收ack (三) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangm</p>
  <div class="site-description" itemprop="description">协议栈源码学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '1c6PW2umhmoCGypfQhPNnfLk-gzGzoHsz',
      appKey     : 'nbVvMAfQXEdOeKD1tmvI3qrQ',
      placeholder: "畅所欲言!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://1c6pw2um.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
