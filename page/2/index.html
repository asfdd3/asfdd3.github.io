<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="协议栈源码学习">
<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="协议栈源码学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhangm">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日拱一卒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/" class="post-title-link" itemprop="url">TCP确认 tcp_ack（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-14 22:00:00 / 修改时间：19:43:31" itemprop="dateCreated datePublished" datetime="2025-12-14T22:00:00+08:00">2025-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>慢速路径中收上来的数据包在<code>tcp_ack</code> 中会调用<code>tcp_ack_update_window</code>尝试更新窗口，之后通过<code>tcp_sacktag_write_queue</code>处理<code>sack</code>，这里对<code>sack</code>的处理逻辑非常复杂，后续分析。处理完成后会更新<code>sack</code>确认的段数，并判断窗口是否被推进并调用拥塞算法的钩子（如果存在）。</p>
<p>接下来调用<code>tcp_clean_rtx_queue</code>移除重传队列中已经确认的数据包，也稍微有点复杂，后续分析，主要工作就是传出<code>flag</code>（标识是否为可疑的<code>ack</code>），用于指导下面拥塞控制处理。</p>
<p>接下来调用<code>tcp_rack_update_reo_wnd</code> 根据上面<code>sack</code>的处理结果（是否看到了重复<code>ack</code>)来调整乱序因子，进而影响后续<code>rack</code>丢包机制的判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_rack_update_reo_wnd</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> rate_sample *rs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//默认不进入会在个分支</span></span><br><span class="line">	<span class="keyword">if</span> ((READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_recovery) &amp;</span><br><span class="line">	     TCP_RACK_STATIC_REO_WND) ||</span><br><span class="line">	    !rs-&gt;prior_delivered)  <span class="comment">//本次速率采样区间开始时确认的包数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disregard DSACK if a rtt has not passed since we adjusted reo_wnd */</span></span><br><span class="line">	<span class="comment">//还没有经过一个完整的RTT</span></span><br><span class="line">	<span class="keyword">if</span> (before(rs-&gt;prior_delivered, tp-&gt;rack.last_delivered))</span><br><span class="line">		tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust the reo_wnd if update is pending */</span></span><br><span class="line">	<span class="comment">//这个是处理sack中设置的，如果看到了daack就增大reo_wnd_steps，这个值会影响rack是否标记为丢包，合理</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;rack.dsack_seen) &#123;</span><br><span class="line">		tp-&gt;rack.reo_wnd_steps = <span class="type">min_t</span>(u32, <span class="number">0xFF</span>,</span><br><span class="line">					       tp-&gt;rack.reo_wnd_steps + <span class="number">1</span>);</span><br><span class="line">		tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line">		tp-&gt;rack.last_delivered = tp-&gt;delivered;</span><br><span class="line">		tp-&gt;rack.reo_wnd_persist = TCP_RACK_RECOVERY_THRESH;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!tp-&gt;rack.reo_wnd_persist) &#123;<span class="comment">//这个值是误判丢包的数量</span></span><br><span class="line">		tp-&gt;rack.reo_wnd_steps = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_rack_update_reo_wnd</code>首先判断当前采样区间是否经过了一个<code>rtt</code>，如果经过了一个<code>rtt</code>且<code>sack</code>的处理中发现了重复<code>ack</code>则更新 <code>reo_wnd_steps</code> 。后续会在<code>tcp_rack_reo_wnd</code>中根据<code>reo_wnd_steps</code>计算得到的时间窗口决定 将哪些数据包标记为丢失。</p>
<p>回到<code>tcp_ack</code>中，上述工作完成后会调用<code>tcp_process_tlp_ack</code>处理TLP重传数据包(如果当前存在<code>tlp</code>数据包的话)，核心思想就是判断是否发生了尾部丢包，如果发生则会进入拥塞状态，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_process_tlp_ack</span><span class="params">(<span class="keyword">struct</span> sock *sk, u32 ack, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//没有确认到tlp的序列号，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (before(ack, tp-&gt;tlp_high_seq))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;tlp_retrans) &#123;</span><br><span class="line">		<span class="comment">/* TLP of new data has been acknowledged */</span></span><br><span class="line">		<span class="comment">//TLP探测的是新数据</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; FLAG_DSACK_TLP) &#123;<span class="comment">//收到了tlp包的重复ack</span></span><br><span class="line">		<span class="comment">/* This DSACK means original and TLP probe arrived; no loss */</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//表示确实发生了丢包，这里有点疑惑，不是有可能也是延迟的情况吗？是不是因为上面没有回复sack？？</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(ack, tp-&gt;tlp_high_seq)) &#123;</span><br><span class="line">		<span class="comment">/* ACK advances: there was a loss, so reduce cwnd. Reset</span></span><br><span class="line"><span class="comment">		 * tlp_high_seq in tcp_init_cwnd_reduction()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_init_cwnd_reduction(sk);</span><br><span class="line">		tcp_set_ca_state(sk, TCP_CA_CWR); <span class="comment">//将状态设置为cwr</span></span><br><span class="line">		tcp_end_cwnd_reduction(sk);</span><br><span class="line">		tcp_try_keep_open(sk);</span><br><span class="line">		NET_INC_STATS(sock_net(sk),</span><br><span class="line">				LINUX_MIB_TCPLOSSPROBERECOVERY);</span><br><span class="line">	<span class="comment">//单纯的重复ack，没有推进窗口，表示就单纯的收到一个重复ack</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flag &amp; (FLAG_SND_UNA_ADVANCED |</span><br><span class="line">			     FLAG_NOT_DUP | FLAG_DATA_SACKED))) &#123;</span><br><span class="line">		<span class="comment">/* Pure dupack: original and TLP probe arrived; no loss */</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中<code>tlp_high_seq</code>为 TLP 探测中的最高序列号边界，这里主要分成以下几种情况对序列号进行处理：</p>
<ul>
<li>如果当前<code>ack</code>还没有到<code>tlp</code>的范围直接返回。</li>
<li>如果 ACK 已经到达 <code>tlp_high_seq</code>，且TLP数据包为新数据包（从发送队列中拿到的），则认为没有丢失数据包，清空<code>tlp_high_seq</code>结束本次<code>tlp</code>探测。</li>
<li>如果收到了<code>tlp</code>包的重复ack则表示也没有发生丢包，直接清掉<code>tlp_high_seq</code></li>
<li>如果<code>ack</code>确认了超过<code>tlp_high_seq</code>且<code>tlp</code>数据包是从重传队列中发送的，则认为数据包丢了（这里有个问题，不会是因为延迟没遇到到达的情况吗？）执行一系列拥塞算法的处理流程（重新计算慢启动阈值，设置拥塞状态等）</li>
<li>如果收到是单纯的一个重复<code>ack</code>同时没有推进窗口则也认为没有丢包，清掉<code>tlp_high_seq</code>（这种情况几乎不会有吧）。</li>
</ul>
<p>回到<code>tcp_ack</code>中，接下来会根据<code>ack</code>的处理结果决定是否进入拥塞状态转换的处理逻辑中，在文章<a href="/2025/10/28/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/" title="TCP拥塞控制-拥塞状态转换">TCP拥塞控制-拥塞状态转换</a>分析过，这里不再重复：-）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/" class="post-title-link" itemprop="url">TCP确认 tcp_ack（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-11 22:00:00" itemprop="dateCreated datePublished" datetime="2025-12-11T22:00:00+08:00">2025-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-17 22:32:15" itemprop="dateModified" datetime="2025-12-17T22:32:15+08:00">2025-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><code>tcp_ack</code>(）用于处理接收到所有携带ack标志位的数据包，建立连接状态下的所有数据包几乎都携带<code>ack</code>标志位，慢速路径以及快速路径都会调用。</strong></p>
<p><strong><code>tcp_ack</code>主要目的是根据<code>ack</code>报文调整发送端的状态，整体工作可以分为以下几个部分：</strong></p>
<ul>
<li>ACK 合法性校验</li>
<li>更新 <code>snd_una</code> &#x2F; <code>窗口</code> &#x2F; <code>SACK</code> &#x2F; <code>ECN</code>（确认信息 &amp; 窗口信息）</li>
<li>清理重传队列，更新 <code>RACK</code> &#x2F; <code>TLP</code> &#x2F; 丢包信息</li>
<li>判断 ACK 是否可疑（重复 <code>ACK</code>、<code>DSACK</code> 等），触发快速重传&#x2F;恢复逻辑</li>
<li>拥塞状态转换，调用拥塞算法钩子</li>
</ul>
<p>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This routine deals with incoming acks, but not outgoing ones. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_ack</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sacktag_state</span> <span class="title">sack_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rate_sample</span> <span class="title">rs</span> =</span> &#123; .prior_delivered = <span class="number">0</span> &#125;;</span><br><span class="line">	u32 prior_snd_una = tp-&gt;snd_una; 		<span class="comment">//已经发送未被确认的序列号</span></span><br><span class="line">	<span class="type">bool</span> is_sack_reneg = tp-&gt;is_sack_reneg;  <span class="comment">//是否是sack反悔</span></span><br><span class="line">	u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;     <span class="comment">//提取数据包的序号</span></span><br><span class="line">	u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;     <span class="comment">///提取当前数据包确认的序列号</span></span><br><span class="line">	<span class="type">int</span> num_dupack = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> prior_packets = tp-&gt;packets_out;    <span class="comment">//发送出去没有被ack的数量</span></span><br><span class="line">	u32 delivered = tp-&gt;delivered;		   <span class="comment">//被确认的ack总数</span></span><br><span class="line">	u32 lost = tp-&gt;lost;				   <span class="comment">//历史丢包数</span></span><br><span class="line">	<span class="type">int</span> rexmit = REXMIT_NONE; <span class="comment">/* Flag to (re)transmit to recover losses */</span><span class="comment">//是否需要重传的标记</span></span><br><span class="line">	u32 prior_fack;</span><br><span class="line"></span><br><span class="line">	sack_state.first_sackt = <span class="number">0</span>;</span><br><span class="line">	sack_state.rate = &amp;rs;</span><br><span class="line">	sack_state.sack_delivered = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We very likely will need to access rtx queue. */</span></span><br><span class="line">	<span class="comment">//预取</span></span><br><span class="line">	prefetch(sk-&gt;tcp_rtx_queue.rb_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack is older than previous acks</span></span><br><span class="line"><span class="comment">	 * then we can probably ignore it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//当前确认的序列号在una之前</span></span><br><span class="line">	<span class="keyword">if</span> (before(ack, prior_snd_una)) &#123;</span><br><span class="line">		<span class="comment">/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */</span></span><br><span class="line">		<span class="comment">//这个ack太老了(可能是注入攻击)，比往前算一个窗口还要小，那就回一个挑战ack</span></span><br><span class="line">		<span class="keyword">if</span> (before(ack, prior_snd_una - tp-&gt;max_window)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_NO_CHALLENGE_ACK))</span><br><span class="line">				tcp_send_challenge_ack(sk);</span><br><span class="line">			<span class="keyword">return</span> -SKB_DROP_REASON_TCP_TOO_OLD_ACK;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> old_ack; <span class="comment">//返回0，外面也会回复挑战ack</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack includes data we haven&#x27;t sent yet, discard</span></span><br><span class="line"><span class="comment">	 * this segment (RFC793 Section 3.9).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//太超前了</span></span><br><span class="line">	<span class="keyword">if</span> (after(ack, tp-&gt;snd_nxt))</span><br><span class="line">		<span class="keyword">return</span> -SKB_DROP_REASON_TCP_ACK_UNSENT_DATA;</span><br><span class="line">	<span class="comment">//确认了新数据</span></span><br><span class="line">	<span class="keyword">if</span> (after(ack, prior_snd_una)) &#123;</span><br><span class="line">		flag |= FLAG_SND_UNA_ADVANCED; <span class="comment">//设置推进ack标志了，下面会用到</span></span><br><span class="line">		icsk-&gt;icsk_retransmits = <span class="number">0</span>;    <span class="comment">//重传清零</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_TLS_DEVICE)</span></span><br><span class="line">		<span class="keyword">if</span> (static_branch_unlikely(&amp;clean_acked_data_enabled.key))</span><br><span class="line">			<span class="keyword">if</span> (icsk-&gt;icsk_clean_acked)</span><br><span class="line">				icsk-&gt;icsk_clean_acked(sk, ack);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回una或者sack最高的序列号</span></span><br><span class="line">	prior_fack = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp-&gt;snd_una;</span><br><span class="line">	<span class="comment">//设置在途数据包数</span></span><br><span class="line">	rs.prior_in_flight = tcp_packets_in_flight(tp);</span><br><span class="line">	<span class="comment">/* ts_recent update must be made after we are sure that the packet</span></span><br><span class="line"><span class="comment">	 * is in window.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//slowpath会设置这个标志，这里会通过PAWS检查后更新时间戳</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_UPDATE_TS_RECENT)</span><br><span class="line">		tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);</span><br><span class="line">	<span class="comment">//这里是fastpath</span></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==</span><br><span class="line">	    FLAG_SND_UNA_ADVANCED) &#123;</span><br><span class="line">		<span class="comment">/* Window is constant, pure forward advance.</span></span><br><span class="line"><span class="comment">		 * No more checks are required.</span></span><br><span class="line"><span class="comment">		 * Note, we use the fact that SND.UNA&gt;=SND.WL2.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//更新发送窗口更新时候的序列号，第二个参数是数据包的序号</span></span><br><span class="line">		tcp_update_wl(tp, ack_seq);</span><br><span class="line">		<span class="comment">//更新una和确认的字节数</span></span><br><span class="line">		tcp_snd_una_update(tp, ack);</span><br><span class="line">		<span class="comment">//设置更新窗口标志位</span></span><br><span class="line">		flag |= FLAG_WIN_UPDATE;</span><br><span class="line">		<span class="comment">//调用拥塞算法钩子，如果有</span></span><br><span class="line">		tcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);</span><br><span class="line"></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);</span><br><span class="line">	<span class="comment">//这里是走slowpah</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u32 ack_ev_flags = CA_ACK_SLOWPATH;</span><br><span class="line">		<span class="comment">//标记数据包是否携带数据</span></span><br><span class="line">		<span class="keyword">if</span> (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)</span><br><span class="line">			flag |= FLAG_DATA;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);</span><br><span class="line">		<span class="comment">//这里的第三个参数是确认号， 第四个参数ack_seq是报文的序列号</span></span><br><span class="line">		flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);</span><br><span class="line">		<span class="comment">//处理sack</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;sacked)</span><br><span class="line">			flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">							&amp;sack_state);</span><br><span class="line">		<span class="comment">//发生了拥塞，设置标志位</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) &#123;</span><br><span class="line">			flag |= FLAG_ECE;</span><br><span class="line">			ack_ev_flags |= CA_ACK_ECE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有sack确认的段数，需要更新确认的总数，合理</span></span><br><span class="line">		<span class="keyword">if</span> (sack_state.sack_delivered)</span><br><span class="line">			tcp_count_delivered(tp, sack_state.sack_delivered,</span><br><span class="line">					    flag &amp; FLAG_ECE);</span><br><span class="line">		<span class="comment">//窗口是否推进了</span></span><br><span class="line">		<span class="keyword">if</span> (flag &amp; FLAG_WIN_UPDATE)</span><br><span class="line">			ack_ev_flags |= CA_ACK_WIN_UPDATE;</span><br><span class="line">		<span class="comment">//调用拥塞算法的钩子</span></span><br><span class="line">		tcp_in_ack_event(sk, ack_ev_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is a deviation from RFC3168 since it states that:</span></span><br><span class="line"><span class="comment">	 * &quot;When the TCP data sender is ready to set the CWR bit after reducing</span></span><br><span class="line"><span class="comment">	 * the congestion window, it SHOULD set the CWR bit only on the first</span></span><br><span class="line"><span class="comment">	 * new data packet that it transmits.&quot;</span></span><br><span class="line"><span class="comment">	 * We accept CWR on pure ACKs to be more robust</span></span><br><span class="line"><span class="comment">	 * with widely-deployed TCP implementations that do this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//如果是显示拥塞，这里立即设置回复ack的标志位，因为发送端窗口已经很小了，需要立即回复ack</span></span><br><span class="line">	tcp_ecn_accept_cwr(sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We passed data and got it acked, remove any soft error</span></span><br><span class="line"><span class="comment">	 * log. Something worked...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_err_soft, <span class="number">0</span>);</span><br><span class="line">	icsk-&gt;icsk_probes_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rcv_tstamp = tcp_jiffies32;</span><br><span class="line">	<span class="keyword">if</span> (!prior_packets)</span><br><span class="line">		<span class="keyword">goto</span> no_queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we can take anything off of the retransmit queue. */</span></span><br><span class="line">	<span class="comment">//清重传队列</span></span><br><span class="line">	flag |= tcp_clean_rtx_queue(sk, skb, prior_fack, prior_snd_una,</span><br><span class="line">				    &amp;sack_state, flag &amp; FLAG_ECE);</span><br><span class="line">	<span class="comment">//根据sack的处理来调整乱续增长因子进而影响丢包判断</span></span><br><span class="line">	tcp_rack_update_reo_wnd(sk, &amp;rs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag); </span><br><span class="line">	<span class="comment">//当前ack是否可疑（	没有确认数据，窗口更新 纯ack sack 或者dsack ）</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_ack_is_dubious(sk, flag)) &#123;</span><br><span class="line">		<span class="comment">//是否是一个纯粹的重复ack（没有确认新数据）</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (FLAG_SND_UNA_ADVANCED | </span><br><span class="line">			      FLAG_NOT_DUP | FLAG_DSACKING_ACK))) &#123;</span><br><span class="line">			num_dupack = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">/* Consider if pure acks were aggregated in tcp_add_backlog() */</span></span><br><span class="line">			<span class="comment">//统计纯ack的计数，注意这里协议站可能会聚合纯ack</span></span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_DATA)) </span><br><span class="line">				num_dupack = <span class="type">max_t</span>(u16, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//传入的是snd_una, 重复ack的数量，ack的标志位 ，传入传出rexmit会指导下面的重传</span></span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If needed, reset TLP/RTO timer when RACK doesn&#x27;t set. */</span></span><br><span class="line">	<span class="comment">//在清理重传队列的时候可能会设置上这个标志位，比如有新的数据包被确认的时候，或者检测到乱续或者丢包 肯定需要重新设置这个定时器了</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_SET_XMIT_TIMER)</span><br><span class="line">		tcp_set_xmit_timer(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; FLAG_FORWARD_PROGRESS) || !(flag &amp; FLAG_NOT_DUP))</span><br><span class="line">		sk_dst_confirm(sk);</span><br><span class="line">	<span class="comment">//更新统计字段累计收到了多少包</span></span><br><span class="line">	delivered = tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	<span class="comment">//更新丢包总数</span></span><br><span class="line">	lost = tp-&gt;lost - lost;			<span class="comment">/* freshly marked lost */</span></span><br><span class="line">	rs.is_ack_delayed = !!(flag &amp; FLAG_ACK_MAYBE_DELAYED);</span><br><span class="line">	<span class="comment">//更新bbr算法用到的字段</span></span><br><span class="line">	tcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);</span><br><span class="line">	tcp_cong_control(sk, ack, delivered, flag, sack_state.rate);</span><br><span class="line">	tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">no_queue:</span><br><span class="line">	<span class="comment">/* If data was DSACKed, see if we can undo a cwnd reduction. */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_DSACKING_ACK) &#123;</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		<span class="comment">////更新统计字段累计收到了多少包</span></span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If this ack opens up a zero window, clear backoff.  It was</span></span><br><span class="line"><span class="comment">	 * being used to time the probes, and is probably far higher than</span></span><br><span class="line"><span class="comment">	 * it needs to be for normal retransmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcp_ack_probe(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">old_ack:</span><br><span class="line">	<span class="comment">/* If data was SACKed, tag it and see if we should send more data.</span></span><br><span class="line"><span class="comment">	 * If data was DSACKed, see if we can undo a cwnd reduction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;sacked) &#123;</span><br><span class="line">		flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">						&amp;sack_state);</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">		tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_ack</code>中<strong>首先判断数据包确认数据的序列号是否太老了，如果确认的序列号比往前移动一个最大接收窗口的的序号还老，会回一个<code>challenge</code> <code>ack</code></strong> （也可能不回复，有速率限制）。如果这个确认号不是太老的话，则直接<code>goto</code>到最下面，判断是否协携带了<code>sack</code>信息，如果没有携带直接返回0，同时也有可能回<code>challenge ack</code>（取决于是否是建立连接的通路上）。</p>
<p>如果数据包确认了还没发送的数据，则直接丢弃。</p>
<p>如果数据包确认了新数据（最常见的情况），则设置推进窗口标志为下面判断<code>slowpath</code>和<code>fastpath</code>会用到。之后判断<strong>如果是慢速路径收上来的数据包，则调用<code>tcp_replace_ts_recent</code>通过PAWS机制决定是否需要更新时间戳</strong>，（这里注意，如果是快速路径上收到 包已经更新过了），具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_replace_ts_recent</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tp, u32 seq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//进入这个分支应该是处理异常的数据包，小心的更新时间戳？</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; !after(seq, tp-&gt;rcv_wup)) &#123;</span><br><span class="line">		<span class="comment">/* PAWS bug workaround wrt. ACK frames, the PAWS discard</span></span><br><span class="line"><span class="comment">		 * extra check below makes sure this can only happen</span></span><br><span class="line"><span class="comment">		 * for pure ACK frames.  -DaveM</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Not only, also it occurs for expired timestamps.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tcp_paws_check(&amp;tp-&gt;rx_opt, <span class="number">0</span>))</span><br><span class="line">			tcp_store_ts_recent(tp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来处理<code>fastpath</code>路径收包的情况，调用<code>tcp_snd_una_update</code>更新发送窗口（<strong>更新<code>una</code></strong>）和确认的总字节数，并设置标志位。具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">TCP输出 __tcp_transmit_skb(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-09 22:00:00 / 修改时间：22:59:44" itemprop="dateCreated datePublished" datetime="2025-12-09T22:00:00+08:00">2025-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>__tcp_select_window</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">u32 __tcp_select_window(<span class="keyword">struct</span> sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">    <span class="comment">/* MSS for the peer&#x27;s data.  Previous versions used mss_clamp</span></span><br><span class="line"><span class="comment">     * here.  I don&#x27;t know if the value based on our guesses</span></span><br><span class="line"><span class="comment">     * of peer&#x27;s MSS is better for the performance.  It&#x27;s more correct</span></span><br><span class="line"><span class="comment">     * but may be worse for the performance because of rcv_mss</span></span><br><span class="line"><span class="comment">     * fluctuations.  --SAW  1998/11/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> mss = icsk-&gt;icsk_ack.rcv_mss;  <span class="comment">//估计对端的mss</span></span><br><span class="line">    <span class="type">int</span> free_space = tcp_space(sk); <span class="comment">//这里是rcvbuf大小减去backlog还有接收队列之后实际剩余真实的内存量，当前可用的剩余空间</span></span><br><span class="line">    <span class="type">int</span> allowed_space = tcp_full_space(sk);<span class="comment">//这里是rcvbuf大小</span></span><br><span class="line">    <span class="type">int</span> full_space, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk_is_mptcp(sk))</span><br><span class="line">        mptcp_space(sk, &amp;free_space, &amp;allowed_space);</span><br><span class="line">    <span class="comment">//取一个最大的 接收端硬限制的最大窗口</span></span><br><span class="line">    full_space = <span class="type">min_t</span>(<span class="type">int</span>, tp-&gt;window_clamp, allowed_space);</span><br><span class="line">    <span class="comment">//连一个mss都装不下</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(mss &gt; full_space)) &#123;</span><br><span class="line">        mss = full_space;</span><br><span class="line">        <span class="keyword">if</span> (mss &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow window shrink if the sysctl is enabled and we have</span></span><br><span class="line"><span class="comment">     * a non-zero scaling factor in effect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//是否允许窗口缩小，默认不容许</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(net-&gt;ipv4.sysctl_tcp_shrink_window) &amp;&amp; tp-&gt;rx_opt.rcv_wscale)</span><br><span class="line">        <span class="keyword">goto</span> shrink_window_allowed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do not allow window to shrink */</span></span><br><span class="line">    <span class="comment">//当 free_space 比 full_space 的一半要小，这里可以理解为小于实际窗口的一半吧</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &lt; (full_space &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        icsk-&gt;icsk_ack.quick = <span class="number">0</span>;  <span class="comment">//关闭 quick ACK 避免频繁ack</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_under_memory_pressure(sk)) <span class="comment">//是否在内存压力之下</span></span><br><span class="line">            tcp_adjust_rcv_ssthresh(sk);    <span class="comment">//设置rcv_ssthresh</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free_space might become our new window, make sure we don&#x27;t</span></span><br><span class="line"><span class="comment">         * increase it due to wscale.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//free_space 齐到 wscale </span></span><br><span class="line">        free_space = round_down(free_space, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if free space is less than mss estimate, or is below 1/16th</span></span><br><span class="line"><span class="comment">         * of the maximum allowed, try to move to zero-window, else</span></span><br><span class="line"><span class="comment">         * tcp_clamp_window() will grow rcv buf up to tcp_rmem[2], and</span></span><br><span class="line"><span class="comment">         * new incoming data is dropped due to memory limits.</span></span><br><span class="line"><span class="comment">         * With large window, mss test triggers way too late in order</span></span><br><span class="line"><span class="comment">         * to announce zero window in time before rmem limit kicks in.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//是否直接变成 0 窗口  当前可用空间 小于最大允许空间的 1/16 || 连一个 MSS 都没有</span></span><br><span class="line">        <span class="keyword">if</span> (free_space &lt; (allowed_space &gt;&gt; <span class="number">4</span>) || free_space &lt; mss)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于发送慢启动阈值，设置为慢启动阈值！</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &gt; tp-&gt;rcv_ssthresh)</span><br><span class="line">        free_space = tp-&gt;rcv_ssthresh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t do rounding if we are using window scaling, since the</span></span><br><span class="line"><span class="comment">     * scaled window will not line up with the MSS boundary anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//开启了窗口缩放</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;rx_opt.rcv_wscale) &#123;</span><br><span class="line">        window = free_space;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advertise enough space so that it won&#x27;t get scaled away.</span></span><br><span class="line"><span class="comment">         * Import case: prevent zero window announcement if</span></span><br><span class="line"><span class="comment">         * 1&lt;&lt;rcv_wscale &gt; mss.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//对齐窗口缩放</span></span><br><span class="line">        window = ALIGN(window, (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没启用窗口缩放的情况</span></span><br><span class="line">        window = tp-&gt;rcv_wnd;</span><br><span class="line">        <span class="comment">/* Get the largest window that is a nice multiple of mss.</span></span><br><span class="line"><span class="comment">         * Window clamp already applied above.</span></span><br><span class="line"><span class="comment">         * If our current window offering is within 1 mss of the</span></span><br><span class="line"><span class="comment">         * free space we just keep it. This prevents the divide</span></span><br><span class="line"><span class="comment">         * and multiply from happening most of the time.</span></span><br><span class="line"><span class="comment">         * We also don&#x27;t do any window rounding when the free space</span></span><br><span class="line"><span class="comment">         * is too small.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//窗口变化太大了，就重新设定一个新的 对齐到 MSS 的整倍数的窗口</span></span><br><span class="line">        <span class="keyword">if</span> (window &lt;= free_space - mss || window &gt; free_space)</span><br><span class="line">            window = rounddown(free_space, mss);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mss == full_space &amp;&amp;   <span class="comment">//一次最大窗口只能装一个 MSS   可用空间超过 window + 一半的实际窗口）</span></span><br><span class="line">             free_space &gt; window + (full_space &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            window = free_space;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> window;</span><br><span class="line"></span><br><span class="line">shrink_window_allowed: <span class="comment">//是否更激进的缩小拥塞窗口吧</span></span><br><span class="line">    <span class="comment">/* new window should always be an exact multiple of scaling factor */</span></span><br><span class="line">    <span class="comment">//向下对齐</span></span><br><span class="line">    free_space = round_down(free_space, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);</span><br><span class="line">    <span class="comment">//如果 free_space 已经小于 full_space 的一半</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &lt; (full_space &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        icsk-&gt;icsk_ack.quick = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否内存压力，修改慢启动阈值</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_under_memory_pressure(sk))</span><br><span class="line">            tcp_adjust_rcv_ssthresh(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if free space is too low, return a zero window */</span></span><br><span class="line">        <span class="comment">//表示空闲空间只剩下不足 1/16  ||  不足一个mss</span></span><br><span class="line">        <span class="keyword">if</span> (free_space &lt; (allowed_space &gt;&gt; <span class="number">4</span>) || free_space &lt; mss ||</span><br><span class="line">            free_space &lt; (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于接收端慢启动阈值</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &gt; tp-&gt;rcv_ssthresh) &#123;</span><br><span class="line">        free_space = tp-&gt;rcv_ssthresh;</span><br><span class="line">        <span class="comment">/* new window should always be an exact multiple of scaling factor</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For this case, we ALIGN &quot;up&quot; (increase free_space) because</span></span><br><span class="line"><span class="comment">         * we know free_space is not zero here, it has been reduced from</span></span><br><span class="line"><span class="comment">         * the memory-based limit, and rcv_ssthresh is not a hard limit</span></span><br><span class="line"><span class="comment">         * (unlike sk_rcvbuf).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//对齐</span></span><br><span class="line">        free_space = ALIGN(free_space, (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> free_space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__tcp_select_window</code>中首先计算接收缓冲区的剩余空间<code>free_space</code> 然后计算接收缓冲区全部的可用大小（按比例计算）<code>allowed_space</code>，拿到这两个值后，计算<strong>理论允许的最大接收窗口</strong><code>full_space</code>。</p>
<p>如果连一个<code>mss</code>都放不下直接0窗口，</p>
<p>之后判断是否允许窗口收缩(是否可以激进的主动缩小窗口)，系统默认是不允许。如果是不收缩的逻辑，则进一步判断剩余的空间大小是否已经小于了缓冲区大小的一半（<strong>已经吃掉了超过半个接收窗口</strong>）则关闭快速<code>ack</code>，如果在内存压力之下，则调用<code>tcp_adjust_rcv_ssthresh</code>设置接收端慢启动阈值**(和拥塞窗口的类似，但是这里是控制接收窗口大小的**)，最后把 <code>free_space</code> 向下对齐到 <code>2^rcv_wscale</code> 的整数倍，如果 当前可用空间 小于最大允许空间的 1&#x2F;16 或连一个 MSS 都没有，则也直接0窗口</p>
<p>上述<code>tcp_adjust_rcv_ssthresh</code> 代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcp_adjust_rcv_ssthresh</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算剩余的内存（用户配置），通常是0</span></span><br><span class="line">    <span class="type">int</span> unused_mem = sk_unused_reserved_mem(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="comment">//钳制一下，最小4个mss</span></span><br><span class="line">    tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, <span class="number">4U</span> * tp-&gt;advmss);</span><br><span class="line">    <span class="keyword">if</span> (unused_mem)</span><br><span class="line">        <span class="comment">//如果由保留的内存则取一个最大值</span></span><br><span class="line">        tp-&gt;rcv_ssthresh = <span class="type">max_t</span>(u32, tp-&gt;rcv_ssthresh,</span><br><span class="line">                     tcp_win_from_space(sk, unuserud_mem));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果剩余空间大于了接收端慢启动阈值，则设置为接收端慢启动阈值，目的就是用来限制窗口增长不要太快。</p>
<p>最后根据是否启用窗口缩放决定最终的window大小，具体分为两种情况，如果启用了窗口缩放，则 <code>window = free_space</code>，再往上对齐到 <code>2^wscale</code> 的倍数。否则判断现在的窗口 <code>（window）</code>是否比 <code>free_space</code> 小太多（差超过 1 MSS），说明应该再增大一点，重新设为 <code>free_space</code> 向下对齐到 MSS 倍数，上述位没开启<code>shrink</code>系统选项的逻辑</p>
<p>如果开启了允许窗口<code>shrink</code>（允许缩小窗口的情况）如果<code>free_space &lt; full_space/2</code>，这里和上述主路径类似，关闭快速<code>ack</code>，内存紧张时候降低慢启动阈值，如果窗口过小则直接零窗口。如果<code>free_space &gt; rcv_ssthresh</code>这里和主路径不同， <strong>向上对齐</strong>到 <code>2^wscale</code> 的倍数。这里感觉主路径和<code>shrink</code>路径没什么区别。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/" class="post-title-link" itemprop="url">TCP输出 __tcp_transmit_skb(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-07 22:00:00 / 修改时间：22:17:00" itemprop="dateCreated datePublished" datetime="2025-12-07T22:00:00+08:00">2025-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>__tcp_transmit_skb</code>为TCP发送路径上交给IP层的最后一个处理函数，主要完成如下工作：</p>
<p>设置时间戳，构建头部各个字段，<code>TCP</code>选项，设置<code>skb</code>属于哪个<code>sk</code>，设置析构函数，更新内存记账。</p>
<p>计算通告给对端的窗口大小，计算伪首部，更新统计字段，数据包的GSO字段。</p>
<p>调用<code>ip</code>层发包函数，更新拥塞算法用到的时间戳字段等等，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __tcp_transmit_skb(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line">			      <span class="type">int</span> clone_it, <span class="type">gfp_t</span> gfp_mask, u32 rcv_nxt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tcp_options_size, tcp_header_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	u64 prior_wstamp;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line">	tp = tcp_sk(sk);</span><br><span class="line">	<span class="comment">//发包前记录时间戳</span></span><br><span class="line">	prior_wstamp = tp-&gt;tcp_wstamp_ns;</span><br><span class="line">	<span class="comment">//确保时间单调不减？</span></span><br><span class="line">	tp-&gt;tcp_wstamp_ns = max(tp-&gt;tcp_wstamp_ns, tp-&gt;tcp_clock_cache);</span><br><span class="line">	<span class="comment">//给qisc用</span></span><br><span class="line">	skb_set_delivery_time(skb, tp-&gt;tcp_wstamp_ns, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (clone_it) &#123; <span class="comment">//需要重传的情况</span></span><br><span class="line">		oskb = skb; <span class="comment">//原skb的指针</span></span><br><span class="line"></span><br><span class="line">		tcp_skb_tsorted_save(oskb) &#123;          	<span class="comment">//临时把 skb 内部 _skb_refdst 字段清空</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(skb_cloned(oskb)))<span class="comment">//克隆数据包</span></span><br><span class="line">				skb = pskb_copy(oskb, gfp_mask);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				skb = skb_clone(oskb, gfp_mask);</span><br><span class="line">		&#125; tcp_skb_tsorted_restore(oskb);		<span class="comment">//还原</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">		<span class="comment">/* retransmit skbs might have a non zero value in skb-&gt;dev</span></span><br><span class="line"><span class="comment">		 * because skb-&gt;dev is aliased with skb-&gt;rbnode.rb_left</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inet = inet_sk(sk);</span><br><span class="line">	tcb = TCP_SKB_CB(skb);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line">	<span class="comment">//syn 包构建选项走这里</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN)) &#123;</span><br><span class="line">		tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//正常数据包选项走这里</span></span><br><span class="line">		tcp_options_size = tcp_established_options(sk, skb, &amp;opts,</span><br><span class="line">							   &amp;md5);</span><br><span class="line">		<span class="comment">/* Force a PSH flag on all (GSO) packets to expedite GRO flush</span></span><br><span class="line"><span class="comment">		 * at receiver : This slightly improve GRO performance.</span></span><br><span class="line"><span class="comment">		 * Note that we do not force the PSH flag for non GSO packets,</span></span><br><span class="line"><span class="comment">		 * because they might be sent under high congestion events,</span></span><br><span class="line"><span class="comment">		 * and in this case it is better to delay the delivery of 1-MSS</span></span><br><span class="line"><span class="comment">		 * packets and thus the corresponding ACK packet that would</span></span><br><span class="line"><span class="comment">		 * release the following packet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果是GSO包则促使对端更快地把数据交给上层</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_skb_pcount(skb) &gt; <span class="number">1</span>)</span><br><span class="line">			tcb-&gt;tcp_flags |= TCPHDR_PSH;</span><br><span class="line">	&#125;</span><br><span class="line">	tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We set skb-&gt;ooo_okay to one if this packet can select</span></span><br><span class="line"><span class="comment">	 * a different TX queue than prior packets of this flow,</span></span><br><span class="line"><span class="comment">	 * to avoid self inflicted reorders.</span></span><br><span class="line"><span class="comment">	 * The &#x27;other&#x27; queue decision is based on current cpu number</span></span><br><span class="line"><span class="comment">	 * if XPS is enabled, or sk-&gt;sk_txhash otherwise.</span></span><br><span class="line"><span class="comment">	 * We can switch to another (and better) queue if:</span></span><br><span class="line"><span class="comment">	 * 1) No packet with payload is in qdisc/device queues.</span></span><br><span class="line"><span class="comment">	 *    Delays in TX completion can defeat the test</span></span><br><span class="line"><span class="comment">	 *    even if packets were already sent.</span></span><br><span class="line"><span class="comment">	 * 2) Or rtx queue is empty.</span></span><br><span class="line"><span class="comment">	 *    This mitigates above case if ACK packets for</span></span><br><span class="line"><span class="comment">	 *    all prior packets were already processed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//是否容许这个 skb 选择和前面不同的 TX queue，协议栈几乎没包，或者重传队列为空</span></span><br><span class="line">	skb-&gt;ooo_okay = sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>) ||</span><br><span class="line">			tcp_rtx_queue_empty(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we had to use memory reserve to allocate this skb,</span></span><br><span class="line"><span class="comment">	 * this might cause drops if packet is looped back :</span></span><br><span class="line"><span class="comment">	 * Other socket might not have SOCK_MEMALLOC.</span></span><br><span class="line"><span class="comment">	 * Packets not looped back do not care about pfmemalloc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb-&gt;pfmemalloc = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	skb_push(skb, tcp_header_size);</span><br><span class="line">	skb_reset_transport_header(skb);</span><br><span class="line">	<span class="comment">//清除之前的 skb-&gt;sk 等 owner 信息</span></span><br><span class="line">	skb_orphan(skb);</span><br><span class="line">	skb-&gt;sk = sk;</span><br><span class="line">	<span class="comment">//是否是纯ack，后者析构中会判断TSQ并设置 调度TSQ</span></span><br><span class="line">	skb-&gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree;</span><br><span class="line">	<span class="comment">//增加协议栈使用的内存</span></span><br><span class="line">	refcount_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line">	<span class="comment">///标识路由是否需要验证，收到ack的地方会置位</span></span><br><span class="line">	skb_set_dst_pending_confirm(skb, sk-&gt;sk_dst_pending_confirm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">	<span class="comment">//设置tcp头部字段</span></span><br><span class="line">	th = (<span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line">	th-&gt;source		= inet-&gt;inet_sport;</span><br><span class="line">	th-&gt;dest		= inet-&gt;inet_dport;</span><br><span class="line">	th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">	th-&gt;ack_seq		= htonl(rcv_nxt);</span><br><span class="line">	*(((__be16 *)th) + <span class="number">6</span>)	= htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">					tcb-&gt;tcp_flags);</span><br><span class="line"></span><br><span class="line">	th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">	th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">	<span class="comment">//urg 几乎不会使用吧</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//GSO的类型</span></span><br><span class="line">	skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line">	<span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">	<span class="comment">//注意这里算的通告给对端的窗口大小</span></span><br><span class="line">		th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">		tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">		 * is never scaled.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		th-&gt;window	= htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置tcp选项</span></span><br><span class="line">	tcp_options_write(th, tp, &amp;opts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">	<span class="comment">/* Calculate the MD5 hash, as we have all we need now */</span></span><br><span class="line">	<span class="keyword">if</span> (md5) &#123;</span><br><span class="line">		sk_gso_disable(sk);</span><br><span class="line">		tp-&gt;af_specific-&gt;calc_md5_hash(opts.hash_location,</span><br><span class="line">					       md5, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BPF prog is the last one writing header option */</span></span><br><span class="line">	<span class="comment">//bpf相关</span></span><br><span class="line">	bpf_skops_write_hdr_opt(sk, skb, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;opts);</span><br><span class="line">	<span class="comment">//计算校验和，注意这里只计算伪首部</span></span><br><span class="line">	INDIRECT_CALL_INET(icsk-&gt;icsk_af_ops-&gt;send_check,</span><br><span class="line">			   tcp_v6_send_check, tcp_v4_send_check,</span><br><span class="line">			   sk, skb);</span><br><span class="line">	<span class="comment">//处理快速ack</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">		tcp_event_ack_sent(sk, rcv_nxt);</span><br><span class="line">	<span class="comment">//存在负载</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">		tcp_event_data_sent(tp, sk);</span><br><span class="line">		tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">		tp-&gt;bytes_sent += skb-&gt;len - tcp_header_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">		TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">			      tcp_skb_pcount(skb));</span><br><span class="line">	<span class="comment">//累计发出去的段数</span></span><br><span class="line">	tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">	<span class="comment">//选怎发送队列用到</span></span><br><span class="line">	skb_set_hash_from_sk(skb, sk);</span><br><span class="line">	<span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">	<span class="comment">//把段数和mss给到skb</span></span><br><span class="line">	skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">	skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Leave earliest departure time in skb-&gt;tstamp (skb-&gt;skb_mstamp_ns) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">	<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm),</span><br><span class="line">			       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet6_skb_parm)));</span><br><span class="line">	<span class="comment">//设置一个时间戳</span></span><br><span class="line">	tcp_add_tx_delay(skb, tp);</span><br><span class="line">	<span class="comment">//向ip层发送数据包</span></span><br><span class="line">	err = INDIRECT_CALL_INET(icsk-&gt;icsk_af_ops-&gt;queue_xmit,</span><br><span class="line">				 inet6_csk_xmit, ip_queue_xmit,</span><br><span class="line">				 sk, skb, &amp;inet-&gt;cork.fl);</span><br><span class="line">	<span class="comment">//如果本地发包失败了，则进入显示拥塞状态</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(err &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		tcp_enter_cwr(sk);</span><br><span class="line">		err = net_xmit_eval(err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!err &amp;&amp; oskb) &#123;</span><br><span class="line">		<span class="comment">//更新pacing相关和rack相关用到的时间</span></span><br><span class="line">		tcp_update_skb_after_send(sk, oskb, prior_wstamp);</span><br><span class="line">		<span class="comment">//更新bbr用到的字段</span></span><br><span class="line">		tcp_rate_skb_sent(sk, oskb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__tcp_transmit_skb</code>中首先将<code>tp</code>的时间戳字段给到<code>skb</code>(TC可能会用到？）如果这个数据包需要<code>clone</code>（重传路径需要）则<code>clone</code>这个数据包，之后构建数据包的选项字段，这里其实就是把<code>tp</code>的选项字段拷贝到<code>tcp_out_options</code>中，这里不做分析。</p>
<p>接下来计算数据包的头部长度，并设置<code>ooo_okay</code>(决定是否可以重新选择TX队列)，当协议栈没有数据包，或者重传队列为空时，选择队列的时候可以重新计算使用哪个硬件队列。</p>
<p>之后设置数据包传输的头的指针，并设置<code>skb</code>与当前<code>sk</code>相关联，设置<code>skb</code>的析构函数，<strong>这里注意，如果数据包存在负载，则析构函数中会包括调度TSQ机制的逻辑，当网卡驱动释放数据包时，如果TSQ被置位(<code>tcp_write_xmit</code>中)则会进行调度。</strong></p>
<p>最后设置<code>tcp</code>头部的各个字段，<strong>这里最关键的是调用</strong><code>tcp_select_window</code><strong>计算</strong>(<strong>不是syn包的情况才会调用，这里可以发现syn包是没有窗口缩放的</strong>)通告给对端窗口的计算逻辑，<code>tcp_select_window</code>具体逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u16 <span class="title function_">tcp_select_window</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	u32 old_win = tp-&gt;rcv_wnd;</span><br><span class="line">	u32 cur_win, new_win;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window 0 if we failed to queue the data because we</span></span><br><span class="line"><span class="comment">	 * are out of memory. The window is temporary, so we don&#x27;t store</span></span><br><span class="line"><span class="comment">	 * it on the socket.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//内存紧张了，直接通告0窗口</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(inet_csk(sk)-&gt;icsk_ack.pending &amp; ICSK_ACK_NOMEM))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//剩余的窗口空间</span></span><br><span class="line">	cur_win = tcp_receive_window(tp);</span><br><span class="line">	<span class="comment">//计算新窗口</span></span><br><span class="line">	new_win = __tcp_select_window(sk);</span><br><span class="line">	<span class="comment">//新窗口比当前窗口还小</span></span><br><span class="line">	<span class="keyword">if</span> (new_win &lt; cur_win) &#123; </span><br><span class="line">		<span class="comment">/* Danger Will Robinson!</span></span><br><span class="line"><span class="comment">		 * Don&#x27;t update rcv_wup/rcv_wnd here or else</span></span><br><span class="line"><span class="comment">		 * we will not be able to advertise a zero</span></span><br><span class="line"><span class="comment">		 * window in time.  --DaveM</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Relax Will Robinson.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//是否允许 shrink 通常是false吧</span></span><br><span class="line">		<span class="keyword">if</span> (!READ_ONCE(net-&gt;ipv4.sysctl_tcp_shrink_window) || !tp-&gt;rx_opt.rcv_wscale) &#123;</span><br><span class="line">			<span class="comment">/* Never shrink the offered window */</span></span><br><span class="line">			<span class="keyword">if</span> (new_win == <span class="number">0</span>) <span class="comment">//实在是太小了</span></span><br><span class="line">				NET_INC_STATS(net, LINUX_MIB_TCPWANTZEROWINDOWADV);</span><br><span class="line">			new_win = ALIGN(cur_win, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);<span class="comment">//保持窗口大小不变基于当前剩余窗口cur_win</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通告窗口的大小</span></span><br><span class="line">	tp-&gt;rcv_wnd = new_win;</span><br><span class="line">	<span class="comment">//记录本次更新窗口的序号</span></span><br><span class="line">	tp-&gt;rcv_wup = tp-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we do not exceed the maximum possible</span></span><br><span class="line"><span class="comment">	 * scaled window.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//限制最大窗口</span></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;rx_opt.rcv_wscale &amp;&amp;</span><br><span class="line">	    READ_ONCE(net-&gt;ipv4.sysctl_tcp_workaround_signed_windows))</span><br><span class="line">		new_win = min(new_win, MAX_TCP_WINDOW);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		new_win = min(new_win, (<span class="number">65535U</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale)); <span class="comment">//启用 wscale 时</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RFC1323 scaling applied */</span></span><br><span class="line">	new_win &gt;&gt;= tp-&gt;rx_opt.rcv_wscale; <span class="comment">//变成缩放后的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we advertise zero window, disable fast path. */</span></span><br><span class="line">	<span class="keyword">if</span> (new_win == <span class="number">0</span>) &#123;</span><br><span class="line">		tp-&gt;pred_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (old_win)</span><br><span class="line">			NET_INC_STATS(net, LINUX_MIB_TCPTOZEROWINDOWADV);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_win == <span class="number">0</span>) &#123;</span><br><span class="line">		NET_INC_STATS(net, LINUX_MIB_TCPFROMZEROWINDOWADV);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> new_win;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/30/tcp_write_xmit(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-30 22:00:00 / 修改时间：22:33:17" itemprop="dateCreated datePublished" datetime="2025-11-30T22:00:00+08:00">2025-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/30/tcp_write_xmit(%E4%B8%89)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit</code>中判断完是否会由于<code>nagle</code>算法和<code>tso</code>推迟发送后接下来会基于对端窗口和<code>nagle</code>算法调用<code>tcp_mss_split_point</code>计算一次发包的最大长度（这个值在下面会和<code>skb</code>的<code>len</code>比较，如果小于<code>len</code>就会拆包）具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">tcp_mss_split_point</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> <span class="type">int</span> mss_now,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> <span class="type">int</span> max_segs,</span></span><br><span class="line"><span class="params">					<span class="type">int</span> nonagle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	u32 partial, needed, window, max_len;</span><br><span class="line"></span><br><span class="line">	window = tcp_wnd_end(tp) - TCP_SKB_CB(skb)-&gt;seq; <span class="comment">//接收窗口剩余空间</span></span><br><span class="line">	max_len = mss_now * max_segs;					<span class="comment">//这里是cwnd</span></span><br><span class="line">	<span class="comment">//如果小于可用窗口的大小，且不是最后一个数据包，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (likely(max_len &lt;= window &amp;&amp; skb != tcp_write_queue_tail(sk)))</span><br><span class="line">		<span class="keyword">return</span> max_len;</span><br><span class="line">	<span class="comment">//计算实际需要长度</span></span><br><span class="line">	needed = min(skb-&gt;len, window);</span><br><span class="line">	<span class="comment">//最大长度检查</span></span><br><span class="line">	<span class="keyword">if</span> (max_len &lt;= needed)</span><br><span class="line">		<span class="keyword">return</span> max_len;</span><br><span class="line">	<span class="comment">//计算最后一段是否是不完整的 MSS</span></span><br><span class="line">	partial = needed % mss_now;</span><br><span class="line">	<span class="comment">/* If last segment is not a full MSS, check if Nagle rules allow us</span></span><br><span class="line"><span class="comment">	 * to include this last segment in this skb.</span></span><br><span class="line"><span class="comment">	 * Otherwise, we&#x27;ll split the skb at last MSS boundary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//nagle算法检查</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_nagle_check(partial != <span class="number">0</span>, tp, nonagle))</span><br><span class="line">		<span class="keyword">return</span> needed - partial;</span><br><span class="line">	<span class="comment">//返回实际需要的长度</span></span><br><span class="line">	<span class="keyword">return</span> needed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_mss_split_point</code><strong>首先计算对端接收窗口的剩余空间，然后计算拥塞窗口剩余空间</strong>，<strong>如果拥塞窗口大小小于对端通告窗口大小，且不是最后一个数据包，直接返回拥塞窗口大小，表示直接发送一个大包，注意通常都走这里</strong>。</p>
<p>否则需要计算真正可发送的长度（受窗口限制），实际可发送最大长度&#x3D; min(当前包长度, 对端窗口剩余) 如果这个值大于拥塞窗口的大小，那就发送拥塞窗口大小的长度，否则计算最后没有对齐的一部分的大小，并进行<code>nagle</code>算法的判断。如果需要 Nagle则返回 <code>needed - partial</code></p>
<p>上述计算完成可以发送的大小后，则需要和当前数据包的长度进行比较，如果数据包的长度超过了上述计算的长度，则<strong>需要调用<code>tso_fragment</code>在四层就进行分段</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tso_fragment</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nlen = skb-&gt;len - len; <span class="comment">//新包的长度（剩余部分）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All of a TSO frame must be composed of paged data.  */</span></span><br><span class="line">	<span class="comment">//这里很重要，负载必须要在非线性部分</span></span><br><span class="line">	DEBUG_NET_WARN_ON_ONCE(skb-&gt;len != skb-&gt;data_len);</span><br><span class="line">	<span class="comment">//申请一个数据包</span></span><br><span class="line">	buff = tcp_stream_alloc_skb(sk, gfp, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!buff))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	skb_copy_decrypted(buff, skb);</span><br><span class="line">	mptcp_skb_ext_copy(buff, skb);</span><br><span class="line">	<span class="comment">//更新内存记账 </span></span><br><span class="line">	sk_wmem_queued_add(sk, buff-&gt;truesize);</span><br><span class="line">	sk_mem_charge(sk, buff-&gt;truesize);</span><br><span class="line">	buff-&gt;truesize += nlen;</span><br><span class="line">	skb-&gt;truesize -= nlen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Correct the sequence numbers. */</span></span><br><span class="line">	<span class="comment">//设置序列号</span></span><br><span class="line">	TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq + len;</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PSH and FIN should only be set in the second packet. */</span></span><br><span class="line">	<span class="comment">//设置标志位</span></span><br><span class="line">	flags = TCP_SKB_CB(skb)-&gt;tcp_flags;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;tcp_flags = flags &amp; ~(TCPHDR_FIN | TCPHDR_PSH);</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;tcp_flags = flags;</span><br><span class="line"></span><br><span class="line">	tcp_skb_fragment_eor(skb, buff);</span><br><span class="line">	<span class="comment">//真正的分割数据包</span></span><br><span class="line">	skb_split(skb, buff, len);</span><br><span class="line">	tcp_fragment_tstamp(skb, buff);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fix up tso_factor for both original and new SKB.  */</span></span><br><span class="line">	<span class="comment">//重新计算GSO信息</span></span><br><span class="line">	tcp_set_skb_tso_segs(skb, mss_now);</span><br><span class="line">	tcp_set_skb_tso_segs(buff, mss_now);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Link BUFF into the send queue. */</span></span><br><span class="line">	__skb_header_release(buff);</span><br><span class="line">	<span class="comment">//新 SKB 插入到原 SKB 之后的发送队列中！</span></span><br><span class="line">	tcp_insert_write_queue_after(skb, buff, sk, TCP_FRAG_IN_WRITE_QUEUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tso_fragment</code>的逻辑中上来就先判断判断负载是否都只存在于非线性部分，<strong>这里就是数据包为什么需要用<code>page</code>来管理的关键，当需要拆分数据包时，仅通过操作指针就可以完成！</strong></p>
<p><code>tso_fragment</code>中首先申请数据包，之后更新内存记账等相关字段，并设置当前数据包的序列号和标志位，调用<code>skb_split</code>完成执行 SKB 数据分页拆分，调用<code>tcp_set_skb_tso_segs</code>重新设置GSO字段，之后将新 <code>skb</code> 插入到原 <code>skb</code> 之后的发送队列中，更新GSO字段的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_set_skb_tso_segs</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> mss_now)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置tcp_gso_size 和gso_segs</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt;= mss_now) &#123;</span><br><span class="line">		<span class="comment">/* Avoid the costly divide in the normal</span></span><br><span class="line"><span class="comment">		 * non-TSO case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//设置段数为1</span></span><br><span class="line">		tcp_skb_pcount_set(skb, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//设置gso size</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_gso_size = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tcp_skb_pcount_set(skb, DIV_ROUND_UP(skb-&gt;len, mss_now)); <span class="comment">//设置有多少个段</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_gso_size = mss_now; <span class="comment">//设置每个段有多少个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成数据包的拆分后(如果需要拆分)，则**接下来会判断是否因TSQ机制(限制单个套接字占用协议栈过多资源)，**暂停发送，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/27/tcp_write_xmit(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-27 22:00:00 / 修改时间：23:23:28" itemprop="dateCreated datePublished" datetime="2025-11-27T22:00:00+08:00">2025-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit</code>在进入<code>while</code>循环遍历发送数据包之前，首先计算<code>max_segs</code>的大小，这里需要注意，<code>tcp_sendmsg_locked</code>中只是尽可能的将用户数据<code>copy</code>放到一个<code>skb</code>中，而接下来的工作是真正决定是否能发送，能发送多少。</p>
<p>首先调用<code>tcp_tso_segs</code>计算当前数据包的最大段数(<code>max_segs</code>根据<code>rtt</code>计算)，最大段数和当前的<code>mss</code>决定了一次<code>while</code>循环最多能发送多少数据，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">tcp_tso_segs</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> *<span class="title">ca_ops</span> =</span> inet_csk(sk)-&gt;icsk_ca_ops;</span><br><span class="line">	u32 min_tso, tso_segs;</span><br><span class="line">	<span class="comment">//拥塞算法是否提供了钩子，bbr就提供了，否则使用默认的，通常为2 </span></span><br><span class="line">	min_tso = ca_ops-&gt;min_tso_segs ?</span><br><span class="line">			ca_ops-&gt;min_tso_segs(sk) :</span><br><span class="line">			READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_min_tso_segs);</span><br><span class="line">	<span class="comment">//根据rtt计算段数 </span></span><br><span class="line">	tso_segs = tcp_tso_autosize(sk, mss_now, min_tso);</span><br><span class="line">	<span class="keyword">return</span> <span class="type">min_t</span>(u32, tso_segs, sk-&gt;sk_gso_max_segs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>tcp_tso_segs</code>进一步调用<code>tcp_tso_autosize</code>根据<code>rtt</code>自适应调整段数的大小，具体代码如下所示：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">tcp_tso_autosize</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> min_tso_segs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bytes;</span><br><span class="line">	u32 r;</span><br><span class="line">	<span class="comment">//转换成每秒多少字节</span></span><br><span class="line">	bytes = sk-&gt;sk_pacing_rate &gt;&gt; READ_ONCE(sk-&gt;sk_pacing_shift);</span><br><span class="line">	<span class="comment">//基于rtt做调整，r可以理解为延迟的严重程度吧</span></span><br><span class="line">	r = tcp_min_rtt(tcp_sk(sk)) &gt;&gt; READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_tso_rtt_log);<span class="comment">//默认是9 标志512是一个合理的网络延迟变化粒度</span></span><br><span class="line">	<span class="keyword">if</span> (r &lt; BITS_PER_TYPE(sk-&gt;sk_gso_max_size))<span class="comment">//这是什么意思？</span></span><br><span class="line">		bytes += sk-&gt;sk_gso_max_size &gt;&gt; r; <span class="comment">//这里的意思就是延迟越大，max_size 越小</span></span><br><span class="line">	<span class="comment">//钳制</span></span><br><span class="line">	bytes = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, bytes, sk-&gt;sk_gso_max_size);</span><br><span class="line">	<span class="comment">//计算段数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">max_t</span>(u32, bytes / mss_now, min_tso_segs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码根据带宽估算和 <code>RTT</code> 动态决定 <code>GSO</code> 报文大小：<code>RTT</code> 越大网络越远，单个 <code>GSO</code>包越小；<code>RTT</code> 越小网络越近，<code>GSO</code>越大以减少 <code>CPU</code> 负载</p>
<p>计算最大段数之后之后进入主要流程，循环从队列头部中获取数据包。</p>
<p>首先调用<code>tcp_pacing_check</code>，判断是否可以立即发送数据包，<code>tcp_pacing_check</code>中首先判断是否需要<code>tcp</code>内部自己做<code>pacing</code>，下一个数据包要发送的时间小于等于当前的时钟（理想发包时间已经到了 ），则可以直接发送，不需要启动定时器，否则表示时间还没有到，返回<code>true</code>表示不立即发送，<strong>注意：这里启动了<code>pacing</code>定时器</strong>，上述具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_pacing_check</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//sch_fq 开启这个就会返回false，表示不需要tcp内部自己pacing ，反之，如果为brr 会继续向下执行</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_needs_internal_pacing(sk))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//下一个数据包要发送的时间小于等于当前的时钟，则可以直接发送，不需要启动定时器</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tcp_wstamp_ns &lt;= tp-&gt;tcp_clock_cache)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//如果定时器还没在排队，就启动一个pacing定时器 如果不能发送的情况 这里用软中断上下文去发包</span></span><br><span class="line">	<span class="keyword">if</span> (!hrtimer_is_queued(&amp;tp-&gt;pacing_timer)) &#123;</span><br><span class="line">		hrtimer_start(&amp;tp-&gt;pacing_timer,</span><br><span class="line">			      ns_to_ktime(tp-&gt;tcp_wstamp_ns),</span><br><span class="line">			      HRTIMER_MODE_ABS_PINNED_SOFT);</span><br><span class="line">		sock_hold(sk);<span class="comment">//这里引用计数++，防止socket被提前释放</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以发送，则调用<code>tcp_init_tso_segs</code>根据当前数据包的总长度和<code>mss</code>计算当前数据包的段数，这里注意上面是根据<code>rtt</code>计算最大的段数，这里计算的是当前数据包的段数，不矛盾，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/tcp_write_xmit(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-25 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-25T22:00:00+08:00">2025-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-26 21:43:00" itemprop="dateModified" datetime="2025-11-26T21:43:00+08:00">2025-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/25/tcp_write_xmit(%E4%B8%80)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit()</code> 是 TCP 协议栈中负责真正“把待发送数据从发送队列写到网络上”的核心调度函数，它<strong>依据拥塞窗口、接收窗口、Nagle、TSO&#x2F;GSO、 pacing、MTU 探测等策略，决定是否发送、如何发送以及发送多少数据</strong></p>
<p><strong>注意：除了进程上下文中通过<code>push_one</code>, <code>__tcp_push_pending_frames</code>, <code>tcp_push</code>会调用<code>tcp_write_xmit</code>发送报文，软中段上下文中，<code>TLP</code>定时器到期，<code>TSQ</code>机制被触发，或者<code>tcp_data_snd_check</code>等地方也会调用改接口尝试发送数据包。</strong></p>
<p><code>tcp_write_xmit</code>具体逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_write_xmit</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">int</span> nonagle,</span></span><br><span class="line"><span class="params">			   <span class="type">int</span> push_one, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tso_segs, sent_pkts;</span><br><span class="line">	<span class="type">int</span> cwnd_quota;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_cwnd_limited = <span class="literal">false</span>, is_rwnd_limited = <span class="literal">false</span>;</span><br><span class="line">	u32 max_segs;</span><br><span class="line"></span><br><span class="line">	sent_pkts = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//更新两个时间戳</span></span><br><span class="line">	tcp_mstamp_refresh(tp);</span><br><span class="line">	<span class="keyword">if</span> (!push_one) &#123;</span><br><span class="line">		<span class="comment">/* Do MTU probing. */</span></span><br><span class="line">		<span class="comment">//是否需要进行tcp的mtu探</span></span><br><span class="line">		result = tcp_mtu_probe(sk);</span><br><span class="line">		<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			sent_pkts = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据rtt拥塞算法等计算段数 </span></span><br><span class="line">	max_segs = tcp_tso_segs(sk, mss_now);</span><br><span class="line">	<span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tp-&gt;repair) &amp;&amp; tp-&gt;repair_queue == TCP_SEND_QUEUE) &#123;</span><br><span class="line">			<span class="comment">/* &quot;skb_mstamp_ns&quot; is used as a start point for the retransmit timer */</span></span><br><span class="line">			tp-&gt;tcp_wstamp_ns = tp-&gt;tcp_clock_cache;</span><br><span class="line">			skb_set_delivery_time(skb, tp-&gt;tcp_wstamp_ns, <span class="literal">true</span>);</span><br><span class="line">			list_move_tail(&amp;skb-&gt;tcp_tsorted_anchor, &amp;tp-&gt;tsorted_sent_queue);</span><br><span class="line">			tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">			<span class="keyword">goto</span> repair; <span class="comment">/* Skip network transmission */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//根据发送速率计算是否可以立即发送这里可能会直接break</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_pacing_check(sk))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//根据mss计算每个skb有多少个段</span></span><br><span class="line">		tso_segs = tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">		BUG_ON(!tso_segs);</span><br><span class="line">		<span class="comment">//计算拥塞窗口的大小</span></span><br><span class="line">		cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">		<span class="keyword">if</span> (!cwnd_quota) &#123;</span><br><span class="line">			<span class="keyword">if</span> (push_one == <span class="number">2</span>) <span class="comment">//这里表示的是TLP探测包，必须能发出去</span></span><br><span class="line">				<span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">				cwnd_quota = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//拥塞窗口不够用了，直接返回</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//是否超出了对端窗口的边界，如果超出了则设置标志位</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) &#123;</span><br><span class="line">			is_rwnd_limited = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//是否是一个小包</span></span><br><span class="line">		<span class="keyword">if</span> (tso_segs == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否因为nagle而不发送数据包，注意这里unlikely的</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!tcp_nagle_test(tp, skb, mss_now,</span><br><span class="line">			<span class="comment">//如果不是最后一个数据包，就立即推送，合理 因为不能然后面的包不发吧</span></span><br><span class="line">						     (tcp_skb_is_last(sk, skb) ? </span><br><span class="line">						      nonagle : TCP_NAGLE_PUSH))))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果当前数据包有多个段，且不是发送一个数据包的情况下，判断是否由于tso 推迟发送</span></span><br><span class="line">			<span class="keyword">if</span> (!push_one &amp;&amp;</span><br><span class="line">			    tcp_tso_should_defer(sk, skb, &amp;is_cwnd_limited,</span><br><span class="line">						 &amp;is_rwnd_limited, max_segs))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		limit = mss_now;</span><br><span class="line">		<span class="comment">//多个段的情况</span></span><br><span class="line">		<span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">			<span class="comment">//基于对端窗口和nagle算法，根据对端窗口和拥塞窗口 返回的是实际需要的长度，注意这里是拥塞状态也直接发送了</span></span><br><span class="line">			limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">						    <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">							  cwnd_quota,  <span class="comment">//拥塞窗口的大小</span></span><br><span class="line">							  max_segs),  <span class="comment">//最大的段数，与数据包无关</span></span><br><span class="line">						    nonagle);</span><br><span class="line">		<span class="comment">//如果数据包的长度大于了窗口的限制，那这里要把直接封装的数据包拆分了</span></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">		    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp))) <span class="comment">//这里其实就是为什么负载用页去管理的原因！！！</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//因为TSQ机制直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_small_queue_check(sk, skb, <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Argh, we hit an empty skb(), presumably a thread</span></span><br><span class="line"><span class="comment">		 * is sleeping in sendmsg()/sk_stream_wait_memory().</span></span><br><span class="line"><span class="comment">		 * We do not want to send a pure-ack packet and have</span></span><br><span class="line"><span class="comment">		 * a strange looking rtx queue with empty packet(s).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//空包</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//真正的发送数据包</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">repair:</span><br><span class="line">		<span class="comment">/* Advance the send_head.  This one is sent out.</span></span><br><span class="line"><span class="comment">		 * This call will increment packets_out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//更新下一个待发送的序列号 ，加入重传队列</span></span><br><span class="line">		tcp_event_new_data_sent(sk, skb);</span><br><span class="line">		<span class="comment">//计算发送小包序列号，nagle算法会设置</span></span><br><span class="line">		tcp_minshall_update(tp, mss_now, skb);</span><br><span class="line">		sent_pkts += tcp_skb_pcount(skb); <span class="comment">//计算发出去的段数</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (push_one)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//更新各个阶段的时间</span></span><br><span class="line">	<span class="keyword">if</span> (is_rwnd_limited)</span><br><span class="line">		tcp_chrono_start(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tcp_chrono_stop(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">	<span class="comment">//拥塞窗口受限</span></span><br><span class="line">	is_cwnd_limited |= (tcp_packets_in_flight(tp) &gt;= tcp_snd_cwnd(tp));</span><br><span class="line">	<span class="keyword">if</span> (likely(sent_pkts || is_cwnd_limited))</span><br><span class="line">		tcp_cwnd_validate(sk, is_cwnd_limited);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(sent_pkts)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tcp_in_cwnd_reduction(sk))</span><br><span class="line">			tp-&gt;prr_out += sent_pkts;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Send one loss probe per tail loss episode. */</span></span><br><span class="line">		<span class="comment">//激活tlp定时器，如果等于2表示已经激活过了</span></span><br><span class="line">		<span class="keyword">if</span> (push_one != <span class="number">2</span>)</span><br><span class="line">			tcp_schedule_loss_probe(sk, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !tp-&gt;packets_out &amp;&amp; !tcp_write_queue_empty(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要关注<code>tcp_write_xmit</code>中第三个参数和第四个参数：</p>
<p> <strong><code>nonagle</code> 用来控制是否绕过 Nagle 算法、是否允许立刻发送小包（例如 <code>TCP_NAGLE_OFF</code> 直接允许发送，<code>TCP_NAGLE_CORK</code> 则尽量攒包）；</strong><br> <strong><code>push_one</code> 则控制本次调用最多发送多少个报文，当为 <code>0</code> 时按正常逻辑尽量多发，当为 <code>1</code> 时最多只发一个报文，而当为 <code>2</code> 时可以临时忽略拥塞窗口限制强制发出去（典型用于 TLP 探测）。</strong></p>
<p><code>tcp_write_xmit</code>首先更新了时间戳字段，<code>bbr</code>算法或者<code>rto</code>计算中会用到。之后会调用<code>tcp_mtu_probe</code>判断是否需要进行MTU探测（只发送一个数据包的情况下肯定不探测了），<strong>注意这里是传输层面的MTU探测，区别于ICMP的MTU探测</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_mtu_probe</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">nskb</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="type">int</span> probe_size;</span><br><span class="line">	<span class="type">int</span> size_needed;</span><br><span class="line">	<span class="type">int</span> copy, len;</span><br><span class="line">	<span class="type">int</span> mss_now;</span><br><span class="line">	<span class="type">int</span> interval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not currently probing/verifying,</span></span><br><span class="line"><span class="comment">	 * not in recovery,</span></span><br><span class="line"><span class="comment">	 * have enough cwnd, and</span></span><br><span class="line"><span class="comment">	 * not SACKing (the variable headers throw things off)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!icsk-&gt;icsk_mtup.enabled ||                 <span class="comment">//MTU 探测功能已启用 </span></span><br><span class="line">		   icsk-&gt;icsk_mtup.probe_size ||				   <span class="comment">//当前没有正在进行的探测</span></span><br><span class="line">		   inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open ||   <span class="comment">//TCP 连接处于 Open 状态</span></span><br><span class="line">		   tcp_snd_cwnd(tp) &lt; <span class="number">11</span> ||						   <span class="comment">//拥塞窗口足够大</span></span><br><span class="line">		   tp-&gt;rx_opt.num_sacks || tp-&gt;rx_opt.dsack))	   <span class="comment">//没有 SACK 数据</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use binary search for probe_size between tcp_mss_base,</span></span><br><span class="line"><span class="comment">	 * and current mss_clamp. if (search_high - search_low)</span></span><br><span class="line"><span class="comment">	 * smaller than a threshold, backoff from probing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//计算当前mss</span></span><br><span class="line">	mss_now = tcp_current_mss(sk);</span><br><span class="line">	<span class="comment">//二分查找计算探测的大小</span></span><br><span class="line">	probe_size = tcp_mtu_to_mss(sk, (icsk-&gt;icsk_mtup.search_high +</span><br><span class="line">				    icsk-&gt;icsk_mtup.search_low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//确认后面还有足够多的数据，否则可能就没法确认探测包了？</span></span><br><span class="line">	size_needed = probe_size + (tp-&gt;reordering + <span class="number">1</span>) * tp-&gt;mss_cache;</span><br><span class="line">	<span class="comment">//计算最大最小探测直接的差值</span></span><br><span class="line">	interval = icsk-&gt;icsk_mtup.search_high - icsk-&gt;icsk_mtup.search_low;</span><br><span class="line">	<span class="comment">/* When misfortune happens, we are reprobing actively,</span></span><br><span class="line"><span class="comment">	 * and then reprobe timer has expired. We stick with current</span></span><br><span class="line"><span class="comment">	 * probing process by not resetting search range to its orignal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//probesize太大 或者搜索区间已经小于系统配置的探测阈值</span></span><br><span class="line">	<span class="keyword">if</span> (probe_size &gt; tcp_mtu_to_mss(sk, icsk-&gt;icsk_mtup.search_high) ||</span><br><span class="line">	    interval &lt; READ_ONCE(net-&gt;ipv4.sysctl_tcp_probe_threshold)) &#123;</span><br><span class="line">		<span class="comment">/* Check whether enough time has elaplased for</span></span><br><span class="line"><span class="comment">		 * another round of probing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//根据时间判断是否需要更新探测的上限</span></span><br><span class="line">		tcp_mtu_check_reprobe(sk);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Have enough data in the send queue to probe? */</span></span><br><span class="line">	<span class="comment">//计算待发送的数据量，如果不足以探测，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;write_seq - tp-&gt;snd_nxt &lt; size_needed)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//对端通告的窗口太小，也直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;snd_wnd &lt; size_needed)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//计算是否超出了窗口的右边界</span></span><br><span class="line">	<span class="keyword">if</span> (after(tp-&gt;snd_nxt + size_needed, tcp_wnd_end(tp)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do we need to wait to drain cwnd? With none in flight, don&#x27;t stall */</span></span><br><span class="line">	<span class="comment">//在途数据包大于拥塞窗口</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_packets_in_flight(tp) + <span class="number">2</span> &gt; tcp_snd_cwnd(tp)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!tcp_packets_in_flight(tp)) <span class="comment">//没有在途数据包？上面拥塞窗口很小？</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查数据包是否可以合并</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_can_coalesce_send_queue_head(sk, probe_size))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re allowed to probe.  Build it now. */</span></span><br><span class="line">	<span class="comment">//申请一个skb</span></span><br><span class="line">	nskb = tcp_stream_alloc_skb(sk, GFP_ATOMIC, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!nskb)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* build the payload, and be prepared to abort if this fails. */</span></span><br><span class="line">	<span class="comment">//这里是将发送队列中的数据包，零拷贝的方式放到探测的数据包中</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_clone_payload(sk, nskb, probe_size)) &#123;</span><br><span class="line">		tcp_skb_tsorted_anchor_cleanup(nskb);</span><br><span class="line">		consume_skb(nskb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里要重新更新内存记账</span></span><br><span class="line">	sk_wmem_queued_add(sk, nskb-&gt;truesize);</span><br><span class="line">	sk_mem_charge(sk, nskb-&gt;truesize);</span><br><span class="line">	<span class="comment">//取出队列中的地一个数据包</span></span><br><span class="line">	skb = tcp_send_head(sk);</span><br><span class="line">	skb_copy_decrypted(nskb, skb);</span><br><span class="line">	mptcp_skb_ext_copy(nskb, skb);</span><br><span class="line">	<span class="comment">//设置数据包的序列号和ack标志</span></span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + probe_size;</span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;tcp_flags = TCPHDR_ACK;</span><br><span class="line">	<span class="comment">//插入队列头，并</span></span><br><span class="line">	tcp_insert_write_queue_before(nskb, skb, sk);</span><br><span class="line">	tcp_highest_sack_replace(sk, skb, nskb);</span><br><span class="line"></span><br><span class="line">	len = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//把被和合并的小包unlink</span></span><br><span class="line">	tcp_for_write_queue_from_safe(skb, next, sk) &#123;</span><br><span class="line">		copy = <span class="type">min_t</span>(<span class="type">int</span>, skb-&gt;len, probe_size - len);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len &lt;= copy) &#123;</span><br><span class="line">			<span class="comment">/* We&#x27;ve eaten all the data from this skb.</span></span><br><span class="line"><span class="comment">			 * Throw it away. */</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags;</span><br><span class="line">			<span class="comment">/* If this is the last SKB we copy and eor is set</span></span><br><span class="line"><span class="comment">			 * we need to propagate it to the new skb.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;eor = TCP_SKB_CB(skb)-&gt;eor;</span><br><span class="line">			tcp_skb_collapse_tstamp(nskb, skb);</span><br><span class="line">			tcp_unlink_write_queue(skb, sk); <span class="comment">//从队列中摘下来</span></span><br><span class="line">			tcp_wmem_free_skb(sk, skb);		 <span class="comment">//释放数据包，更新内存记账 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">///处理部分skb的情况 调用__pskb_trim_head减枝</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags &amp;</span><br><span class="line">						   ~(TCPHDR_FIN|TCPHDR_PSH);</span><br><span class="line">			__pskb_trim_head(skb, copy);</span><br><span class="line">			tcp_set_skb_tso_segs(skb, mss_now); <span class="comment">//设置保留数据包的GSO相关字段</span></span><br><span class="line">			TCP_SKB_CB(skb)-&gt;seq += copy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len += copy;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt;= probe_size)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化GSO字段信息</span></span><br><span class="line">	tcp_init_tso_segs(nskb, nskb-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re ready to send.  If this fails, the probe will</span></span><br><span class="line"><span class="comment">	 * be resegmented into mss-sized pieces by tcp_write_xmit().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_transmit_skb(sk, nskb, <span class="number">1</span>, GFP_ATOMIC)) &#123;</span><br><span class="line">		<span class="comment">/* Decrement cwnd here because we are sending</span></span><br><span class="line"><span class="comment">		 * effectively two packets. */</span></span><br><span class="line">		tcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - <span class="number">1</span>);<span class="comment">//更新拥塞窗口--</span></span><br><span class="line">		tcp_event_new_data_sent(sk, nskb);</span><br><span class="line"></span><br><span class="line">		icsk-&gt;icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb-&gt;len);<span class="comment">//记录mtu探测的相关字段</span></span><br><span class="line">		tp-&gt;mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)-&gt;seq;</span><br><span class="line">		tp-&gt;mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)-&gt;end_seq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_mtu_probe</code>中首先判断是否不需要进行MTU探测，如果MTU 探测功能已启用 ，<strong>当前没有正在进行的探测，TCP 连接处于 Open 状态，拥塞窗口足够大，没有 SACK 数据的情况下不需要探测</strong>，否则进入MTU探测的逻辑。</p>
<p>首先计算当前的<code>mss</code>，之后根据根据二分查找计算<code>probe_size</code>探测报文的大小，<strong>这里注意<code>search_high</code>和 <code>low</code>在<code>tcp_mtup_init</code>中会设置初始值</strong>，计算完成探测报文的大小后，<strong>会进一步确认后续数据是否足够数据确认的这个探测报文</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/" class="post-title-link" itemprop="url">TCP输出tcp_sendmsg_locked（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-23 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-23T22:00:00+08:00">2025-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-25 21:34:57" itemprop="dateModified" datetime="2025-11-25T21:34:57+08:00">2025-11-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_sendmsg_locked</code>申请数据包成功并调用<code>tcp_skb_entail</code>将数据包入队后，接下来的任务就是将用户数据包<code>copy</code>到<code>skb</code>非线性部分中。</p>
<p>首先调用<code>sk_page_frag</code>从当前进程获取一个<code>page</code>，之后调用<code>sk_page_frag_refill</code>查看是否还有足够的空间可以使用，上述过程具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page_frag *<span class="title function_">sk_page_frag</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_use_task_frag)</span><br><span class="line">		<span class="keyword">return</span> &amp;current-&gt;task_frag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;sk-&gt;sk_frag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sk_page_frag_refill</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> page_frag *pfrag)</span></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//是否有32字节可以写的空间</span></span><br><span class="line">	<span class="keyword">if</span> (likely(skb_page_frag_refill(<span class="number">32U</span>, pfrag, sk-&gt;sk_allocation)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//分配失败，进入内存压力</span></span><br><span class="line">	sk_enter_memory_pressure(sk);</span><br><span class="line">	<span class="comment">//减小发送缓冲区</span></span><br><span class="line">	sk_stream_moderate_sndbuf(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>skb_page_frag_refill</code>中会进一步判断拿到的页是否有32字节可写的空间，如果空间不够则会申请一个新的页，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skb_page_frag_refill</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sz, <span class="keyword">struct</span> page_frag *pfrag, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pfrag-&gt;page) &#123;</span><br><span class="line">		<span class="keyword">if</span> (page_ref_count(pfrag-&gt;page) == <span class="number">1</span>) &#123; 	   <span class="comment">//只有自己在用</span></span><br><span class="line">			pfrag-&gt;offset = <span class="number">0</span>; 						 <span class="comment">//offset设置为0 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pfrag-&gt;offset + sz &lt;= pfrag-&gt;size) 		   <span class="comment">//别人在用，看空间是否够，如果够也直接返回了</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		put_page(pfrag-&gt;page);  					  <span class="comment">//不够，直接put掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备分配新页</span></span><br><span class="line">	pfrag-&gt;offset = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">//这里通常不会走把</span></span><br><span class="line">	<span class="keyword">if</span> (SKB_FRAG_PAGE_ORDER &amp;&amp;</span><br><span class="line">	    !static_branch_unlikely(&amp;net_high_order_alloc_disable_key)) &#123;</span><br><span class="line">		<span class="comment">/* Avoid direct reclaim but allow kswapd to wake */</span></span><br><span class="line">		pfrag-&gt;page = alloc_pages((gfp &amp; ~__GFP_DIRECT_RECLAIM) |</span><br><span class="line">					  __GFP_COMP | __GFP_NOWARN |</span><br><span class="line">					  __GFP_NORETRY,</span><br><span class="line">					  SKB_FRAG_PAGE_ORDER);</span><br><span class="line">		<span class="keyword">if</span> (likely(pfrag-&gt;page)) &#123;</span><br><span class="line">			pfrag-&gt;size = PAGE_SIZE &lt;&lt; SKB_FRAG_PAGE_ORDER;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//分配一个page</span></span><br><span class="line">	pfrag-&gt;page = alloc_page(gfp);</span><br><span class="line">	<span class="keyword">if</span> (likely(pfrag-&gt;page)) &#123;</span><br><span class="line">		pfrag-&gt;size = PAGE_SIZE;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述获取到<code>page</code>后，进一步调用<code>skb_can_coalesce</code>判断当前获取到的页是否已经是<code>skb</code>管理的页，如果不是，且当前<code>skb</code>已将有17个非线性部分的页了，则直接重新申请<code>skb</code>同时设置<code>push</code>标志位，并将标记为不能合并（后续用于指导设置页的元数据)</p>
<p>判断是否可以合并的逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">skb_can_coalesce</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="keyword">struct</span> page *page, <span class="type">int</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb_zcopy(skb)) <span class="comment">//零拷贝 skb 不能合并</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (i) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">skb_frag_t</span> *frag = &amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>]; <span class="comment">//skb的最后一个页？</span></span><br><span class="line">		<span class="comment">//当前写入数据使用的 page 与最后的 frag 是同一物理页</span></span><br><span class="line">		<span class="keyword">return</span> page == skb_frag_page(frag) &amp;&amp;   <span class="comment">//判断是否是同一个页</span></span><br><span class="line">		       off == skb_frag_off(frag) + skb_frag_size(frag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述工作完成后，会计算当前获取的页还有头多少可以<code>copy</code>的空间，并调用<code>tcp_wmem_schedule</code>更新内存记账，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_wmem_schedule</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> copy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> left;</span><br><span class="line">	<span class="comment">//判断是否达到全局的内存压力，如果还有足够发送空间，则直接允许这次请求</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sk_wmem_schedule(sk, copy)))</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We could be in trouble if we have nothing queued.</span></span><br><span class="line"><span class="comment">	 * Use whatever is left in sk-&gt;sk_forward_alloc and tcp_wmem[0]</span></span><br><span class="line"><span class="comment">	 * to guarantee some progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//正常内存预算不够了 TCP 进入资源紧张状态</span></span><br><span class="line">	left = sock_net(sk)-&gt;ipv4.sysctl_tcp_wmem[<span class="number">0</span>] - sk-&gt;sk_wmem_queued;</span><br><span class="line">	<span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="comment">//最低保障区间还有空间，强制额外分配内存，这里可以看到每个sk最少可以用4k，没使用到4k的时候即使资源紧张也会强制调度</span></span><br><span class="line">		sk_forced_mem_schedule(sk, min(left, copy));</span><br><span class="line">	<span class="keyword">return</span> min(copy, sk-&gt;sk_forward_alloc); <span class="comment">//回真正允许写入的数据大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/20/tcp_sendmsg_locked(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/20/tcp_sendmsg_locked(%E4%BA%8C)/" class="post-title-link" itemprop="url">TCP输出 tcp_sendmsg_locked（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-20 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-20T22:00:00+08:00">2025-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-07 21:50:01" itemprop="dateModified" datetime="2025-12-07T21:50:01+08:00">2025-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/20/tcp_sendmsg_locked(%E4%BA%8C)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/20/tcp_sendmsg_locked(%E4%BA%8C)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_sendmsg_locked</code>中计算得到<code>size_goal</code>后，会进入<code>while</code>大循环完成<code>skb</code>申请，数据拷贝，更新内存记账等关键操作</p>
<p>循环内部首先从队列尾部取出一个数据包并计算是否还有剩余的空间可以拷贝用户的数据，这里注意，有用户调用<code>send</code>发送数据包后，协议栈可能不会立马发送数据（比如<code>nagle</code>），因此队列尾部是可以拿到数据包的。</p>
<p>首先判断队尾数据包（如果有）是否还有待拷贝的空间，没有则会尝试申请数据包，申请数据包前会首先判断是否有缓冲区，如果协议栈中当前<code>sk</code>发送队列使用总量大于了发送<code>tcp</code>发送缓冲区的大小直接就返回了。</p>
<p>接下来判断重传队列和发送队列是否为空，如果为空，则<strong>标记为第一个数据包，后面申请内存的时候即使在内存压力之下也能申请成功</strong>。</p>
<p>调用<code>tcp_stream_alloc_skb</code>申请数据包，并处理内存记账，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">tcp_stream_alloc_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">gfp_t</span> gfp,</span></span><br><span class="line"><span class="params">				     <span class="type">bool</span> force_schedule)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="comment">//fclone带出来两个skb</span></span><br><span class="line">	skb = alloc_skb_fclone(MAX_TCP_HEADER, gfp);</span><br><span class="line">	<span class="keyword">if</span> (likely(skb)) &#123;</span><br><span class="line">		<span class="type">bool</span> mem_scheduled;</span><br><span class="line">		<span class="comment">//计算truesize</span></span><br><span class="line">		skb-&gt;truesize = SKB_TRUESIZE(skb_end_offset(skb));</span><br><span class="line">		<span class="keyword">if</span> (force_schedule) &#123; <span class="comment">//第一个数据包走强制调度</span></span><br><span class="line">			mem_scheduled = <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">//叫强制分配内存</span></span><br><span class="line">			sk_forced_mem_schedule(sk, skb-&gt;truesize);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//不是强制调度的情况，更新内存压力信息，并判断是否到达内存压力，返回0 表示申请失败了</span></span><br><span class="line">			mem_scheduled = sk_wmem_schedule(sk, skb-&gt;truesize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (likely(mem_scheduled)) &#123;</span><br><span class="line">			skb_reserve(skb, MAX_TCP_HEADER);<span class="comment">//这里应该直接拉到了最后面</span></span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_PARTIAL;		<span class="comment">//设置校验和</span></span><br><span class="line">			INIT_LIST_HEAD(&amp;skb-&gt;tcp_tsorted_anchor);</span><br><span class="line">			<span class="keyword">return</span> skb;</span><br><span class="line">		&#125;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sk-&gt;sk_prot-&gt;enter_memory_pressure(sk); <span class="comment">//如果skb都申请失败了，直接设置内存压力</span></span><br><span class="line">		sk_stream_moderate_sndbuf(sk); <span class="comment">//调小发送缓冲区</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_stream_alloc_skb</code>中调用<code>alloc_skb_fclone</code>申请两个<code>skb</code>结构体，为后续<code>clone</code>数据包做准备</p>
<p><strong>注意这里申请数据包的线性部分的长度为<code>MAX_TCP_HEADER</code>，也就是说对于TCP来说，数据包的负载并没有在skb的线性缓冲区部分，是后续用非线性部分管理的</strong>。  </p>
<p>如果申请成功，则进一步计算数据包的<code>true_size</code>,并使用<code>true_size</code>更新内存记账信息，例如一个数据数据包这里会调用<code>sk_forced_mem_schedule</code>强制分配内存（即使在内存压力下也能申请成功）对应具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sk_forced_mem_schedule</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> delta, amt;</span><br><span class="line">	<span class="comment">//这里应该是计算超出的字节数，如果没有超出就直接返回了</span></span><br><span class="line">	delta = size - sk-&gt;sk_forward_alloc;</span><br><span class="line">	<span class="keyword">if</span> (delta &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//计算需要几个页</span></span><br><span class="line">	amt = sk_mem_pages(delta);</span><br><span class="line">	<span class="comment">//增加预分配内存额度</span></span><br><span class="line">	sk_forward_alloc_add(sk, amt &lt;&lt; PAGE_SHIFT);</span><br><span class="line">	sk_memory_allocated_add(sk, amt); <span class="comment">//传入页数，里面会批量更新内存压力情况</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_sockets_enabled &amp;&amp; sk-&gt;sk_memcg)</span><br><span class="line">		mem_cgroup_charge_skmem(sk-&gt;sk_memcg, amt,</span><br><span class="line">					gfp_memcg_charge() | __GFP_NOFAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/20/tcp_sendmsg_locked(%E4%BA%8C)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/18/TCP%E8%BE%93%E5%87%BAtcp_sendmsg_locked%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/18/TCP%E8%BE%93%E5%87%BAtcp_sendmsg_locked%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">TCP输出 tcp_sendmsg_locked（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-18 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-18T22:00:00+08:00">2025-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-25 21:34:53" itemprop="dateModified" datetime="2025-11-25T21:34:53+08:00">2025-11-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/18/TCP%E8%BE%93%E5%87%BAtcp_sendmsg_locked%EF%BC%88%E4%B8%80%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/18/TCP%E8%BE%93%E5%87%BAtcp_sendmsg_locked%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_sendmsg_locked</code>为发送<code>tcp</code>数据包的核心函数，主要完成数据包从用户态到内核态的拷贝，根据<code>mss</code>，<code>GSO</code>等信息封装数据包，最终将数据包放入发送队列，更新内存记账等。具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_sendmsg_locked</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info</span> *<span class="title">uarg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockcm_cookie</span> <span class="title">sockc</span>;</span></span><br><span class="line">	<span class="type">int</span> flags, err, copied = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mss_now = <span class="number">0</span>, size_goal, copied_syn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> process_backlog = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> zc = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> timeo;</span><br><span class="line"></span><br><span class="line">	flags = msg-&gt;msg_flags;</span><br><span class="line">	<span class="comment">//零拷贝处理</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; MSG_ZEROCOPY) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (msg-&gt;msg_ubuf) &#123;</span><br><span class="line">			uarg = msg-&gt;msg_ubuf;</span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_SG)</span><br><span class="line">				zc = MSG_ZEROCOPY;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_ZEROCOPY)) &#123;</span><br><span class="line">			skb = tcp_write_queue_tail(sk);</span><br><span class="line">			uarg = msg_zerocopy_realloc(sk, size, skb_zcopy(skb));</span><br><span class="line">			<span class="keyword">if</span> (!uarg) &#123;</span><br><span class="line">				err = -ENOBUFS;</span><br><span class="line">				<span class="keyword">goto</span> out_err;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_SG)</span><br><span class="line">				zc = MSG_ZEROCOPY;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				uarg_to_msgzc(uarg)-&gt;zerocopy = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(msg-&gt;msg_flags &amp; MSG_SPLICE_PAGES) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_route_caps &amp; NETIF_F_SG)</span><br><span class="line">			zc = MSG_SPLICE_PAGES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//TFO相关</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; MSG_FASTOPEN ||</span><br><span class="line">		     inet_test_bit(DEFER_CONNECT, sk)) &amp;&amp;</span><br><span class="line">	    !tp-&gt;repair) &#123;</span><br><span class="line">		err = tcp_sendmsg_fastopen(sk, msg, &amp;copied_syn, size, uarg);</span><br><span class="line">		<span class="keyword">if</span> (err == -EINPROGRESS &amp;&amp; copied_syn &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置tcp发送超时时间</span></span><br><span class="line">	timeo = sock_sndtimeo(sk, flags &amp; MSG_DONTWAIT);</span><br><span class="line">	<span class="comment">//于判断当前 TCP 连接是否因为应用程序没有提供足够数据</span></span><br><span class="line">	tcp_rate_check_app_limited(sk);  <span class="comment">/* is sending application-limited? */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Wait for a connection to finish. One exception is TCP Fast Open</span></span><br><span class="line"><span class="comment">	 * (passive side) where data is allowed to be sent before a connection</span></span><br><span class="line"><span class="comment">	 * is fully established.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//TFO</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &amp;&amp;</span><br><span class="line">	    !tcp_passive_fastopen(sk)) &#123;</span><br><span class="line">		err = sk_stream_wait_connect(sk, &amp;timeo);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> do_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//热迁移场景</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_RECV_QUEUE) &#123;</span><br><span class="line">			copied = tcp_send_rcvq(sk, msg, size);</span><br><span class="line">			<span class="keyword">goto</span> out_nopush;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_NO_QUEUE)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* &#x27;common&#x27; sending to sendq */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理用户的控制信息，保存到sockc中</span></span><br><span class="line">	sockcm_init(&amp;sockc, sk);</span><br><span class="line">	<span class="keyword">if</span> (msg-&gt;msg_controllen) &#123;</span><br><span class="line">		err = sock_cmsg_send(sk, msg, &amp;sockc);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This should be in poll */</span></span><br><span class="line">	sk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ok commence sending. */</span></span><br><span class="line">	copied = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">//计算当前的mss ,这里传出的size_goal大概率是64k</span></span><br><span class="line">	mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line"></span><br><span class="line">	err = -EPIPE;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_err || (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN))</span><br><span class="line">		<span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (msg_data_left(msg)) &#123;</span><br><span class="line">		<span class="type">ssize_t</span> copy = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//队列尾部取出一个数据包</span></span><br><span class="line">		skb = tcp_write_queue_tail(sk);</span><br><span class="line">		<span class="keyword">if</span> (skb)</span><br><span class="line">			<span class="comment">//计算剩余可以拷贝的空间</span></span><br><span class="line">			copy = size_goal - skb-&gt;len;</span><br><span class="line">		<span class="comment">//没有可以copy的空间了</span></span><br><span class="line">		<span class="keyword">if</span> (copy &lt;= <span class="number">0</span> || !tcp_skb_can_collapse_to(skb)) &#123;</span><br><span class="line">			<span class="type">bool</span> first_skb;</span><br><span class="line"></span><br><span class="line">new_segment:<span class="comment">//判断是否有缓冲区，如果发送的队列比发送的缓冲区大，这里就直接goto了</span></span><br><span class="line">			<span class="keyword">if</span> (!sk_stream_memory_free(sk))</span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			<span class="comment">//连续创建了16个skb</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(process_backlog &gt;= <span class="number">16</span>)) &#123;</span><br><span class="line">				process_backlog = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (sk_flush_backlog(sk))</span><br><span class="line">					<span class="keyword">goto</span> restart;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//重传队列和发送队列是否都是空</span></span><br><span class="line">			first_skb = tcp_rtx_and_write_queues_empty(sk);</span><br><span class="line">			<span class="comment">//申请一个skb</span></span><br><span class="line">			skb = tcp_stream_alloc_skb(sk, sk-&gt;sk_allocation,</span><br><span class="line">						   first_skb);</span><br><span class="line">			<span class="keyword">if</span> (!skb) <span class="comment">//如果申请skb失败，那就等</span></span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			<span class="comment">//增加创建skb的计数</span></span><br><span class="line">			process_backlog++;</span><br><span class="line">			<span class="comment">//数据包入队列，更新内存相关统计</span></span><br><span class="line">			tcp_skb_entail(sk, skb);</span><br><span class="line">			copy = size_goal; </span><br><span class="line"></span><br><span class="line">			<span class="comment">/* All packets are restored as if they have</span></span><br><span class="line"><span class="comment">			 * already been sent. skb_mstamp_ns isn&#x27;t set to</span></span><br><span class="line"><span class="comment">			 * avoid wrong rtt estimation.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (tp-&gt;repair)</span><br><span class="line">				TCP_SKB_CB(skb)-&gt;sacked |= TCPCB_REPAIRED;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//注意这里开始是把数据包追加到skb上</span></span><br><span class="line">		<span class="comment">/* Try to append data to the end of skb. */</span></span><br><span class="line">		<span class="comment">//copy表示能容纳的最大字节数，如果大于用户数据，就拷贝用户指定的大小，否则肯定是最大大小，合理</span></span><br><span class="line">		<span class="keyword">if</span> (copy &gt; msg_data_left(msg))</span><br><span class="line">			copy = msg_data_left(msg);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (zc == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">bool</span> merge = <span class="literal">true</span>;</span><br><span class="line">			<span class="type">int</span> i = skb_shinfo(skb)-&gt;nr_frags;</span><br><span class="line">			<span class="comment">//获取一个page的缓存，这里大概率是获取当前线程的page</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span> *<span class="title">pfrag</span> =</span> sk_page_frag(sk);</span><br><span class="line">			<span class="comment">//确保上面获取的页有足够的空间，没有的话这里会申请一个page，申请失败会goto</span></span><br><span class="line">			<span class="keyword">if</span> (!sk_page_frag_refill(sk, pfrag))</span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			<span class="comment">//判断当前数据是否能追加到 skb 的最后一个 frag 上 (通常应该是可以)</span></span><br><span class="line">			<span class="keyword">if</span> (!skb_can_coalesce(skb, i, pfrag-&gt;page,</span><br><span class="line">					      pfrag-&gt;offset)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i &gt;= READ_ONCE(sysctl_max_skb_frags)) &#123; <span class="comment">//17 表示一个skb最多挂17个非线性的</span></span><br><span class="line">					tcp_mark_push(tp, skb);</span><br><span class="line">					<span class="keyword">goto</span> new_segment;</span><br><span class="line">				&#125;</span><br><span class="line">				merge = <span class="literal">false</span>;<span class="comment">//不能合并</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//计算可以copy的大小</span></span><br><span class="line">			copy = <span class="type">min_t</span>(<span class="type">int</span>, copy, pfrag-&gt;size - pfrag-&gt;offset);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tcp_downgrade_zcopy_pure(sk, skb))</span><br><span class="line">					<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">				skb_zcopy_downgrade_managed(skb);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//内存记账，这里面一个是全局的一个是sk自己的，这里可能会缩小copy</span></span><br><span class="line">			copy = tcp_wmem_schedule(sk, copy);</span><br><span class="line">			<span class="keyword">if</span> (!copy)</span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			<span class="comment">//真正的copy</span></span><br><span class="line">			err = skb_copy_to_page_nocache(sk, &amp;msg-&gt;msg_iter, skb,</span><br><span class="line">						       pfrag-&gt;page,</span><br><span class="line">						       pfrag-&gt;offset,</span><br><span class="line">						       copy);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Update the skb. */</span></span><br><span class="line">			<span class="comment">//可以合并的情况</span></span><br><span class="line">			<span class="keyword">if</span> (merge) &#123;</span><br><span class="line">				skb_frag_size_add(&amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>], copy);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//申请了新的page</span></span><br><span class="line">				skb_fill_page_desc(skb, i, pfrag-&gt;page,</span><br><span class="line">						   pfrag-&gt;offset, copy);</span><br><span class="line">				page_ref_inc(pfrag-&gt;page);<span class="comment">//增加引用计数</span></span><br><span class="line">			&#125;</span><br><span class="line">			pfrag-&gt;offset += copy;<span class="comment">//更新page的offset</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (zc == MSG_ZEROCOPY)  &#123;</span><br><span class="line">			<span class="comment">/* First append to a fragless skb builds initial</span></span><br><span class="line"><span class="comment">			 * pure zerocopy skb</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!skb-&gt;len)</span><br><span class="line">				skb_shinfo(skb)-&gt;flags |= SKBFL_PURE_ZEROCOPY;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!skb_zcopy_pure(skb)) &#123;</span><br><span class="line">				copy = tcp_wmem_schedule(sk, copy);</span><br><span class="line">				<span class="keyword">if</span> (!copy)</span><br><span class="line">					<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			err = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);</span><br><span class="line">			<span class="keyword">if</span> (err == -EMSGSIZE || err == -EEXIST) &#123;</span><br><span class="line">				tcp_mark_push(tp, skb);</span><br><span class="line">				<span class="keyword">goto</span> new_segment;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> do_error;</span><br><span class="line">			copy = err;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (zc == MSG_SPLICE_PAGES) &#123;</span><br><span class="line">			<span class="comment">/* Splice in data if we can; copy if we can&#x27;t. */</span></span><br><span class="line">			<span class="keyword">if</span> (tcp_downgrade_zcopy_pure(sk, skb))</span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line">			copy = tcp_wmem_schedule(sk, copy);</span><br><span class="line">			<span class="keyword">if</span> (!copy)</span><br><span class="line">				<span class="keyword">goto</span> wait_for_space;</span><br><span class="line"></span><br><span class="line">			err = skb_splice_from_iter(skb, &amp;msg-&gt;msg_iter, copy,</span><br><span class="line">						   sk-&gt;sk_allocation);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (err == -EMSGSIZE) &#123;</span><br><span class="line">					tcp_mark_push(tp, skb);</span><br><span class="line">					<span class="keyword">goto</span> new_segment;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> do_error;</span><br><span class="line">			&#125;</span><br><span class="line">			copy = err;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(flags &amp; MSG_NO_SHARED_FRAGS))</span><br><span class="line">				skb_shinfo(skb)-&gt;flags |= SKBFL_SHARED_FRAG;</span><br><span class="line"></span><br><span class="line">			sk_wmem_queued_add(sk, copy);</span><br><span class="line">			sk_mem_charge(sk, copy);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若当前这个 skb 之前没 copy（即刚创建或第一次写）则清除 PSH 标志位</span></span><br><span class="line">		<span class="keyword">if</span> (!copied)</span><br><span class="line">			TCP_SKB_CB(skb)-&gt;tcp_flags &amp;= ~TCPHDR_PSH;</span><br><span class="line">		<span class="comment">//发送缓冲区中最后一个字节的下一个序列号</span></span><br><span class="line">		WRITE_ONCE(tp-&gt;write_seq, tp-&gt;write_seq + copy);</span><br><span class="line">		<span class="comment">//该 skb 已覆盖的 TCP 数据范围</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;end_seq += copy;</span><br><span class="line">		tcp_skb_pcount_set(skb, <span class="number">0</span>); <span class="comment">//初始认为这是 non-GSO skb</span></span><br><span class="line">		<span class="comment">//这个值最终作为 send() 的返回值</span></span><br><span class="line">		copied += copy;</span><br><span class="line">		<span class="comment">//判断是否已经拷贝完用户数据</span></span><br><span class="line">		<span class="keyword">if</span> (!msg_data_left(msg)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(flags &amp; MSG_EOR))</span><br><span class="line">				TCP_SKB_CB(skb)-&gt;eor = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> out;<span class="comment">//跳出主循环 out</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//决定是否继续累积写，还是 push（发送)</span></span><br><span class="line">		<span class="comment">//skb还没写够期望大小 </span></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len &lt; size_goal || (flags &amp; MSG_OOB) || unlikely(tp-&gt;repair))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断现在是否应该把数据push 给 TCP 输出层</span></span><br><span class="line">		<span class="keyword">if</span> (forced_push(tp)) &#123; <span class="comment">//如果当前写入的数据量已经超过发送窗口的一半，那就必须强制 push</span></span><br><span class="line">			tcp_mark_push(tp, skb); <span class="comment">//设置push标志位</span></span><br><span class="line">			__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == tcp_send_head(sk)) <span class="comment">//当前 skb 恰好是发送队列的头部</span></span><br><span class="line">			tcp_push_one(sk, mss_now); <span class="comment">//，只发送一个</span></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">wait_for_space: <span class="comment">//skb 或者page申请失败都会走这里</span></span><br><span class="line">		set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">		tcp_remove_empty_skb(sk);<span class="comment">//如果队列尾部那个skb是空的就把它删掉</span></span><br><span class="line">		<span class="keyword">if</span> (copied) <span class="comment">//copy 了一部分数据到某个skb ，，先把这部分内容 push 出去。</span></span><br><span class="line">			tcp_push(sk, flags &amp; ~MSG_MORE, mss_now, <span class="comment">//不再等待更多数据</span></span><br><span class="line">				 TCP_NAGLE_PUSH, size_goal); <span class="comment">//忽略 Nagle 延迟策略，立即发送</span></span><br><span class="line">		<span class="comment">//等待</span></span><br><span class="line">		err = sk_stream_wait_memory(sk, &amp;timeo);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> do_error;</span><br><span class="line">		<span class="comment">//重新计算mss</span></span><br><span class="line">		mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (copied) &#123;</span><br><span class="line">		tcp_tx_timestamp(sk, sockc.tsflags);</span><br><span class="line">		<span class="comment">//write_queue 中积累的skb按条件发送到ip层可能立即发 也可能等Nagle/pacing。</span></span><br><span class="line">		tcp_push(sk, flags, mss_now, tp-&gt;nonagle, size_goal);</span><br><span class="line">	&#125;</span><br><span class="line">out_nopush:</span><br><span class="line">	<span class="comment">/* msg-&gt;msg_ubuf is pinned by the caller so we don&#x27;t take extra refs */</span></span><br><span class="line">	<span class="keyword">if</span> (uarg &amp;&amp; !msg-&gt;msg_ubuf)</span><br><span class="line">		net_zcopy_put(uarg);</span><br><span class="line">	<span class="keyword">return</span> copied + copied_syn;</span><br><span class="line"></span><br><span class="line">do_error:</span><br><span class="line">	tcp_remove_empty_skb(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copied + copied_syn)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">out_err:</span><br><span class="line">	<span class="comment">/* msg-&gt;msg_ubuf is pinned by the caller so we don&#x27;t take extra refs */</span></span><br><span class="line">	<span class="keyword">if</span> (uarg &amp;&amp; !msg-&gt;msg_ubuf)</span><br><span class="line">		net_zcopy_put_abort(uarg, <span class="literal">true</span>);</span><br><span class="line">	err = sk_stream_error(sk, flags, err);</span><br><span class="line">	<span class="comment">/* make sure we wake any epoll edge trigger waiter */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_rtx_and_write_queues_empty(sk) &amp;&amp; err == -EAGAIN)) &#123;</span><br><span class="line">		sk-&gt;sk_write_space(sk);</span><br><span class="line">		tcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_sendmsg_locked</code>中首先判断是否为零拷贝或者<code>TFO</code>模式，之后获取超时时间，并调用<code>tcp_rate_check_app_limited</code>判断是否处于应用层发送速率过慢状态(<strong>会影响<code>bbr</code>等拥塞算法的处理</strong>)，具体代码如下所：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_rate_check_app_limited</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="comment">/* We have less than one packet to send. */</span></span><br><span class="line">		<span class="comment">//待发送的数据不足一个mss &amp;&amp; 缓冲区没有数据 &amp;&amp; 在途数据包小于拥塞窗口</span></span><br><span class="line">	    tp-&gt;write_seq - tp-&gt;snd_nxt &lt; tp-&gt;mss_cache &amp;&amp;</span><br><span class="line">	    <span class="comment">/* Nothing in sending host&#x27;s qdisc queues or NIC tx queue. */</span></span><br><span class="line">	    sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>) &amp;&amp;</span><br><span class="line">	    <span class="comment">/* We are not limited by CWND. */</span></span><br><span class="line">	    tcp_packets_in_flight(tp) &lt; tcp_snd_cwnd(tp) &amp;&amp;</span><br><span class="line">	    <span class="comment">/* All lost packets have been retransmitted. */</span></span><br><span class="line">		<span class="comment">//数据包都已经重传</span></span><br><span class="line">	    tp-&gt;lost_out &lt;= tp-&gt;retrans_out)</span><br><span class="line">		<span class="comment">//存在已经交付的数据包，则设置为应用受限制</span></span><br><span class="line">		tp-&gt;app_limited =</span><br><span class="line">			(tp-&gt;delivered + tcp_packets_in_flight(tp)) ? : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当同时满足以下所有条件时，连接会被标记为应用受限：</p>
<ol>
<li>待发送数据不足一个MSS</li>
<li>发送缓冲区中没有排队数据</li>
<li>在途数据量小于拥塞窗口</li>
<li>所有丢失的数据包都已重传</li>
</ol>
<p>总的来说，<strong>当TCP有能力发送更多数据但应用程序没有及时提供时，就标记为应用受限状态</strong></p>
<p>之后调用<code>tcp_send_mss</code>计算当前的<code>mss</code>和<code>size_goal</code>这里的<code>size_goal</code>可以理解为一个<code>skb</code>最多可以承载多少数据，理想情况下这里是<code>64k</code>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_send_mss</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> *size_goal, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mss_now;</span><br><span class="line">	<span class="comment">//大概率返回1460，受mtu，双方协商，pmtu等影响可能不是这个值</span></span><br><span class="line">	mss_now = tcp_current_mss(sk);</span><br><span class="line">	<span class="comment">//这里如果支持GSO或TSO 这里应该就是64k</span></span><br><span class="line">	*size_goal = tcp_xmit_size_goal(sk, mss_now, !(flags &amp; MSG_OOB));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mss_now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_send_mss</code>中首先获取当前的<code>mss</code>，之后调用<code>tcp_xmit_size_goal</code>进一步计算<code>size_goal</code>具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/18/TCP%E8%BE%93%E5%87%BAtcp_sendmsg_locked%EF%BC%88%E4%B8%80%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangm</p>
  <div class="site-description" itemprop="description">协议栈源码学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '1c6PW2umhmoCGypfQhPNnfLk-gzGzoHsz',
      appKey     : 'nbVvMAfQXEdOeKD1tmvI3qrQ',
      placeholder: "畅所欲言!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://1c6pw2um.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
