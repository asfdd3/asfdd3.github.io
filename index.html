<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="协议栈源码学习">
<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="协议栈源码学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhangm">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日拱一卒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/03/01/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/03/01/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">IP报文的转发与输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-03-01 22:00:00 / 修改时间：23:31:14" itemprop="dateCreated datePublished" datetime="2026-03-01T22:00:00+08:00">2026-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/03/01/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/03/01/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IP数据包的转发"><a href="#IP数据包的转发" class="headerlink" title="IP数据包的转发"></a><code>IP</code>数据包的转发</h2><p><code>IP</code>数据包的转发由<code>ip_forward</code>完成，该函数是在<code>ip_rcv_finish</code>查找路由后确定的，是<strong>当报文不是本机而是需要转发时</strong> 的核心函数，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_forward</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 mtu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span>	<span class="comment">/* Our header */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span>	<span class="comment">/* Route we use */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span> *<span class="title">opt</span>	=</span> &amp;(IPCB(skb)-&gt;opt);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	SKB_DR(reason);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* that should never happen */</span></span><br><span class="line">	<span class="comment">//只处理是发给本机的帧</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//不应该找到本机的sk</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;sk))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//不应该有lro</span></span><br><span class="line">	<span class="keyword">if</span> (skb_warn_if_lro(skb))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//ipsec</span></span><br><span class="line">	<span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_FWD, skb)) &#123;</span><br><span class="line">		SKB_DR_SET(reason, XFRM_POLICY);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Router Alert 选项 用户可以通过setsockopt设置</span></span><br><span class="line">	<span class="keyword">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))</span><br><span class="line">		<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">	<span class="comment">//准备修改ttl，设置校验和为未计算</span></span><br><span class="line">	skb_forward_csum(skb);</span><br><span class="line">	net = dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	According to the RFC, we must first decrease the TTL field. If</span></span><br><span class="line"><span class="comment">	 *	that reaches zero, we must reply an ICMP control message telling</span></span><br><span class="line"><span class="comment">	 *	that the packet&#x27;s lifetime expired.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip_hdr(skb)-&gt;ttl &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">goto</span> too_many_hops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!xfrm4_route_forward(skb)) &#123;</span><br><span class="line">		SKB_DR_SET(reason, XFRM_POLICY);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rt = skb_rtable(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">		<span class="keyword">goto</span> sr_failed;</span><br><span class="line">	<span class="comment">//标记转发</span></span><br><span class="line">	IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;</span><br><span class="line">	<span class="comment">//获取mtu，注意这里获取了mtu</span></span><br><span class="line">	mtu = ip_dst_mtu_maybe_forward(&amp;rt-&gt;dst, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//超过了mtu，还不让分片</span></span><br><span class="line">	<span class="keyword">if</span> (ip_exceeds_mtu(skb, mtu)) &#123;</span><br><span class="line">		IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);</span><br><span class="line">		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,</span><br><span class="line">			  htonl(mtu));</span><br><span class="line">		SKB_DR_SET(reason, PKT_TOO_BIG);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We are about to mangle packet. Copy it! */</span></span><br><span class="line">	<span class="comment">//可以修改数据包的接口</span></span><br><span class="line">	<span class="keyword">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;dst.dev)+rt-&gt;dst.header_len))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Decrease ttl after skb cow done */</span></span><br><span class="line">	<span class="comment">//减去ttl</span></span><br><span class="line">	ip_decrease_ttl(iph);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	We now generate an ICMP HOST REDIRECT giving the route</span></span><br><span class="line"><span class="comment">	 *	we calculated.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//如果没有源路由选项也不是ipsec相关，就回一个icmp重定向</span></span><br><span class="line">	<span class="keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_DOREDIRECT &amp;&amp; !opt-&gt;srr &amp;&amp;</span><br><span class="line">	    !skb_sec_path(skb))</span><br><span class="line">		ip_rt_send_redirect(skb);</span><br><span class="line">	<span class="comment">//根据tos映射skb 的优先级</span></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(net-&gt;ipv4.sysctl_ip_fwd_update_priority))</span><br><span class="line">		skb-&gt;priority = rt_tos2priority(iph-&gt;tos);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,</span><br><span class="line">		       net, <span class="literal">NULL</span>, skb, skb-&gt;dev, rt-&gt;dst.dev,</span><br><span class="line">		       ip_forward_finish);</span><br><span class="line"></span><br><span class="line">sr_failed:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Strict routing permits no gatewaying</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, <span class="number">0</span>);</span><br><span class="line">	 <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">too_many_hops:</span><br><span class="line">	<span class="comment">/* Tell the sender its packet died... */</span></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">	icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, <span class="number">0</span>);</span><br><span class="line">	SKB_DR_SET(reason, IP_INHDR);</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb_reason(skb, reason);</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_forward</code>首先判断数据包是否需要由本机转发，之后判断<code>TTL</code>是否合法，不合法会回复 ICMP 报文。如果超过路径的 MTU 且不能分片，则也会回复ICMP报文。如果没有源路由选项则还可能回 ICMP 重定向，或者根据 TOS 设置包的优先级（<code>tc</code>会用到），接着交给 <code>netfilter</code> 的 FORWARD 挂载点。如果没有被丢弃，则会继续向下调用<code>ip_forward_finish</code>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_forward_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span> *<span class="title">opt</span>	=</span> &amp;(IPCB(skb)-&gt;opt);</span><br><span class="line">	<span class="comment">//统计转发的包数</span></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_OUTFORWDATAGRAMS);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SWITCHDEV</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;offload_l3_fwd_mark) &#123;</span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//处理ip选项</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(opt-&gt;optlen))</span><br><span class="line">		ip_forward_options(skb);</span><br><span class="line"></span><br><span class="line">	skb_clear_tstamp(skb);</span><br><span class="line">	<span class="comment">//调用路由dst的output，把包发出去</span></span><br><span class="line">	<span class="keyword">return</span> dst_output(net, sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IP数据包的输出"><a href="#IP数据包的输出" class="headerlink" title="IP数据包的输出"></a><code>IP</code>数据包的输出</h2><p>无论是转发的数据包还是从本地输出的数据包，经过路由之后都要进一步输出，而输出的接口就是<code>ip_output</code>，该函数和上述转发类似，也是通过路由查找的结果关联的。<code>ip_output</code>具体实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_output</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb_dst(skb)-&gt;dev, *indev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,</span><br><span class="line">			    net, sk, skb, indev, dev,</span><br><span class="line">			    ip_finish_output,</span><br><span class="line">			    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ip_output</code>主要工作就是设置<code>skb</code>的<code>netdev</code>和对应的<code>protocol</code>，为后续链路层发送数据包做准备，之后调用<code>netfilter</code>的<code>POST_ROUTING</code>钩子点，如果正常放行数据包则会进一步调用<code>ip_finish_output</code>。</p>
<p><code>ip_finish_output</code>具体代码如下所示:</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/03/01/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/27/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/27/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">IP报文的输入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-02-27 22:00:00" itemprop="dateCreated datePublished" datetime="2026-02-27T22:00:00+08:00">2026-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-03-01 20:51:25" itemprop="dateModified" datetime="2026-03-01T20:51:25+08:00">2026-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/02/27/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/02/27/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当以太网帧头的<code>ethertype</code>为<code>0X0800</code>时，标识数据包下一步交由<code>IPv4</code>处理，对内核网络协议栈而言，当数据包推送协议栈时，会根据<code>ptype_base</code>链表中找到对应处理函数，对于<code>IPv4</code>类型的数据包就是<code>ip_rcv</code>。</p>
<p><strong>协议栈初始化时，会调用<code>dev_add_pack</code>注册<code>ip_rcv</code>函数到<code>ptype_base</code>中</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">	.type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">	.func = ip_rcv,</span><br><span class="line">	.list_func = ip_list_rcv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此后续协议栈收到<code>ipv4</code>报文后会调用<code>ip_rcv</code>进行处理，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line">	<span class="comment">//合法性检查等工作</span></span><br><span class="line">	skb = ip_rcv_core(skb, net);</span><br><span class="line">	<span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	<span class="comment">//pre routing钩子，之后调用ip_rcv_finish</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">		       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">		       ip_rcv_finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_rcv</code>首先调用<code>ip_rcv_core()</code> 做基本合法性校验（如头部长度、校验和、分片等），若失败直接丢包，若通过则继续走 <code>PREROUTING</code> 钩子，若未被丢弃，则进一步回调 <code>ip_rcv_finish()</code>，上述<code>ip_rcv_core</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sk_buff *<span class="title function_">ip_rcv_core</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="type">int</span> drop_reason;</span><br><span class="line">	u32 len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When the interface is in promisc. mode, drop all the crap</span></span><br><span class="line"><span class="comment">	 * that it receives, do not try to analyse it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//驱动置位，丢弃mac地址不是本地的数据包，混杂模式就在这里丢弃吧！</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST) &#123;</span><br><span class="line">		dev_core_stats_rx_otherhost_dropped_inc(skb-&gt;dev);</span><br><span class="line">		drop_reason = SKB_DROP_REASON_OTHERHOST;</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb-&gt;len);</span><br><span class="line">	<span class="comment">//有些协议会加user的计数</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;</span><br><span class="line">	<span class="comment">//拉去数据包头到线性部分，如果可能</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr)))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line">	<span class="comment">//获取ip头</span></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	Is the datagram acceptable?</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	1.	Length at least the size of an ip header</span></span><br><span class="line"><span class="comment">	 *	2.	Version of 4</span></span><br><span class="line"><span class="comment">	 *	3.	Checksums correctly. [Speed optimisation for later, skip loopback checksums]</span></span><br><span class="line"><span class="comment">	 *	4.	Doesn&#x27;t have a bogus length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1);</span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0);</span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE);</span><br><span class="line">	__IP_ADD_STATS(net,</span><br><span class="line">		       IPSTATS_MIB_NOECTPKTS + (iph-&gt;tos &amp; INET_ECN_MASK),</span><br><span class="line">		       <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">short</span>, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs));</span><br><span class="line">	<span class="comment">//拉取头部到线性部分</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	<span class="comment">//汇编计算ip校验和</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line">	<span class="comment">//长度检查</span></span><br><span class="line">	len = iph_totlen(skb, iph);</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt; len) &#123;</span><br><span class="line">		drop_reason = SKB_DROP_REASON_PKT_TOO_SMALL;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Our transport medium may have padded the buffer out. Now we know it</span></span><br><span class="line"><span class="comment">	 * is IP we can trim to the true length of the frame.</span></span><br><span class="line"><span class="comment">	 * Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//去掉padding部分</span></span><br><span class="line">	<span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	<span class="comment">//这里设置了传输层指针的偏移</span></span><br><span class="line">	skb-&gt;transport_header = skb-&gt;network_header + iph-&gt;ihl*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remove any debris in the socket control block */</span></span><br><span class="line">	<span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line">	IPCB(skb)-&gt;iif = skb-&gt;skb_iif;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Must drop socket now because of tproxy. */</span></span><br><span class="line">	<span class="comment">//这个几乎不会进入吧</span></span><br><span class="line">	<span class="keyword">if</span> (!skb_sk_is_prefetched(skb))</span><br><span class="line">		skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">csum_error:</span><br><span class="line">	drop_reason = SKB_DROP_REASON_IP_CSUM;</span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);</span><br><span class="line">inhdr_error:</span><br><span class="line">	<span class="keyword">if</span> (drop_reason == SKB_DROP_REASON_NOT_SPECIFIED)</span><br><span class="line">		drop_reason = SKB_DROP_REASON_IP_INHDR;</span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb_reason(skb, drop_reason);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述<code>ip_rcv_core()</code> <strong>核心思想就是针对接收的ipv4报文进行一系列的合法性检查</strong>，先丢弃混杂模式下收到的非本机目标帧。随后把 IP 头拉到线性区，检查版本，IP 头校验以及总长度合法性；若报文被链路层 padding，则会裁剪报文，并设置 <code>transport_header</code>  让上层能直接定位传输层头。</p>
<p><strong>若通过<code>ip_rcv_core</code>和<code>PRE_ROUTING</code>的检查则会一步调用<code>ip_rcv_finish</code>查找路由决定是转发还是上送本机</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if ingress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment">	 * skb to its handler for processing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = l3mdev_ip_rcv(skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line">	<span class="comment">//查路由决定是上送还是转发</span></span><br><span class="line">	ret = ip_rcv_finish_core(net, sk, skb, dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != NET_RX_DROP)</span><br><span class="line">		ret = dst_input(skb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/02/27/IP%E5%B1%82%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/25/%E5%AF%B9%E7%AB%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84inet_peer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/25/%E5%AF%B9%E7%AB%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84inet_peer/" class="post-title-link" itemprop="url">对端信息管理结构-inet_peer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-02-25 22:00:00 / 修改时间：21:16:07" itemprop="dateCreated datePublished" datetime="2026-02-25T22:00:00+08:00">2026-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/02/25/%E5%AF%B9%E7%AB%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84inet_peer/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/02/25/%E5%AF%B9%E7%AB%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84inet_peer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>协议栈会创建<code>inet_peer</code>结构来保存通信对端的一些信息，<strong>例如对端的地址，主要用于重组IP时判断是否为来自同一源IP的分片攻击。</strong><code>inet_peer</code>结构具体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_peer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>		<span class="title">rb_node</span>;</span>    <span class="comment">//红黑树管理用到</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inetpeer_addr</span>	<span class="title">daddr</span>;</span>  <span class="comment">//inet_peer</span></span><br><span class="line"></span><br><span class="line">	u32			metrics[RTAX_MAX];</span><br><span class="line">	u32			rate_tokens;	<span class="comment">/* rate limiting for ICMP */</span><span class="comment">//icmp令牌限速</span></span><br><span class="line">	u32			n_redirects;	<span class="comment">//防止redirect攻击</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		rate_last; <span class="comment">//icpmi</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Once inet_peer is queued for deletion (refcnt == 0), following field</span></span><br><span class="line"><span class="comment">	 * is not available: rid</span></span><br><span class="line"><span class="comment">	 * We can share memory with rcu_head to help keep inet_peer small.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">atomic_t</span>			rid;		<span class="comment">/* Frag reception counter */</span><span class="comment">//ip分片计数！</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>         <span class="title">rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* following fields might be frequently dirtied */</span></span><br><span class="line">	__u32			dtime;	<span class="comment">/* the time of last use of not referenced entries */</span> <span class="comment">//老化时间</span></span><br><span class="line">	<span class="type">refcount_t</span>		refcnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化路由模块的最后会为每个网络命令空间创建一个管理<code>inet_peer</code>的结构，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __net_init <span class="title function_">ipv4_inetpeer_init</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_peer_base</span> *<span class="title">bp</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*bp), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bp)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	inet_peer_base_init(bp);</span><br><span class="line">	net-&gt;ipv4.peers = bp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inet_peer_base_init</span><span class="params">(<span class="keyword">struct</span> inet_peer_base *bp)</span></span><br><span class="line">&#123;</span><br><span class="line">	bp-&gt;rb_root = RB_ROOT;</span><br><span class="line">	seqlock_init(&amp;bp-&gt;lock);</span><br><span class="line">	bp-&gt;total = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipv4_inetpeer_init()</code> 负责分配一块 <code>inet_peer_base</code> 内存并挂到 <code>net-&gt;ipv4.peers</code> 上， <code>inet_peer_base_init()</code> 把这块内存初始化好，建一棵空的红黑树、初始化锁、把计数清零。</p>
<p>在初始化路由模块完成后会调用<code>inet_initpeers</code>计算本机可以创建的最多<code>peer</code>数量和相对应的<code>slab</code>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">inet_initpeers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 nr_entries;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* 1% of physical memory */</span></span><br><span class="line">	<span class="comment">//计算物理内存的百分之1是多少</span></span><br><span class="line">	nr_entries = div64_ul((u64)totalram_pages() &lt;&lt; PAGE_SHIFT,</span><br><span class="line">			      <span class="number">100</span> * L1_CACHE_ALIGN(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_peer)));</span><br><span class="line">	<span class="comment">//钳制一下</span></span><br><span class="line">	inet_peer_threshold = clamp_val(nr_entries, <span class="number">4096</span>, <span class="number">65536</span> + <span class="number">128</span>);</span><br><span class="line">	<span class="comment">//创建对应的slab</span></span><br><span class="line">	peer_cachep = kmem_cache_create(<span class="string">&quot;inet_peer_cache&quot;</span>,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_peer),</span><br><span class="line">			<span class="number">0</span>, SLAB_HWCACHE_ALIGN | SLAB_PANIC,</span><br><span class="line">			<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对端信息块的创建和查找"><a href="#对端信息块的创建和查找" class="headerlink" title="对端信息块的创建和查找"></a>对端信息块的创建和查找</h3><p>对端信息结构的查找和创建都是<code>inet_getpeer</code>来实现的，由参数<code>create</code>确定是否需要创建，首先根据指定ip地址从红黑树中查找对应的结构，如果没有找到则会尝试创建对端信息块，同时还可能会由同步清理的操作，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/02/25/%E5%AF%B9%E7%AB%AF%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84inet_peer/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/08/IPv4%20%E7%9A%84%E6%8E%A7%E5%88%B6%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/08/IPv4%20%E7%9A%84%E6%8E%A7%E5%88%B6%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">IPv4 的控制与错误上报机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-02-08 22:00:00 / 修改时间：20:18:21" itemprop="dateCreated datePublished" datetime="2026-02-08T22:00:00+08:00">2026-02-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/02/08/IPv4%20%E7%9A%84%E6%8E%A7%E5%88%B6%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/02/08/IPv4%20%E7%9A%84%E6%8E%A7%E5%88%B6%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="IP私有信息控制块"><a href="#IP私有信息控制块" class="headerlink" title="IP私有信息控制块"></a>IP私有信息控制块</h3><p>协议栈的IP层处理中会依靠<code>skb</code>的控制字段（<code>cb</code>总计48个字节）来存储IP层用到的控制信息，这个控制块主要存储IP选项，分片路由等信息，具体结构如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_skb_parm</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>			iif;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_options</span>	<span class="title">opt</span>;</span>		<span class="comment">/* Compiled IP options		*/</span></span><br><span class="line">	u16			flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_FORWARDED		BIT(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_XFRM_TUNNEL_SIZE	BIT(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_XFRM_TRANSFORMED	BIT(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_FRAG_COMPLETE	BIT(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_REROUTED		BIT(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_DOREDIRECT	BIT(5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_FRAG_PMTU		BIT(6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_L3SLAVE		BIT(7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_NOPOLICY		BIT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPSKB_MULTIPATH		BIT(9)</span></span><br><span class="line"></span><br><span class="line">	u16			frag_max_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如在接收数据包时，<code>ip_rcv_options</code>会解析数据包首部的IP选项保存到控制块中，在发送数据包时<code>ip_options_build</code>会将根据控制信息生成一个选项。上述<code>flags</code>用于标记是否被重组，是否需要被<code>ipsec</code>处理，是否需要重定向等信息。</p>
<h3 id="ipv4-devconf-结构"><a href="#ipv4-devconf-结构" class="headerlink" title="ipv4_devconf 结构"></a><code>ipv4_devconf</code> 结构</h3><p> <code>ipv4_devconf</code> 是网口的IPv4系统配置，用于控制这个网口在IPv4协议栈里的所有策略行为，注意这个结构被之前介绍的in_device结构管理，每个网口都有自己的一份<code>ipv4_devconf</code> 具体结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipv4_devconf</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>	*sysctl;</span><br><span class="line">	<span class="type">int</span>	data[IPV4_DEVCONF_MAX];</span><br><span class="line">	DECLARE_BITMAP(state, IPV4_DEVCONF_MAX);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ipv4_devconf</code>结构中有一个<code>bitmap</code>和一个数组，<code>bitmap</code>用于标识当前设备是否显示修改过配置（正常应该是全局结构继承过来的），上述data数组中存的就是每个配置项的具体开关，标识是否开启，具体有如下配置项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IPV4_DEVCONF_FORWARDING = <span class="number">1</span>,   <span class="comment">// forwarding：是否允许该接口进行三层转发（路由器开关）</span></span><br><span class="line">    IPV4_DEVCONF_MC_FORWARDING,    <span class="comment">// mc_forwarding：是否转发组播报文</span></span><br><span class="line">    IPV4_DEVCONF_PROXY_ARP,        <span class="comment">// proxy_arp：是否开启 ARP 代答（替别的主机回应 ARP）</span></span><br><span class="line">    IPV4_DEVCONF_ACCEPT_REDIRECTS, <span class="comment">// accept_redirects：是否接受 ICMP Redirect 重定向</span></span><br><span class="line">    IPV4_DEVCONF_SECURE_REDIRECTS, <span class="comment">// secure_redirects：只接受“可信网关”发来的 Redirect</span></span><br><span class="line">    IPV4_DEVCONF_SEND_REDIRECTS,   <span class="comment">// send_redirects：是否向对端发送 ICMP Redirect</span></span><br><span class="line">    IPV4_DEVCONF_SHARED_MEDIA,     <span class="comment">// shared_media：多接口共享链路场景，影响地址选择与 ARP 行为</span></span><br><span class="line">    IPV4_DEVCONF_RP_FILTER,        <span class="comment">// rp_filter：反向路径过滤，防止 IP 欺骗</span></span><br><span class="line">    IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE, <span class="comment">// accept_source_route：是否允许源路由（极不安全）</span></span><br><span class="line">    IPV4_DEVCONF_BOOTP_RELAY,      <span class="comment">// bootp_relay：是否作为 BOOTP relay（遗留功能）</span></span><br><span class="line">    IPV4_DEVCONF_LOG_MARTIANS,     <span class="comment">// log_martians：记录异常/伪造源地址的报文</span></span><br><span class="line">    IPV4_DEVCONF_TAG,              <span class="comment">// tag：给地址/接口打标签，供策略路由等使用</span></span><br><span class="line">    IPV4_DEVCONF_ARPFILTER,        <span class="comment">// arp_filter：是否严格根据路由选择接口回应 ARP</span></span><br><span class="line">    IPV4_DEVCONF_MEDIUM_ID,        <span class="comment">// medium_id：介质标识，用于 shared_media 判断</span></span><br><span class="line">    IPV4_DEVCONF_NOXFRM,           <span class="comment">// disable_xfrm：禁止该接口进行 IPsec/xfrm 处理</span></span><br><span class="line">    IPV4_DEVCONF_NOPOLICY,         <span class="comment">// disable_policy：禁止该接口进行策略匹配（xfrm policy）</span></span><br><span class="line">    IPV4_DEVCONF_FORCE_IGMP_VERSION, <span class="comment">// force_igmp_version：强制 IGMP 版本（v2/v3）</span></span><br><span class="line">    IPV4_DEVCONF_ARP_ANNOUNCE,     <span class="comment">// arp_announce：ARP 宣告时使用哪个源 IP（防 ARP flux）</span></span><br><span class="line">    IPV4_DEVCONF_ARP_IGNORE,       <span class="comment">// arp_ignore：收到 ARP 请求时的忽略级别</span></span><br><span class="line">    IPV4_DEVCONF_PROMOTE_SECONDARIES, <span class="comment">// promote_secondaries：删除主地址时是否提升从地址为主地址</span></span><br><span class="line">    IPV4_DEVCONF_ARP_ACCEPT,       <span class="comment">// arp_accept：是否接受 Gratuitous ARP 更新邻居表</span></span><br><span class="line">    IPV4_DEVCONF_ARP_NOTIFY,       <span class="comment">// arp_notify：本接口 IP 变化时是否发送 Gratuitous ARP</span></span><br><span class="line">    IPV4_DEVCONF_ACCEPT_LOCAL,     <span class="comment">// accept_local：是否接受源地址是本机地址的报文</span></span><br><span class="line">    IPV4_DEVCONF_SRC_VMARK,        <span class="comment">// src_valid_mark：fwmark 参与源地址选择</span></span><br><span class="line">    IPV4_DEVCONF_PROXY_ARP_PVLAN,  <span class="comment">// proxy_arp_pvlan：PVLAN 场景下的 proxy ARP</span></span><br><span class="line">    IPV4_DEVCONF_ROUTE_LOCALNET,   <span class="comment">// route_localnet：是否允许路由 127.0.0.0/8 的流量</span></span><br><span class="line">    IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL, <span class="comment">// igmpv2 上报间隔</span></span><br><span class="line">    IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL, <span class="comment">// igmpv3 上报间隔</span></span><br><span class="line">    IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN, <span class="comment">// 接口 down 时忽略其相关路由</span></span><br><span class="line">    IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST, <span class="comment">// 丢弃 L2 多播帧中承载的单播 IP 包（防欺骗）</span></span><br><span class="line">    IPV4_DEVCONF_DROP_GRATUITOUS_ARP, <span class="comment">// 丢弃 Gratuitous ARP</span></span><br><span class="line">    IPV4_DEVCONF_BC_FORWARDING,    <span class="comment">// 是否允许转发广播报文</span></span><br><span class="line">    IPV4_DEVCONF_ARP_EVICT_NOCARRIER, <span class="comment">// 接口无 carrier 时清空 ARP 邻居表</span></span><br><span class="line">    __IPV4_DEVCONF_MAX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="套接字的错误队列"><a href="#套接字的错误队列" class="headerlink" title="套接字的错误队列"></a>套接字的错误队列</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/02/08/IPv4%20%E7%9A%84%E6%8E%A7%E5%88%B6%E9%9D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E6%9C%BA%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/02/03/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/02/03/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">netlink配置IPv4地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-02-03 22:00:00" itemprop="dateCreated datePublished" datetime="2026-02-03T22:00:00+08:00">2026-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-08 20:18:09" itemprop="dateModified" datetime="2026-02-08T20:18:09+08:00">2026-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/02/03/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/02/03/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用户态<code>iproute2</code>工具包提供了使用<code>netlink</code>对IP地址进行操作，例如用户通过以下命令给网口配置一个IP地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr add 192.168.1.10/24 dev eth0</span><br></pre></td></tr></table></figure>

<p><strong>其实本质上是构造了一个类型为<code>RTM_NEWADDR</code>的<code>netlink</code>消息，请求内核去完成这次地址的配置，并通过通知链机制通告给内核中其他子系统。本文侧重梳理IP地址配置和删除的整个流程，先从注册<code>netlink</code>消息开始说起：</strong></p>
<p>内核<code>inet_init</code>中最终会调用<code>rtnl_register</code>注册<code>RTM_NEWADDR /RTM_DELADDR</code>的规则，之后当<strong>用户执行 <code>ip addr add /del</code> 命令</strong>时，只要是 IPv4，都会被派发到注册的这个函数中，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//删除IP地址的命令</span></span><br><span class="line">rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>inet_rtm_newaddr</code>为实际配置IP地址时的回调函数，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inet_rtm_newaddr</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nlmsghdr *nlh,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(skb-&gt;sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> *<span class="title">ifa</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> *<span class="title">ifa_existing</span>;</span></span><br><span class="line">	__u32 valid_lft = INFINITY_LIFE_TIME;</span><br><span class="line">	__u32 prefered_lft = INFINITY_LIFE_TIME;</span><br><span class="line"></span><br><span class="line">	ASSERT_RTNL();</span><br><span class="line">	<span class="comment">//把 netlink 消息解析成 in_ifaddr</span></span><br><span class="line">	ifa = rtm_to_ifaddr(net, nlh, &amp;valid_lft, &amp;prefered_lft, extack);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ifa))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ifa);</span><br><span class="line">	<span class="comment">//这个地址是否已经在该设备上存在</span></span><br><span class="line">	ifa_existing = find_matching_ifa(ifa);</span><br><span class="line">	<span class="comment">//地址不存在，插入新地址</span></span><br><span class="line">	<span class="keyword">if</span> (!ifa_existing) &#123;</span><br><span class="line">		<span class="comment">/* It would be best to check for !NLM_F_CREATE here but</span></span><br><span class="line"><span class="comment">		 * userspace already relies on not having to provide this.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//设置存活时间</span></span><br><span class="line">		set_ifa_lifetime(ifa, valid_lft, prefered_lft);</span><br><span class="line">		<span class="comment">//注意这里加入了组播地址</span></span><br><span class="line">		<span class="keyword">if</span> (ifa-&gt;ifa_flags &amp; IFA_F_MCAUTOJOIN) &#123;</span><br><span class="line">			<span class="type">int</span> ret = ip_mc_autojoin_config(net, <span class="literal">true</span>, ifa);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				NL_SET_ERR_MSG(extack, <span class="string">&quot;ipv4: Multicast auto join failed&quot;</span>);</span><br><span class="line">				inet_free_ifa(ifa);</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> __inet_insert_ifa(ifa, nlh, NETLINK_CB(skb).portid,</span><br><span class="line">					 extack);</span><br><span class="line">	<span class="comment">//地址已经存在 更新</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u32 new_metric = ifa-&gt;ifa_rt_priority;</span><br><span class="line">		u8 new_proto = ifa-&gt;ifa_proto;</span><br><span class="line"></span><br><span class="line">		inet_free_ifa(ifa);</span><br><span class="line">		<span class="comment">//必须是replace ip addr</span></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL ||</span><br><span class="line">		    !(nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)) &#123;</span><br><span class="line">			NL_SET_ERR_MSG(extack, <span class="string">&quot;ipv4: Address already assigned&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">		&#125;</span><br><span class="line">		ifa = ifa_existing;</span><br><span class="line">		<span class="comment">//更新mertic</span></span><br><span class="line">		<span class="keyword">if</span> (ifa-&gt;ifa_rt_priority != new_metric) &#123;</span><br><span class="line">			fib_modify_prefix_metric(ifa, new_metric);</span><br><span class="line">			ifa-&gt;ifa_rt_priority = new_metric;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新来源</span></span><br><span class="line">		ifa-&gt;ifa_proto = new_proto;</span><br><span class="line"></span><br><span class="line">		set_ifa_lifetime(ifa, valid_lft, prefered_lft);</span><br><span class="line">		cancel_delayed_work(&amp;check_lifetime_work);</span><br><span class="line">		queue_delayed_work(system_power_efficient_wq,</span><br><span class="line">				&amp;check_lifetime_work, <span class="number">0</span>);</span><br><span class="line">		rtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 <code>inet_rtm_newaddr</code> 是处理 <code>RTM_NEWADDR</code>类型<code>netlink</code> 消息的入口函数，它先把用户态发来的 <code>netlink</code> 报文解析成一个 <code>struct in_ifaddr</code>，然后判断是否已经存在该地址，<strong>如果不存在</strong>，就设置生命周期(默认是永久)，必要时进行组播自动加入，然后调用 <code>__inet_insert_ifa</code> 把该地址正式插入到 <code>in_device-&gt;ifa_list</code>，并触发路由等通知连，<strong>如果已存在</strong>，则可能更新该地址的路由优先级（<code>metric</code>），来源和生命周期。整个函数的核心思想就是：<strong>根据 <code>netlink</code> 语义，在内核中维护 <code>in_ifaddr</code> 的插入或更新</strong>。</p>
<p>上述<code>__inet_insert_ifa</code>为完成插入的实际函数（<strong>注意<code>ioctl</code>方式配置的IP地址也会调用到这个接口</strong>）具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __inet_insert_ifa(<span class="keyword">struct</span> in_ifaddr *ifa, <span class="keyword">struct</span> nlmsghdr *nlh,</span><br><span class="line">			     u32 portid, <span class="keyword">struct</span> netlink_ext_ack *extack)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> __<span class="title">rcu</span> **<span class="title">last_primary</span>, **<span class="title">ifap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> =</span> ifa-&gt;ifa_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_validator_info</span> <span class="title">ivi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> *<span class="title">ifa1</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ASSERT_RTNL();</span><br><span class="line">	<span class="comment">//用户配置的ip地址</span></span><br><span class="line">	<span class="keyword">if</span> (!ifa-&gt;ifa_local) &#123;</span><br><span class="line">		inet_free_ifa(ifa);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置为主地址</span></span><br><span class="line">	ifa-&gt;ifa_flags &amp;= ~IFA_F_SECONDARY;</span><br><span class="line">	last_primary = &amp;in_dev-&gt;ifa_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Don&#x27;t set IPv6 only flags to IPv4 addresses */</span></span><br><span class="line">	ifa-&gt;ifa_flags &amp;= ~IPV6ONLY_FLAGS;</span><br><span class="line"></span><br><span class="line">	ifap = &amp;in_dev-&gt;ifa_list;</span><br><span class="line">	ifa1 = rtnl_dereference(*ifap);</span><br><span class="line">	<span class="comment">/* 遍历设备已有地址列表 , 通常肯定没有*/</span></span><br><span class="line">	<span class="keyword">while</span> (ifa1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(ifa1-&gt;ifa_flags &amp; IFA_F_SECONDARY) &amp;&amp;</span><br><span class="line">		    ifa-&gt;ifa_scope &lt;= ifa1-&gt;ifa_scope)<span class="comment">//主地址</span></span><br><span class="line">			last_primary = &amp;ifa1-&gt;ifa_next;</span><br><span class="line">		<span class="comment">//是否是同一个子网</span></span><br><span class="line">		<span class="keyword">if</span> (ifa1-&gt;ifa_mask == ifa-&gt;ifa_mask &amp;&amp;</span><br><span class="line">		    inet_ifa_match(ifa1-&gt;ifa_address, ifa)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ifa1-&gt;ifa_local == ifa-&gt;ifa_local) &#123;</span><br><span class="line">				inet_free_ifa(ifa);</span><br><span class="line">				<span class="keyword">return</span> -EEXIST;<span class="comment">//完全相同</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ifa1-&gt;ifa_scope != ifa-&gt;ifa_scope) &#123;</span><br><span class="line">				NL_SET_ERR_MSG(extack, <span class="string">&quot;ipv4: Invalid scope value&quot;</span>);</span><br><span class="line">				inet_free_ifa(ifa);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;<span class="comment">//同网段却不同 scope 会导致路由冲突</span></span><br><span class="line">			&#125;</span><br><span class="line">			ifa-&gt;ifa_flags |= IFA_F_SECONDARY;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ifap = &amp;ifa1-&gt;ifa_next;</span><br><span class="line">		ifa1 = rtnl_dereference(*ifap);<span class="comment">//下一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow any devices that wish to register ifaddr validtors to weigh</span></span><br><span class="line"><span class="comment">	 * in now, before changes are committed.  The rntl lock is serializing</span></span><br><span class="line"><span class="comment">	 * access here, so the state should not change between a validator call</span></span><br><span class="line"><span class="comment">	 * and a final notify on commit.  This isn&#x27;t invoked on promotion under</span></span><br><span class="line"><span class="comment">	 * the assumption that validators are checking the address itself, and</span></span><br><span class="line"><span class="comment">	 * not the flags.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ivi.ivi_addr = ifa-&gt;ifa_address;</span><br><span class="line">	ivi.ivi_dev = ifa-&gt;ifa_dev;</span><br><span class="line">	ivi.extack = extack;</span><br><span class="line">	<span class="comment">//有没有注册这个链的</span></span><br><span class="line">	ret = blocking_notifier_call_chain(&amp;inetaddr_validator_chain,</span><br><span class="line">					   NETDEV_UP, &amp;ivi);</span><br><span class="line">	ret = notifier_to_errno(ret);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		inet_free_ifa(ifa);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通常走这里</span></span><br><span class="line">	<span class="keyword">if</span> (!(ifa-&gt;ifa_flags &amp; IFA_F_SECONDARY))</span><br><span class="line">		ifap = last_primary;</span><br><span class="line">	<span class="comment">//插入链表 新节点 next 指向原来的后继</span></span><br><span class="line">	rcu_assign_pointer(ifa-&gt;ifa_next, *ifap);</span><br><span class="line">	rcu_assign_pointer(*ifap, ifa);<span class="comment">//前驱</span></span><br><span class="line">	<span class="comment">//插入hash表</span></span><br><span class="line">	inet_hash_insert(dev_net(in_dev-&gt;dev), ifa);</span><br><span class="line">	<span class="comment">//检查ip存活时间的定时器</span></span><br><span class="line">	cancel_delayed_work(&amp;check_lifetime_work);</span><br><span class="line">	queue_delayed_work(system_power_efficient_wq, &amp;check_lifetime_work, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Send message first, then call notifier.</span></span><br><span class="line"><span class="comment">	   Notifier will trigger FIB update, so that</span></span><br><span class="line"><span class="comment">	   listeners of netlink will know about new ifaddr */</span></span><br><span class="line">	<span class="comment">//广播给用户态</span></span><br><span class="line">	rtmsg_ifa(RTM_NEWADDR, ifa, nlh, portid);</span><br><span class="line">	<span class="comment">//注意这段代码很关键，是通知了路由模块的通知连</span></span><br><span class="line">	blocking_notifier_call_chain(&amp;inetaddr_chain, NETDEV_UP, ifa);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/02/03/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/30/IP%E7%BC%96%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/30/IP%E7%BC%96%E5%88%B6/" class="post-title-link" itemprop="url">IPv4地址相关操作接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-30 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-30T22:00:00+08:00">2026-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-02-04 21:07:14" itemprop="dateModified" datetime="2026-02-04T21:07:14+08:00">2026-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/30/IP%E7%BC%96%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/30/IP%E7%BC%96%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文将分析内核IP地址是如何被管理及介绍操作IP地址的常用接口。要知道在内核网络协议栈中，IP地址是设置到主机的网络接口，同时一个网口可以有多个IP地址。<br><code>net_device</code>可以视作驱动与协议栈沟通的桥梁之一，其中IPv4相关的配置被<code>net_device</code>的<code>in_device</code>结构中，而具体的IP地址，子网掩码，广播地址等信息存放到<code>in_device</code>的<code>in_ifaddr</code>中，具体关系如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        ┌──────────────────────────┐</span><br><span class="line">        │     <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>     │</span></span><br><span class="line"><span class="class">        │         (<span class="title">e</span>.<span class="title">g</span>. <span class="title">eth0</span>)       │</span></span><br><span class="line"><span class="class">        └─────────────┬────────────┘</span></span><br><span class="line"><span class="class">                      │</span></span><br><span class="line"><span class="class">                      │  <span class="title">dev</span>-&gt;</span>ip_ptr / dev-&gt;__in_dev (IPv4)</span><br><span class="line">                      ▼</span><br><span class="line">        ┌──────────────────────────┐</span><br><span class="line">        │      <span class="class"><span class="keyword">struct</span> <span class="title">in_device</span>     │</span></span><br><span class="line"><span class="class">        │   (<span class="title">IPv4</span> <span class="title">per</span>-<span class="title">device</span> <span class="title">state</span>) │</span></span><br><span class="line"><span class="class">        └─────────────┬────────────┘</span></span><br><span class="line"><span class="class">                      │</span></span><br><span class="line"><span class="class">                      │  <span class="title">in_dev</span>-&gt;</span>ifa_list (链表头)</span><br><span class="line">                      ▼</span><br><span class="line">┌──────────────────────────┐</span><br><span class="line">│     <span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span>      │   ← 一个 <span class="title">IPv4</span> 地址对象</span></span><br><span class="line"><span class="class">│  <span class="title">ifa_local</span> / <span class="title">ifa_mask</span> ... │</span></span><br><span class="line"><span class="class">└─────────────┬────────────┘</span></span><br><span class="line"><span class="class">              │ <span class="title">ifa_next</span></span></span><br><span class="line"><span class="class">              ▼</span></span><br><span class="line"><span class="class">┌──────────────────────────┐</span></span><br><span class="line"><span class="class">│     <span class="keyword">struct</span> <span class="title">in_ifaddr</span>      │   ← 另一个 <span class="title">IPv4</span> 地址</span></span><br><span class="line"><span class="class">└─────────────┬────────────┘</span></span><br><span class="line"><span class="class">              │</span></span><br><span class="line"><span class="class">              ▼</span></span><br><span class="line"><span class="class">             ...</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<h3 id="in-device-结构"><a href="#in-device-结构" class="headerlink" title="in_device 结构"></a><code>in_device</code> 结构</h3><p><code>in_device</code> 是每个网络接口对应的 IPv4 管理结构。当驱动注册<code>net_device</code>时，内核在 <code>inetdev_init()</code> 中为该 <code>net_device</code> 创建一个 <code>in_device</code>，并通过 <code>dev-&gt;ip_ptr</code> 与之关联。<code>in_device</code> 本身并不保存具体的 IP 地址，而是维护一个链表，用来管理该网口上的所有 IPv4 地址。同时，<code>in_device</code> 还保存了该接口的 IPv4 行为配置（如 <code>rp_filter</code>、<code>arp_ignore</code>、<code>arp_announce</code>、<code>forwarding</code> 等）。</p>
<p>具体结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>	*<span class="title">dev</span>;</span>	<span class="comment">//对应的netdev</span></span><br><span class="line">	netdevice_tracker	dev_tracker;</span><br><span class="line"></span><br><span class="line">	<span class="type">refcount_t</span>		refcnt;		<span class="comment">//引用计数</span></span><br><span class="line">	<span class="type">int</span>			dead;			<span class="comment">//标识设备是否已经销毁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span>	__<span class="title">rcu</span> *<span class="title">ifa_list</span>;</span><span class="comment">/* IP ifaddr chain		*/</span><span class="comment">//管理所有ip地址的链表</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_list</span> __<span class="title">rcu</span>	*<span class="title">mc_list</span>;</span>	<span class="comment">/* IP multicast filter chain    */</span><span class="comment">//多播地址的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_list</span> __<span class="title">rcu</span>	* __<span class="title">rcu</span> *<span class="title">mc_hash</span>;</span>	<span class="comment">//多播组hash表</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			mc_count;	<span class="comment">/* Number of installed mcasts	*/</span><span class="comment">//加入多播组的数量</span></span><br><span class="line">	<span class="type">spinlock_t</span>		mc_tomb_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_list</span>	*<span class="title">mc_tomb</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		mr_v1_seen;		<span class="comment">//igmpv1 查询时间</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		mr_v2_seen;		<span class="comment">//igmpv2 查询时间</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		mr_maxdelay;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		mr_qi;		<span class="comment">/* Query Interval */</span><span class="comment">//查询间隔</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		mr_qri;		<span class="comment">/* Query Response Interval */</span><span class="comment">//查询响应间隔</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		mr_qrv;		<span class="comment">/* Query Robustness Variable */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		mr_gq_running;</span><br><span class="line">	u32			mr_ifc_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">mr_gq_timer</span>;</span>	<span class="comment">/* general query timer */</span><span class="comment">//igmp的定时器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">mr_ifc_timer</span>;</span>	<span class="comment">/* interface change timer */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neigh_parms</span>	*<span class="title">arp_parms</span>;</span>	<span class="comment">//指向arp表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipv4_devconf</span>	<span class="title">cnf</span>;</span>		<span class="comment">//具体的配置，例如forward，反向路由过滤，arp ignore等</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="in-ifaddr结构"><a href="#in-ifaddr结构" class="headerlink" title="in_ifaddr结构"></a><code>in_ifaddr</code>结构</h3><p><code>in_ifaddr</code> 是 Linux 内核中 <strong>一个具体 IPv4 地址的实体对象</strong>。<strong>当执行 <code>ip addr add ... dev eth0</code> 时，内核并不是把 IP 直接写进网口，而是创建一个 <code>in_ifaddr</code> 结构体，并将其挂到该网口对应的 <code>in_device-&gt;ifa_list</code> 链表中</strong>。这个结构体中保存了该地址的核心信息，如本机地址、广播地址、子网掩码、作用域、标志位等。具体结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hash</span>;</span>			<span class="comment">//这个结构体同时也被一个全局hash表管理</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span>	__<span class="title">rcu</span> *<span class="title">ifa_next</span>;</span><span class="comment">//同一个设备的下一个ip地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_device</span>	*<span class="title">ifa_dev</span>;</span>		<span class="comment">//指向in_device 也就是管理结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu_head</span>;</span></span><br><span class="line">	__be32			ifa_local;			<span class="comment">//用户配置的ip地址</span></span><br><span class="line">	__be32			ifa_address;		<span class="comment">//子网？</span></span><br><span class="line">	__be32			ifa_mask;			<span class="comment">//子网掩码</span></span><br><span class="line">	__u32			ifa_rt_priority;	<span class="comment">//路由优先级影响的是metric</span></span><br><span class="line">	__be32			ifa_broadcast;		<span class="comment">//广播地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		ifa_scope;		<span class="comment">//这个地址的可达范围，默认是全局可达</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		ifa_prefixlen;	<span class="comment">//前缀长度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		ifa_proto;		<span class="comment">//标识路由的来源，比如是用户加的还是kernel自己生成的</span></span><br><span class="line">	__u32			ifa_flags;			<span class="comment">//标志位，比如是否是主ip地址</span></span><br><span class="line">	<span class="type">char</span>			ifa_label[IFNAMSIZ];<span class="comment">//接口的别名</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */</span></span><br><span class="line">	__u32			ifa_valid_lft;		<span class="comment">//存活的时间</span></span><br><span class="line">	__u32			ifa_preferred_lft;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ifa_cstamp; <span class="comment">/* created timestamp */</span><span class="comment">//时间戳</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ifa_tstamp; <span class="comment">/* updated timestamp */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IP-操作函数"><a href="#IP-操作函数" class="headerlink" title="IP 操作函数"></a>IP 操作函数</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/30/IP%E7%BC%96%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/28/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/28/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-主动关闭（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-28 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-28T22:00:00+08:00">2026-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-26 23:44:59" itemprop="dateModified" datetime="2026-01-26T23:44:59+08:00">2026-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/28/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/28/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_time_wait</code>主要做了四件事，创建<code>tw</code>套接字，拷贝sk必要的字段到<code>tw sock</code>中，插入<code>ehash</code>中（完成<code>hashdance</code>），释放<code>sk</code>资源。</p>
<p>上述创建<code>tw</code>套接字的过程中设置了<code>tw</code>定时器的回调(注意并没有激活定时器)，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inet_timewait_sock *<span class="title function_">inet_twsk_alloc</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> inet_timewait_death_row *dr,</span></span><br><span class="line"><span class="params">					   <span class="type">const</span> <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_sock</span> *<span class="title">tw</span>;</span></span><br><span class="line">	<span class="comment">//是否超过了最大的tw套接字的数量</span></span><br><span class="line">	<span class="keyword">if</span> (refcount_read(&amp;dr-&gt;tw_refcount) - <span class="number">1</span> &gt;=</span><br><span class="line">	    READ_ONCE(dr-&gt;sysctl_max_tw_buckets))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//申请tw套接字</span></span><br><span class="line">	tw = kmem_cache_alloc(sk-&gt;sk_prot_creator-&gt;twsk_prot-&gt;twsk_slab,</span><br><span class="line">			      GFP_ATOMIC);</span><br><span class="line">	<span class="comment">//copy必要的字段</span></span><br><span class="line">	<span class="keyword">if</span> (tw) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line"></span><br><span class="line">		tw-&gt;tw_dr	    = dr;</span><br><span class="line">		<span class="comment">/* Give us an identity. */</span></span><br><span class="line">		tw-&gt;tw_daddr	    = inet-&gt;inet_daddr;</span><br><span class="line">		tw-&gt;tw_rcv_saddr    = inet-&gt;inet_rcv_saddr;</span><br><span class="line">		tw-&gt;tw_bound_dev_if = sk-&gt;sk_bound_dev_if;</span><br><span class="line">		tw-&gt;tw_tos	    = inet-&gt;tos;</span><br><span class="line">		tw-&gt;tw_num	    = inet-&gt;inet_num;</span><br><span class="line">		tw-&gt;tw_state	    = TCP_TIME_WAIT;</span><br><span class="line">		tw-&gt;tw_substate	    = state; <span class="comment">//这个状态很关键，用于区别是什么状态下收到的套接字</span></span><br><span class="line">		tw-&gt;tw_sport	    = inet-&gt;inet_sport;</span><br><span class="line">		tw-&gt;tw_dport	    = inet-&gt;inet_dport;</span><br><span class="line">		tw-&gt;tw_family	    = sk-&gt;sk_family;</span><br><span class="line">		tw-&gt;tw_reuse	    = sk-&gt;sk_reuse;</span><br><span class="line">		tw-&gt;tw_reuseport    = sk-&gt;sk_reuseport;</span><br><span class="line">		tw-&gt;tw_hash	    = sk-&gt;sk_hash;</span><br><span class="line">		tw-&gt;tw_ipv6only	    = <span class="number">0</span>;</span><br><span class="line">		tw-&gt;tw_transparent  = inet_test_bit(TRANSPARENT, sk);</span><br><span class="line">		tw-&gt;tw_prot	    = sk-&gt;sk_prot_creator;</span><br><span class="line">		atomic64_set(&amp;tw-&gt;tw_cookie, atomic64_read(&amp;sk-&gt;sk_cookie));</span><br><span class="line">		twsk_net_set(tw, sock_net(sk));</span><br><span class="line">		<span class="comment">//这里设置tw 定时器的回调</span></span><br><span class="line">		timer_setup(&amp;tw-&gt;tw_timer, tw_timer_handler, TIMER_PINNED);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because we use RCU lookups, we should not set tw_refcnt</span></span><br><span class="line"><span class="comment">		 * to a non null value before everything is setup for this</span></span><br><span class="line"><span class="comment">		 * timewait socket.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		refcount_set(&amp;tw-&gt;tw_refcnt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		__module_get(tw-&gt;tw_prot-&gt;owner);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点关注<code>tw-&gt;tw_substate</code>状态的处理，这里区分了当前<code>tw sock</code> 是finwait2状态创建的还是<code>timewati</code>状态下创建的。当创建<code>tw</code>状态套接字插入到<code>ehash</code>中之后，后续收到的数据包都找到的是<code>tw</code>状态的<code>sk</code>并跳转到<code>tw</code>状态进行处理，具体代码逻辑如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	sk = __inet_lookup_skb(net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">			       skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">			       th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">process:</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)</span><br><span class="line">		<span class="keyword">goto</span> do_time_wait;</span><br><span class="line">	...</span><br><span class="line"><span class="comment">//tw状态的处理</span></span><br><span class="line">do_time_wait:</span><br><span class="line">	<span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb)) &#123;</span><br><span class="line">		drop_reason = SKB_DROP_REASON_XFRM_POLICY;</span><br><span class="line">		inet_twsk_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">		inet_twsk_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//决定怎么处理这个包</span></span><br><span class="line">	<span class="keyword">switch</span> (tcp_timewait_state_process(inet_twsk(sk), skb, th)) &#123;</span><br><span class="line">	<span class="comment">//允许重新开始三次握手</span></span><br><span class="line">	<span class="keyword">case</span> TCP_TW_SYN: &#123;</span><br><span class="line">		<span class="comment">//找到监听套接字</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> =</span> inet_lookup_listener(net,</span><br><span class="line">							net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">							skb, __tcp_hdrlen(th),</span><br><span class="line">							iph-&gt;saddr, th-&gt;source,</span><br><span class="line">							iph-&gt;daddr, th-&gt;dest,</span><br><span class="line">							inet_iif(skb),</span><br><span class="line">							sdif);</span><br><span class="line">		<span class="keyword">if</span> (sk2) &#123;</span><br><span class="line">			<span class="comment">//将tw套接字直接释放</span></span><br><span class="line">			inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">			sk = sk2;</span><br><span class="line">			tcp_v4_restore_cb(skb);</span><br><span class="line">			refcounted = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">goto</span> process;<span class="comment">//注意这里回到三次握手的处理中</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">/* to ACK */</span></span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_ACK:</span><br><span class="line">		<span class="comment">//对端重传fin，或者发了窗口外的数据包这里在回复一个ack，或者最后一个ack</span></span><br><span class="line">		tcp_v4_timewait_ack(sk, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_RST:</span><br><span class="line">		<span class="comment">//比如在finwait2阶段收到了syn包</span></span><br><span class="line">		tcp_v4_send_reset(sk, skb);</span><br><span class="line">		<span class="comment">//真正释放资源</span></span><br><span class="line">		inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_SUCCESS:;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> discard_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code>到<code>timewait</code>处理逻辑后首先调用<code>tcp_timewait_state_process</code>根据返回值决定怎么处理这个数据包，<code>tcp_timewait_state_process</code>具体实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> tcp_tw_status</span><br><span class="line"><span class="title function_">tcp_timewait_state_process</span><span class="params">(<span class="keyword">struct</span> inet_timewait_sock *tw, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">			   <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_options_received</span> <span class="title">tmp_opt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_timewait_sock</span> *<span class="title">tcptw</span> =</span> tcp_twsk((<span class="keyword">struct</span> sock *)tw);</span><br><span class="line">	<span class="type">bool</span> paws_reject = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	tmp_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//如果存在时间戳，再通过PAWS机制判断是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;doff &gt; (<span class="keyword">sizeof</span>(*th) &gt;&gt; <span class="number">2</span>) &amp;&amp; tcptw-&gt;tw_ts_recent_stamp) &#123;</span><br><span class="line">		tcp_parse_options(twsk_net(tw), skb, &amp;tmp_opt, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp_opt.rcv_tsecr)</span><br><span class="line">				tmp_opt.rcv_tsecr -= tcptw-&gt;tw_ts_offset;</span><br><span class="line">			tmp_opt.ts_recent	= tcptw-&gt;tw_ts_recent;</span><br><span class="line">			tmp_opt.ts_recent_stamp	= tcptw-&gt;tw_ts_recent_stamp;</span><br><span class="line">			paws_reject = tcp_paws_reject(&amp;tmp_opt, th-&gt;rst);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是finwait2状态下创建的套接字</span></span><br><span class="line">	<span class="keyword">if</span> (tw-&gt;tw_substate == TCP_FIN_WAIT2) &#123;</span><br><span class="line">		<span class="comment">/* Just repeat all the checks of tcp_rcv_state_process() */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Out of window, send ACK */</span></span><br><span class="line">		<span class="comment">//如果没有通过paws机制检查，或者超出了窗口则会回一个ack</span></span><br><span class="line">		<span class="keyword">if</span> (paws_reject ||</span><br><span class="line">		    !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,</span><br><span class="line">				   tcptw-&gt;tw_rcv_nxt,</span><br><span class="line">				   tcptw-&gt;tw_rcv_nxt + tcptw-&gt;tw_rcv_wnd))</span><br><span class="line">			<span class="keyword">return</span> tcp_timewait_check_oow_rate_limit(</span><br><span class="line">				tw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);</span><br><span class="line">		<span class="comment">//如果通过了检查携带rst，直接清除tw套接字释放资源</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line">			<span class="keyword">goto</span> kill;</span><br><span class="line">		<span class="comment">//TCP_FIN_WAIT2状态下收到syn包 同时syn包大于下一个待接收的序列号，则直接回rst</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;syn &amp;&amp; !before(TCP_SKB_CB(skb)-&gt;seq, tcptw-&gt;tw_rcv_nxt))</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_RST;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Dup ACK? */</span></span><br><span class="line">		<span class="comment">//没有ack标志位，或者是重复的ack</span></span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;ack ||</span><br><span class="line">		    !after(TCP_SKB_CB(skb)-&gt;end_seq, tcptw-&gt;tw_rcv_nxt) ||</span><br><span class="line">		    TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq) &#123;</span><br><span class="line">			inet_twsk_put(tw);</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_SUCCESS; <span class="comment">//外面默默丢弃了</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* New data or FIN. If new data arrive after half-duplex close,</span></span><br><span class="line"><span class="comment">		 * reset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//不是fin或者是新数据，直接回rst，这里是意味着finwait2就不能接对端继续发呆数据包吗？</span></span><br><span class="line">		<span class="comment">//注意可能是因为这里是tw套接字承载着finwait2</span></span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;fin ||</span><br><span class="line">		    TCP_SKB_CB(skb)-&gt;end_seq != tcptw-&gt;tw_rcv_nxt + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_RST;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* FIN arrived, enter true time-wait state. */</span></span><br><span class="line">		<span class="comment">//走到这里表示收到了合法的fin包</span></span><br><span class="line">		tw-&gt;tw_substate	  = TCP_TIME_WAIT;</span><br><span class="line">		<span class="comment">//更新下一个待接收的序号</span></span><br><span class="line">		tcptw-&gt;tw_rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			tcptw-&gt;tw_ts_recent_stamp = ktime_get_seconds();</span><br><span class="line">			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//注意这里是重新开始tw 计时</span></span><br><span class="line">		inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_ACK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Now real TIME-WAIT state.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	RFC 1122:</span></span><br><span class="line"><span class="comment">	 *	&quot;When a connection is [...] on TIME-WAIT state [...]</span></span><br><span class="line"><span class="comment">	 *	[a TCP] MAY accept a new SYN from the remote TCP to</span></span><br><span class="line"><span class="comment">	 *	reopen the connection directly, if it:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	(1)  assigns its initial sequence number for the new</span></span><br><span class="line"><span class="comment">	 *	connection to be larger than the largest sequence</span></span><br><span class="line"><span class="comment">	 *	number it used on the previous connection incarnation,</span></span><br><span class="line"><span class="comment">	 *	and</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	(2)  returns to TIME-WAIT state if the SYN turns out</span></span><br><span class="line"><span class="comment">	 *	to be an old duplicate&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//正常timewait状态的处理，通过了检查如果是纯ack或者是rst</span></span><br><span class="line">	<span class="keyword">if</span> (!paws_reject &amp;&amp;</span><br><span class="line">	    (TCP_SKB_CB(skb)-&gt;seq == tcptw-&gt;tw_rcv_nxt &amp;&amp;</span><br><span class="line">	     (TCP_SKB_CB(skb)-&gt;seq == TCP_SKB_CB(skb)-&gt;end_seq || th-&gt;rst))) &#123;</span><br><span class="line">		<span class="comment">/* In window segment, it may be only reset or bare ack. */</span></span><br><span class="line">		<span class="comment">//如果收到了rst 直接释放资源</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line">			<span class="comment">/* This is TIME_WAIT assassination, in two flavors.</span></span><br><span class="line"><span class="comment">			 * Oh well... nobody has a sufficient solution to this</span></span><br><span class="line"><span class="comment">			 * protocol bug yet.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!READ_ONCE(twsk_net(tw)-&gt;ipv4.sysctl_tcp_rfc1337)) &#123;</span><br><span class="line">kill:</span><br><span class="line">				inet_twsk_deschedule_put(tw);</span><br><span class="line">				<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//重新开始定时器，因为可能是ack丢失了</span></span><br><span class="line">			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;</span><br><span class="line">			tcptw-&gt;tw_ts_recent_stamp = ktime_get_seconds();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		inet_twsk_put(tw);</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Out of window segment.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   All the segments are ACKed immediately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   The only exception is new SYN. We accept it, if it is</span></span><br><span class="line"><span class="comment">	   not old duplicate and we are not in danger to be killed</span></span><br><span class="line"><span class="comment">	   by delayed old duplicates. RFC check is that it has</span></span><br><span class="line"><span class="comment">	   newer sequence number works at rates &lt;40Mbit/sec.</span></span><br><span class="line"><span class="comment">	   However, if paws works, it is reliable AND even more,</span></span><br><span class="line"><span class="comment">	   we even may relax silly seq space cutoff.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   RED-PEN: we violate main RFC requirement, if this SYN will appear</span></span><br><span class="line"><span class="comment">	   old duplicate (i.e. we receive RST in reply to SYN-ACK),</span></span><br><span class="line"><span class="comment">	   we must return socket to time-wait state. It is not good,</span></span><br><span class="line"><span class="comment">	   but not fatal yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//窗口外的数据包，如果是纯syn包，注意这里会重新在外面找listne套接字</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;syn &amp;&amp; !th-&gt;rst &amp;&amp; !th-&gt;ack &amp;&amp; !paws_reject &amp;&amp;</span><br><span class="line">	    (after(TCP_SKB_CB(skb)-&gt;seq, tcptw-&gt;tw_rcv_nxt) ||<span class="comment">//序列号大于下一个待接收的</span></span><br><span class="line">	     (tmp_opt.saw_tstamp &amp;&amp;</span><br><span class="line">	      (s32)(tcptw-&gt;tw_ts_recent - tmp_opt.rcv_tsval) &lt; <span class="number">0</span>))) &#123;<span class="comment">//时间戳合理</span></span><br><span class="line">		u32 isn = tcptw-&gt;tw_snd_nxt + <span class="number">65535</span> + <span class="number">2</span>;<span class="comment">//必须大于旧连接的序列号</span></span><br><span class="line">		<span class="keyword">if</span> (isn == <span class="number">0</span>)</span><br><span class="line">			isn++;</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_tw_isn = isn;</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_SYN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于PAWS拒绝</span></span><br><span class="line">	<span class="keyword">if</span> (paws_reject)</span><br><span class="line">		__NET_INC_STATS(twsk_net(tw), LINUX_MIB_PAWSESTABREJECTED);</span><br><span class="line">	<span class="comment">//没有携带rst，但是由于序列号被拒绝 会ack，但是限速</span></span><br><span class="line">	<span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line">		<span class="comment">/* In this case we must reset the TIMEWAIT timer.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If it is ACKless SYN it may be both old duplicate</span></span><br><span class="line"><span class="comment">		 * and new good SYN with random sequence number &lt;rcv_nxt.</span></span><br><span class="line"><span class="comment">		 * Do not reschedule in the last case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (paws_reject || th-&gt;ack)</span><br><span class="line">			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tcp_timewait_check_oow_rate_limit(</span><br><span class="line">			tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);</span><br><span class="line">	&#125;</span><br><span class="line">	inet_twsk_put(tw);</span><br><span class="line">	<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_timewait_state_process</code>首先PAWS机制检查数据包是否合法，</p>
<p>如果当前的<code>tw</code>套接字是<code>fin_wait2</code>状态下创建的，具体处理情况如下所示：</p>
<ul>
<li>窗口外 &#x2F; PAWS 失 回 ACK（限速）</li>
<li>收到 RST 直接 <code>kill tw_sock</code></li>
<li>收到 SYN 且 seq 合法 → 回 RST</li>
<li>防止旧连接干扰新连接建立。</li>
<li>纯 ACK &#x2F; 重复 ACK  丢弃报文</li>
<li>如果不是 FIN，或者 FIN 位置不对 回RST</li>
<li>收到了和发<code>fin</code>真正进入<code>timewait</code>状态</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/28/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-主动关闭（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-26 22:00:00 / 修改时间：23:43:39" itemprop="dateCreated datePublished" datetime="2026-01-26T22:00:00+08:00">2026-01-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在TCP连接终止的过程中，主动关闭连接的一方会经历如下所示的四个状态：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ESTABLISHED</span><br><span class="line">    ↓ <span class="built_in">close</span>()</span><br><span class="line">FIN_WAIT_1</span><br><span class="line">    ↓ 收到 <span class="built_in">ACK</span>(对方确认FIN)</span><br><span class="line">FIN_WAIT_2</span><br><span class="line">    ↓ 收到 对方FIN</span><br><span class="line">TIME_WAIT   ← 核心</span><br><span class="line">    ↓ <span class="number">2MS</span>L</span><br><span class="line">CLOSED</span><br></pre></td></tr></table></figure>

<p>主动关闭方发送<code>fin</code>段之后会进入到FIN_WAIT_1状态，如果收到了<code>fin</code>的确认则状态迁移到FIN_WAIT_2，并有可能创建<code>tw</code>套接字（也有可能不创建，取决于用户配置，也取决于系统当前<code>tw</code>套接字数量），如果在FIN_WAIT_2状态下收到了对端的<code>fin</code>则会发送<code>ack</code>并启动TIME_WAIT定时器。<strong>TIME_WAIT状态存在的原因其实就一个，防止旧的连接干扰新的连接。</strong></p>
<p>由于主动关闭方发送<code>fin</code>段之后由于已经不是建立连接状态，因此接收到的数据包都有由<code>cp_rcv_state_process</code>处理，这里重点分析发送<code>fin</code>段之后进入FIN_WAIT_1状态，等待对端确认的逻辑，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_rcv_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1: &#123;</span><br><span class="line">		<span class="type">int</span> tmo;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req)</span><br><span class="line">			tcp_rcv_synrecv_state_fastopen(sk);</span><br><span class="line">		<span class="comment">//这如果break了，表示对端还没有收到本段发出的fin</span></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;snd_una != tp-&gt;write_seq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//对端确认了本端发送的fin，这里设置为fin_wait2状态</span></span><br><span class="line">		tcp_set_state(sk, TCP_FIN_WAIT2);</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_shutdown, sk-&gt;sk_shutdown | SEND_SHUTDOWN);</span><br><span class="line"></span><br><span class="line">		sk_dst_confirm(sk);</span><br><span class="line">		<span class="comment">//如果在close中还没有设置dead 那这里就直接推出了！ 什么情况下还么没有设置dead？ 当启用linger的时候（注意区分linger2）</span></span><br><span class="line">		<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">			<span class="comment">/* Wake up lingering close() */</span></span><br><span class="line">			sk-&gt;sk_state_change(sk);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (READ_ONCE(tp-&gt;linger2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			tcp_done(sk);</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">		    after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">			<span class="comment">/* Receive out of order FIN after close() */</span></span><br><span class="line">			<span class="keyword">if</span> (tp-&gt;syn_fastopen &amp;&amp; th-&gt;fin)</span><br><span class="line">				tcp_fastopen_active_disable(sk);</span><br><span class="line">			tcp_done(sk);</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这里的代码逻辑如下：首先是围绕这个tmo来处理，这个tmo的值简单可以概括成用户是否配置，</span></span><br><span class="line"><span class="comment">		如果配置了那就要看这个值大还是小，如果没有配置，那就是</span></span><br><span class="line"><span class="comment">		走正常1分钟超时逻辑。如果用户配置了linger2 且 大于1分钟的话，</span></span><br><span class="line"><span class="comment">		那就先启动fin_wait2d定时器，注意这个定时器到期的时间时配置的时间减去一分钟，</span></span><br><span class="line"><span class="comment">		然后在这样就会先在 FIN_WAIT2 等 tmo - TIMEWAIT_LEN，</span></span><br><span class="line"><span class="comment">		到点再进 TIME_WAIT*/</span></span><br><span class="line">		<span class="comment">//用户配置的时间，或者是默认的60s</span></span><br><span class="line">		tmo = tcp_fin_time(sk);</span><br><span class="line">		<span class="comment">//tmo超过60s的情况,这里启动fin_wait2定时器，当定时到期还没有收到对方的fin包的话当定时器到期的时候tcp_time_wait，</span></span><br><span class="line">		<span class="comment">// 里面会启动一个定时器，如果此时收到了fin包则会找到tw套接字重新经过60秒的时间</span></span><br><span class="line">		<span class="comment">// 如果还超时了则直接释放资源。</span></span><br><span class="line">		<span class="comment">// 如果fin_wait2定时器没有到期的时候收到了fin包，则会在下tcp_fin中调用tcp_time_wait</span></span><br><span class="line">		<span class="keyword">if</span> (tmo &gt; TCP_TIMEWAIT_LEN) &#123;</span><br><span class="line">			<span class="comment">//fin_wait2定时器</span></span><br><span class="line">			inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);</span><br><span class="line">		<span class="comment">//这里是正常抓包三次挥手时候走的逻辑，如果收到fin 或者 用户锁住了sock 就会进入这个分支</span></span><br><span class="line">		<span class="comment">// 问题是收到fin包为什么会启动一个定时器呢？不应该直接进入timewwwai吗？？</span></span><br><span class="line">		<span class="comment">// 这里的逻辑如果linger2小于60秒 则启动一个时常为linger2的定时器，如果这里右fin标志后面回直接tcp_fin的处理中回直接进入timewait状态</span></span><br><span class="line">		<span class="comment">//如果是由于用户持有锁进入这个分支则启动一个60s的fin_wati2定时器当定时器到期还没有收到fin 的话就rst，如果期间收到了fin的话则tcp_fin会处理</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (th-&gt;fin || sock_owned_by_user(sk)) &#123;</span><br><span class="line">			<span class="comment">/* Bad case. We could lose such FIN otherwise.</span></span><br><span class="line"><span class="comment">			 * It is not a big problem, but it looks confusing</span></span><br><span class="line"><span class="comment">			 * and not so rare event. We still can lose it now,</span></span><br><span class="line"><span class="comment">			 * if it spins in bh_lock_sock(), but it is really</span></span><br><span class="line"><span class="comment">			 * marginal case.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">////对端的数据包带fin或者用户持有sock</span></span><br><span class="line">			<span class="comment">//fin_wait2定时器 tcp_keepalive_timer</span></span><br><span class="line">			inet_csk_reset_keepalive_timer(sk, tmo);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//正常四次挥手的逻辑，没有fin 标志位，这里启动一个60s的fin_wait2定时器</span></span><br><span class="line">		<span class="comment">//注意这里直接创建了tw套接字，进入了tw状态，如果60s每有收到fin则直接释放资源，如果收到了fin则在</span></span><br><span class="line">		<span class="comment">//外层中会直接找到这个tw套接字，并重新开始计时！！！！，这个和上面linger2大于60 有点类似 本质上是防止对端不发fin 我方不释放资源</span></span><br><span class="line">			tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);</span><br><span class="line">			<span class="keyword">goto</span> consume;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 6: check the URG bit */</span></span><br><span class="line">	tcp_urg(sk, skb, th);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 7: process the segment text */</span></span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">	<span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">		<span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">			<span class="comment">/* If a subflow has been reset, the packet should not</span></span><br><span class="line"><span class="comment">			 * continue to be processed, drop the packet.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (sk_is_mptcp(sk) &amp;&amp; !mptcp_incoming_options(sk, skb))</span><br><span class="line">				<span class="keyword">goto</span> discard;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">		<span class="comment">/* RFC 793 says to queue data in these states,</span></span><br><span class="line"><span class="comment">		 * RFC 1122 says we MUST send a reset.</span></span><br><span class="line"><span class="comment">		 * BSD 4.4 also does reset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//收到了对端的fin</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) &#123;</span><br><span class="line">			<span class="comment">//如果数据包携带数据，发rst复位连接</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">			    after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">				NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">				tcp_reset(sk, skb);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;<span class="comment">//注意这里如果是处于finwai2状态，则直接继续执行，fin包交给tcp_data_queuec处理</span></span><br><span class="line">	<span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">		tcp_data_queue(sk, skb);</span><br><span class="line">		queued = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主动关闭方发送<code>fin</code>包之后，后续收到的报文都会交由这个处理逻辑来处理，首先判断发出去的fin是否已经被确认过了，如果没有确认则直接<code>break</code>，如果确认了则将状态设置为TCP_FIN_WAIT2，<strong>接下来判断是否优雅的关闭（linger2 &lt;0）或者收到了<code>fin</code>但携带额外数据，则调用<code>tcp_done</code>直接关闭，不经历完整的四次挥手。</strong></p>
<p><strong>接下来的处理则根据<code>tmo</code>的值走不同的处理逻辑</strong>，<code>tmo</code>的计算逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tcp_fin_time</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果设置了linger2就用用户配置的，否则用系统的</span></span><br><span class="line">	<span class="type">int</span> fin_timeout = tcp_sk(sk)-&gt;linger2 ? :</span><br><span class="line">		READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_fin_timeout);</span><br><span class="line">	<span class="comment">//在拿到rto</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> rto = inet_csk(sk)-&gt;icsk_rto;</span><br><span class="line">	<span class="comment">//如果基础超时时间 fin_timeout小于3.5 * RTO 则设置为3.5个rto </span></span><br><span class="line">	<span class="comment">// 大概率不会进来吧 </span></span><br><span class="line">	<span class="keyword">if</span> (fin_timeout &lt; (rto &lt;&lt; <span class="number">2</span>) - (rto &gt;&gt; <span class="number">1</span>))</span><br><span class="line">		fin_timeout = (rto &lt;&lt; <span class="number">2</span>) - (rto &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fin_timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户配置了大于60s的<code>tmo</code>则启动一个<code>finwait2</code>定时器，如果这个定时器到期了则会创建一个TCP_FIN_WAIT2状态的<code>tw</code>套接字。如果没到期的情况下收到了<code>fin</code>包则会被下面的<code>tcp_fin</code>处理，启动正常<code>tw</code>状态的定时器。</p>
<p>如果没有配置<code>tmo</code>，则进一步判断当前数据包是否已经携带了<code>fin</code>（四次握手合并成了三次的情况）或者<code>sk</code>当前被用户持有则会启动fin_wait2定时器，防止对端不发送<code>fin</code>（用户被锁住的情况），如果携带了<code>fin</code>则会在下面的处理逻辑中同样交由<code>tcp_fin</code>处理（注意法<code>fall through</code>），里面会启动<code>tw</code>状态的定时器，<strong>注意这里和第一种启动定时器的类似，都是复用保活定时器(保活定时器中增加了对<code>fin_wait2</code>状态的特殊处理)具体代码如下所示：</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-被动关闭</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-24 22:00:00 / 修改时间：23:56:07" itemprop="dateCreated datePublished" datetime="2026-01-24T22:00:00+08:00">2026-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>被动关闭方在处于ESTABLISHED状态时，收到的TCP段都由<code>tcp_rcv_established</code>来处理，若此时收到主动关闭方的FIN段无法命中快速路径（因为标志中不包含<code>fin</code>）所以必然走慢速路径，前文分析过慢速路径如果序列号是预期也会直接放到接收队列，否则放入乱序队列。在接收队列的处理逻辑中会判断是否携带<code>fin</code>标志，如果携带<code>fin</code>标志则会调用<code>tcp_fin</code>进行处理，具体代码如下所示 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_data_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) &#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">		<span class="comment">//四次挥手fin包处理逻辑</span></span><br><span class="line">			tcp_fin(sk);</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	tcp_data_queue_ofo(sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_fin</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//收到了fin包肯定需要确认</span></span><br><span class="line">	inet_csk_schedule_ack(sk);</span><br><span class="line">	<span class="comment">//接收方向shutdown 因为对端关闭了,进程上下文从接收队列获取数据的时候会判断</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_shutdown, sk-&gt;sk_shutdown | RCV_SHUTDOWN);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	sock_set_flag(sk, SOCK_DONE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">	<span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">		<span class="comment">/* Move to CLOSE_WAIT */</span></span><br><span class="line">		<span class="comment">//建连接或者客户端已经认为建立连接成功的情况下进入closewait状态</span></span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE_WAIT);</span><br><span class="line">		<span class="comment">//进入pingpong模式，因为四次挥手对时延要求高，所以回复ack要快</span></span><br><span class="line">		inet_csk_enter_pingpong_mode(sk);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//认为时重传的ifn不处理</span></span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">		<span class="comment">/* Received a retransmission of the FIN, do</span></span><br><span class="line"><span class="comment">		 * nothing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">		<span class="comment">/* RFC793: Remain in the LAST-ACK state. */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//发送fin后收到fin表示同时关闭</span></span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">		<span class="comment">/* This case occurs when a simultaneous close</span></span><br><span class="line"><span class="comment">		 * happens, we must ack the received FIN and</span></span><br><span class="line"><span class="comment">		 * enter the CLOSING state.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//发送ack</span></span><br><span class="line">		tcp_send_ack(sk);</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSING);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">		<span class="comment">/* Received a FIN -- send ACK and enter TIME_WAIT. */</span></span><br><span class="line">		<span class="comment">//主动关闭的一方收到了对端的fin，发送最后一个ack 并进入tw状态，合理</span></span><br><span class="line">		tcp_send_ack(sk);</span><br><span class="line">		tcp_time_wait(sk, TCP_TIME_WAIT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* Only TCP_LISTEN and TCP_CLOSE are left, in these</span></span><br><span class="line"><span class="comment">		 * cases we should never reach this piece of code.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pr_err(<span class="string">&quot;%s: Impossible, sk-&gt;sk_state=%d\n&quot;</span>,</span><br><span class="line">		       __func__, sk-&gt;sk_state);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* It _is_ possible, that we have something out-of-order _after_ FIN.</span></span><br><span class="line"><span class="comment">	 * Probably, we should reset in this case. For now drop them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//清理乱序队列，概率很小吧，都发送fin了后面还有数据&gt;</span></span><br><span class="line">	skb_rbtree_purge(&amp;tp-&gt;out_of_order_queue);</span><br><span class="line">	<span class="keyword">if</span> (tcp_is_sack(tp))</span><br><span class="line">	<span class="comment">//复位sack的信息</span></span><br><span class="line">		tcp_sack_reset(&amp;tp-&gt;rx_opt);</span><br><span class="line">	<span class="comment">//如果没死，则唤醒用户的进程</span></span><br><span class="line">	<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">		sk-&gt;sk_state_change(sk);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not send POLL_HUP for half duplex close. */</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK ||</span><br><span class="line">		    sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);<span class="comment">//两个方向都关闭</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);<span class="comment">//关闭了一个方向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注建连状态下的处理，<code>tcp_fin</code>中首先设置需要发送<code>ack</code>的标志位（<strong>由于收到了<code>fin</code>包需要确认，注意这里其实就是第二次挥手发送的<code>ack</code>报文</strong>），并处理了关闭流程中不同状态的迁移，之后设置 <code>RCV_SHUTDOWN</code>，表示发送端已经关闭，之后将状态设置为TCP_CLOSE_WAIT（应用程序程序读取数据时发现设置该标志位会立刻返回），并进入<code>pingpong</code>模式（快速回复<code>ack</code>）。最后完成乱序队列的清理，并复位<code>sack</code>的信息。</p>
<p>上述代码可以看到，当被动关闭方收到主动关闭方发送的<code>fin</code>后设置了<code>sk</code>的状态为<code>SOCK_DONE</code>，并且设置了RCV_SHUTDOWN标志，表示发送端已经关闭，<strong>此时用户程序调用<code>recv</code>时会发现 数据包携带<code>fin</code></strong>（<strong>注意<code>fin</code>包是会放到接收队列中的</strong>）标志位会停止继续拷贝数据，如果拷贝的长度为0，或者下一次调用会发现设置了<code>shutdown</code>标志位，<strong>都会返回用户0</strong>，通知用户对端已经关闭，具体代码在前文<code>tcp_recvmsg</code>中分析过，这里不在重复，对应处理逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_recvmsg_locked</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> flags, <span class="keyword">struct</span> scm_timestamping_internal *tss,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> *cmsg_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//不断从 sk_receive_queue 找到当前 seq 对应的 skb，拷贝数据</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Next get a buffer. */</span></span><br><span class="line">		<span class="comment">//获取当前队列尾部的skb</span></span><br><span class="line">		last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">		skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) &#123;</span><br><span class="line">		...</span><br><span class="line">			<span class="comment">//数据包中存在fin标志</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">				<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Well, if we have backlog, try to process it now yet. */</span></span><br><span class="line">		<span class="comment">//如果没找到skb 同时没有读够数据，且backlog为空，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (copied &gt;= target &amp;&amp; !READ_ONCE(sk-&gt;sk_backlog.tail))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//已经读了一些数据</span></span><br><span class="line">		<span class="keyword">if</span> (copied) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!timeo ||							<span class="comment">//非阻塞</span></span><br><span class="line">			    sk-&gt;sk_err ||						<span class="comment">//存在错误</span></span><br><span class="line">			    sk-&gt;sk_state == TCP_CLOSE ||		<span class="comment">//已经close</span></span><br><span class="line">			    (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) ||	<span class="comment">//被动关闭</span></span><br><span class="line">			    signal_pending(current))			<span class="comment">//ctrl c？？</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (sock_flag(sk, SOCK_DONE))		<span class="comment">//比如说主动关闭 或被动收到fin</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_err) &#123;						<span class="comment">//比如说收到rst，icmp</span></span><br><span class="line">				copied = sock_error(sk);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)		 <span class="comment">//被动关闭</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">found_fin_ok:</span><br><span class="line">		<span class="comment">/* Process the FIN. */</span></span><br><span class="line">		<span class="comment">//处理fin包</span></span><br><span class="line">		WRITE_ONCE(*seq, *seq + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">			tcp_eat_recv_skb(sk, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	tcp_cleanup_rbuf(sk, copied);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码为被动关闭方收到<code>fin</code>包的处理逻辑，<strong>用户会通过<code>recv</code>返回0来感知对端已经关闭连接</strong>，此时仍是半关闭状态，此时用户程序通常会发完需要待发送的数之后调用<code>close</code>(如果应用程序不调用<code>close</code>，对端也会起一个定时器防止本端不发送<code>fin</code>包)，也就是前文分析的<code>tcp_close</code>，<strong>区别是此时调用<code>tcp_close</code>的状态时<code>TCP_CLOSE_WAIT</code>。</strong></p>
<p>**被动关闭方应用程序调用<code>close</code>后的行为与主动关闭方类似，也是判断是否由有未读数据，是否有<code>linger</code>选项，还是走正常关闭，不同的地方在于状态由CLOSE_WAIT 变成 LAST_ACK（发送FIN等待对端ack）**具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里传入的第二个参数就是solinger设置的超时时间</span></span><br><span class="line"><span class="type">void</span> __tcp_close(<span class="keyword">struct</span> sock *sk, <span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//遍历接收队列，判断是否存在未接收的数据，记录字节数</span></span><br><span class="line">	<span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			len--;</span><br><span class="line">		data_was_unread += len;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//repaire模式</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_sk(sk)-&gt;repair)) &#123;</span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//存在未读的数据，不能让对端认为数据包已经收到了（发fin表示正常接收）</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">		<span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">		<span class="comment">//直接发rst</span></span><br><span class="line">		tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line">	<span class="comment">//用户启用了so linger选项但是超时时间为0 大概率直接发rst</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line">		<span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line"></span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">	<span class="comment">//正常情况，设置为下个状态发送fin包</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">		<span class="comment">//发送fin包</span></span><br><span class="line">		tcp_send_fin(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//close状态的处理</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">		req = rcu_dereference_protected(tcp_sk(sk)-&gt;fastopen_rsk,</span><br><span class="line">						lockdep_sock_is_held(sk));</span><br><span class="line">		<span class="comment">/* We could get here with a non-NULL req if the socket is</span></span><br><span class="line"><span class="comment">		 * aborted (e.g., closed with unread data) before 3WHS</span></span><br><span class="line"><span class="comment">		 * finishes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (req)</span><br><span class="line">			reqsk_fastopen_remove(sk, req, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//最终释放资源</span></span><br><span class="line">		inet_csk_destroy_sock(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Otherwise, socket is reprieved until protocol close. */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	bh_unlock_sock(sk);</span><br><span class="line">	local_bh_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当被动关闭方发送<code>fin</code>包之后进入到了LAST_ACK状态，此时需要等待主动关闭方发送最后一个<code>ack</code>，当收到最后一个<code>ack</code>后会<code>tcp_rcv_state_process</code>交由对应的LAST_ACK状态进行处理，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-tcp_close（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-22 22:00:00 / 修改时间：21:48:51" itemprop="dateCreated datePublished" datetime="2026-01-22T22:00:00+08:00">2026-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>**<code>inet_child_forget</code>首先调用TCP注册的<code>disconnect</code>释放资源（关闭定时器，清理重传队列等,重置字段），并大概率会发送一个<code>rst</code>**终止连接，具体代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_disconnect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="type">int</span> old_state = sk-&gt;sk_state;</span><br><span class="line">	u32 seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_state != TCP_CLOSE)</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ABORT function of RFC793 */</span></span><br><span class="line">	<span class="comment">//listen状态的处理</span></span><br><span class="line">	<span class="keyword">if</span> (old_ state == TCP_LISTEN) &#123;</span><br><span class="line">		inet_csk_listen_stop(sk);</span><br><span class="line">	<span class="comment">//repair</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNABORTED);</span><br><span class="line">	<span class="comment">//建链或者断开连接或者syn——recv 会发rst，也就是说大概率发rst</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_need_reset(old_state) ||</span><br><span class="line">		   (tp-&gt;snd_nxt != tp-&gt;write_seq &amp;&amp;</span><br><span class="line">		    (<span class="number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSING | TCPF_LAST_ACK))) &#123;</span><br><span class="line">		<span class="comment">/* The last check adjusts for discrepancy of Linux wrt. RFC</span></span><br><span class="line"><span class="comment">		 * states</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_send_active_reset(sk, gfp_any());</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNRESET);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_state == TCP_SYN_SENT)</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNRESET);</span><br><span class="line">	<span class="comment">//停掉所有的定时器</span></span><br><span class="line">	tcp_clear_xmit_timers(sk);</span><br><span class="line">	<span class="comment">//清掉接收队列</span></span><br><span class="line">	__skb_queue_purge(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">	WRITE_ONCE(tp-&gt;copied_seq, tp-&gt;rcv_nxt);</span><br><span class="line">	WRITE_ONCE(tp-&gt;urg_data, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//清发送队列</span></span><br><span class="line">	tcp_write_queue_purge(sk);</span><br><span class="line">	tcp_fastopen_active_disable_ofo_check(sk);</span><br><span class="line">	<span class="comment">//清重传队列</span></span><br><span class="line">	skb_rbtree_purge(&amp;tp-&gt;out_of_order_queue);</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//对用户调用bind的情况，移除bhash2后复位ip地址并重新加入</span></span><br><span class="line">	inet_bhash2_reset_saddr(sk);</span><br><span class="line">	<span class="comment">//清除shutdown</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_shutdown, <span class="number">0</span>);</span><br><span class="line">	sock_reset_flag(sk, SOCK_DONE);</span><br><span class="line">	<span class="comment">//rtt相关</span></span><br><span class="line">	tp-&gt;srtt_us = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);</span><br><span class="line">	tp-&gt;rcv_rtt_last_tsecr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//让新发送的序列号离当前序列号远一点</span></span><br><span class="line">	seq = tp-&gt;write_seq + tp-&gt;max_window + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (!seq)</span><br><span class="line">		seq = <span class="number">1</span>;</span><br><span class="line">	WRITE_ONCE(tp-&gt;write_seq, seq);</span><br><span class="line">	<span class="comment">//rto  延迟ack</span></span><br><span class="line">	icsk-&gt;icsk_backoff = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_probes_out = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_probes_tstamp = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;</span><br><span class="line">	icsk-&gt;icsk_rto_min = TCP_RTO_MIN;</span><br><span class="line">	icsk-&gt;icsk_delack_max = TCP_DELACK_MAX;</span><br><span class="line">	<span class="comment">//拥塞</span></span><br><span class="line">	tp-&gt;snd_ssthresh = TCP_INFINITE_SSTHRESH;</span><br><span class="line">	tcp_snd_cwnd_set(tp, TCP_INIT_CWND);</span><br><span class="line">	tp-&gt;snd_cwnd_cnt = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;is_cwnd_limited = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;max_packets_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;window_clamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;delivered = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;delivered_ce = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (icsk-&gt;icsk_ca_ops-&gt;release)</span><br><span class="line">		icsk-&gt;icsk_ca_ops-&gt;release(sk);</span><br><span class="line">	<span class="built_in">memset</span>(icsk-&gt;icsk_ca_priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(icsk-&gt;icsk_ca_priv));</span><br><span class="line">	icsk-&gt;icsk_ca_initialized = <span class="number">0</span>;</span><br><span class="line">	tcp_set_ca_state(sk, TCP_CA_Open);</span><br><span class="line">	tp-&gt;is_sack_reneg = <span class="number">0</span>;</span><br><span class="line">	tcp_clear_retrans(tp);</span><br><span class="line">	tp-&gt;total_retrans = <span class="number">0</span>;</span><br><span class="line">	inet_csk_delack_init(sk);</span><br><span class="line">	<span class="comment">/* Initialize rcv_mss to TCP_MIN_MSS to avoid division by 0</span></span><br><span class="line"><span class="comment">	 * issue in __tcp_select_window()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	icsk-&gt;icsk_ack.rcv_mss = TCP_MIN_MSS;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;tp-&gt;rx_opt, <span class="number">0</span>, <span class="keyword">sizeof</span>(tp-&gt;rx_opt));</span><br><span class="line">	<span class="comment">//清除路由</span></span><br><span class="line">	__sk_dst_reset(sk);</span><br><span class="line">	dst_release(xchg((__force <span class="keyword">struct</span> dst_entry **)&amp;sk-&gt;sk_rx_dst, <span class="literal">NULL</span>));</span><br><span class="line">	tcp_saved_syn_free(tp);</span><br><span class="line">	<span class="comment">//清除统计计数</span></span><br><span class="line">	tp-&gt;compressed_ack = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;segs_in = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;segs_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_sent = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_acked = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_received = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_retrans = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;data_segs_in = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;data_segs_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;duplicate_sack[<span class="number">0</span>].start_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;duplicate_sack[<span class="number">0</span>].end_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;dsack_dups = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;reord_seen = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;retrans_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;sacked_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;last_oow_ack_time = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;plb_rehash = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* There&#x27;s a bubble in the pipe until at least the first ACK. */</span></span><br><span class="line">	tp-&gt;app_limited = ~<span class="number">0U</span>;</span><br><span class="line">	tp-&gt;rate_app_limited = <span class="number">1</span>;</span><br><span class="line">	tp-&gt;rack.mstamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.advanced = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.reo_wnd_steps = <span class="number">1</span>;</span><br><span class="line">	tp-&gt;rack.last_delivered = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.reo_wnd_persist = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;syn_data_acked = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.dsack = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.num_sacks = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rcv_ooopack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up fastopen related fields */</span></span><br><span class="line">	tcp_free_fastopen_req(tp);</span><br><span class="line">	inet_clear_bit(DEFER_CONNECT, sk);</span><br><span class="line">	tp-&gt;fastopen_client_fail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON(inet-&gt;inet_num &amp;&amp; !icsk-&gt;icsk_bind_hash);</span><br><span class="line">	<span class="comment">//释放管理的页</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_frag.page) &#123;</span><br><span class="line">		put_page(sk-&gt;sk_frag.page);</span><br><span class="line">		sk-&gt;sk_frag.page = <span class="literal">NULL</span>;</span><br><span class="line">		sk-&gt;sk_frag.offset = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上送错误</span></span><br><span class="line">	sk_error_report(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_disconnect</code>核心思想就是根据当前<code>sk</code>状态决定是否发送<code>rst</code>（例如<code>ESTABLISHED</code>，<code>SYN_RECV</code>四次挥手中间状态等 ）然后无论是否发包，都清理与旧连接相关的定时器，清理接收&#x2F;发送&#x2F;乱序队列，清除远端端口并重置 bhash2 中的源地址关联，重置 shutdown 标志，接着重新设置序列号避旧包污染，恢复 RTO&#x2F;RTT&#x2F;延迟 ACK 和拥塞控制到初始值，清空 SACK&#x2F;RACK&#x2F;重传与各种统计计数，释放路由缓存，最后释放临时页并向用户上报错误。</p>
<p>回到<code>tcp_close</code>中，如果处理的不是<code>listen</code>状态的套接字（大概率都不是），则遍历接收队列记录未读取的字节数并释放数据包（后续会决定是否发送<code>rst</code>），之后判断套接字是否已经被关闭了，比如收到了或者发送了<code>rst</code>？之后判断是否存在未被读取的数据，如果有则不会走正常的四次挥手，而是发送<code>rst</code>，<strong>如果用户设置了linger选项同时<code>linger=0</code>则调用disconnect，表示不走四次挥手，而是直接发送RST终止连接</strong>。</p>
<p>如果不满足上述条件，则走正常挥手发送<code>fin</code>包的流程，首先调用<code>tcp_close_state</code>将状态切换为FIN_WAIT1，之后调用<code>tcp_send_fin</code>发送FIN包，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">tcp_send_fin</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tskb</span>, *<span class="title">tail</span> =</span> tcp_write_queue_tail(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optimization, tack on the FIN if we have one skb in write queue and</span></span><br><span class="line"><span class="comment">	 * this skb was not yet sent, or we are under memory pressure.</span></span><br><span class="line"><span class="comment">	 * Note: in the latter case, FIN packet will be sent after a timeout,</span></span><br><span class="line"><span class="comment">	 * as TCP stack thinks it has already been transmitted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//首先从发送队列尾部尝试获取，如果没有且在内存压力之下则直接</span></span><br><span class="line">	<span class="comment">//从重传队列中获取skb</span></span><br><span class="line">	tskb = tail;</span><br><span class="line">	<span class="keyword">if</span> (!tskb &amp;&amp; tcp_under_memory_pressure(sk))</span><br><span class="line">		tskb = skb_rb_last(&amp;sk-&gt;tcp_rtx_queue);</span><br><span class="line">	<span class="comment">//拿到了一个skb则加上fin标志 同时增加一个序列号</span></span><br><span class="line">	<span class="keyword">if</span> (tskb) &#123;</span><br><span class="line">		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span><br><span class="line">		TCP_SKB_CB(tskb)-&gt;end_seq++;</span><br><span class="line">		tp-&gt;write_seq++;</span><br><span class="line">		<span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">			<span class="comment">/* This means tskb was already sent.</span></span><br><span class="line"><span class="comment">			 * Pretend we included the FIN on previous transmit.</span></span><br><span class="line"><span class="comment">			 * We need to set tp-&gt;snd_nxt to the value it would have</span></span><br><span class="line"><span class="comment">			 * if FIN had been sent. This is because retransmit path</span></span><br><span class="line"><span class="comment">			 * does not change tp-&gt;snd_nxt.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			WRITE_ONCE(tp-&gt;snd_nxt, tp-&gt;snd_nxt + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//没有获取到可以用的skb则申请一个skb</span></span><br><span class="line">		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		INIT_LIST_HEAD(&amp;skb-&gt;tcp_tsorted_anchor);</span><br><span class="line">		<span class="comment">//resever一下</span></span><br><span class="line">		skb_reserve(skb, MAX_TCP_HEADER);</span><br><span class="line">		sk_forced_mem_schedule(sk, skb-&gt;truesize);</span><br><span class="line">		<span class="comment">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span></span><br><span class="line">		<span class="comment">//初始化数据</span></span><br><span class="line">		tcp_init_nondata_skb(skb, tp-&gt;write_seq,</span><br><span class="line">				     TCPHDR_ACK | TCPHDR_FIN);</span><br><span class="line">		<span class="comment">//数据包入队列</span></span><br><span class="line">		tcp_queue_skb(sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//发送</span></span><br><span class="line">	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>tcp_send_fin</code>主要逻辑就是在关闭连接时发送 FIN（<strong>占用 1 个序列号字节</strong>）。首先尽量把 FIN 挂在现有的最后一个发送 <code>skb</code> 上，如果没有则会申请并构造一个带 FIN 标志的 <code>skb</code>，并发送出去。</p>
<p>回到<code>tcp_close</code>中<strong>发送完<code>fin</code>包之后会调用<code>sk_stream_wait_close</code>睡眠（如果用户设置了需要等待的话），睡眠最大的意义应该是希望发送队列中的数据被发送完？？？</strong> 之后调用<code>sock_orphan</code>将套接字设置为<code>SOCK_DEAD</code>（收包逻辑中会针对这个状态处理）<strong>此时套接字与进程上下文就脱离关系了</strong>。</p>
<p>接下来处理后备队列中的数据包（重走收报逻辑，后面会释放资源），同时增加孤儿套接字统计计数，之后进一步判断当前套接字是否处于关闭状态了，由于在软中断上下文中可能已经关闭了套接字(<strong>感觉这种概率并不大，但是如果上面睡眠了的话是有可能的</strong>)。</p>
<p><strong>之后判断是否处于FIN_WAIT2状态，当发送的<code>fin</code>被对端确认后会进入该状态</strong>，（该状态<strong>下如果对端一直不发送<code>fin</code>包则本端会一直停留在该状态</strong>，为避免这种情况发送，所以在收到<code>ack</code>后会起一个定时器，或者直接回<code>rst</code>），如果用户设置了<code>linger2</code>的时间的话可能会直接发送一个<code>rst</code>，或者可能会创建一个<code>tw</code>状态的套接字，同时把原来的<code>sk</code>从<code>ehash</code>中移除，并启动一个定时器<strong>注意这里不是启动<code>tw</code>定时器，应该叫FIN_WAIT2定时器</strong>（<strong>复用了保活的定时器</strong>），因为<strong>如果收包路径中收到了对端的<code>fin</code>则会找到该<code>tw</code>套接字并判断<code>substate</code>之后启动真正的<code>tw</code> 定时器。</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangm</p>
  <div class="site-description" itemprop="description">协议栈源码学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '1c6PW2umhmoCGypfQhPNnfLk-gzGzoHsz',
      appKey     : 'nbVvMAfQXEdOeKD1tmvI3qrQ',
      placeholder: "畅所欲言!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://1c6pw2um.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
