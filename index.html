<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="协议栈源码学习">
<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="协议栈源码学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhangm">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日拱一卒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/17/TCP%20sack%E5%A4%84%E7%90%86tcp_sacktag_write_queue%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/17/TCP%20sack%E5%A4%84%E7%90%86tcp_sacktag_write_queue%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">TCP确认 tcp_sacktag_write_queue（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-17 22:00:00 / 修改时间：22:35:22" itemprop="dateCreated datePublished" datetime="2025-12-17T22:00:00+08:00">2025-12-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/17/TCP%20sack%E5%A4%84%E7%90%86tcp_sacktag_write_queue%EF%BC%882%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/17/TCP%20sack%E5%A4%84%E7%90%86tcp_sacktag_write_queue%EF%BC%882%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在<a href="/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/" title="TCP确认 tcp_sacktag_write_queue（一）">TCP确认 tcp_sacktag_write_queue（一）</a>中处理完判断是否为<code>dsack</code>块并丢弃无用的<code>sack</code>块后，接下来会把合法的<code>sack block</code>按<code>startseq</code>排序，为后续扫描发送队列提供优化。</p>
<p>接下来进入<code>tcp_sacktag_write_queue</code>中的主循环，循环会遍历每个有效的<code>sack block</code>，首先尝试让 cache 指针指向相关的 cache block，如果 <code>cache</code> 可用且是普通 sack（不是<code>dup</code>）则进入关键的处理流程。</p>
<p>首先判断当前当前确认的段是否在cache管理的前面（表示说明当前 <code>SACK</code> <code>block</code> 的左边一段是新的），如果条件满足则调用<code>tcp_sacktag_skip</code>二分找到发送队列中第一个 待处理的skb，<strong>调用<code>tcp_sacktag_walk</code>对 [start_seq, cache-&gt;start_seq) 这段序列范围的数据进行标记</strong>，<code>tcp_sacktag_walk</code>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从给定的 skb 开始，沿着 TCP 发送队列（有序 rb-tree）遍历序列号在 [start_seq, end_seq) 的所有 skb</span></span><br><span class="line"><span class="comment">//这个函数本质上才是sack的核心逻辑</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sk_buff *<span class="title function_">tcp_sacktag_walk</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> tcp_sack_block *next_dup,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> tcp_sacktag_state *state,</span></span><br><span class="line"><span class="params">					u32 start_seq, u32 end_seq,</span></span><br><span class="line"><span class="params">					<span class="type">bool</span> dup_sack_in)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="comment">//遍历重传队列</span></span><br><span class="line">	skb_rbtree_walk_from(skb) &#123;</span><br><span class="line">		<span class="type">int</span> in_sack = <span class="number">0</span>; 			 <span class="comment">//标识skb是否被某个sack覆盖</span></span><br><span class="line">		<span class="type">bool</span> dup_sack = dup_sack_in; <span class="comment">//这个块是否dsack语义</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* queue is in-order =&gt; we can short-circuit the walk early */</span></span><br><span class="line">		<span class="comment">//这里开始后面的 skb 都不在 [start_seq, end_seq) 内  可以直接break</span></span><br><span class="line">		<span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq, end_seq))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//第一个条件是 考虑dsack的情况（两块组合编码） &amp;&amp; 当前 skb 起始序列号 &lt; DSACK块末尾序号 注意这里传入的的start和end是可能是dup的</span></span><br><span class="line">		<span class="keyword">if</span> (next_dup  &amp;&amp;</span><br><span class="line">		    before(TCP_SKB_CB(skb)-&gt;seq, next_dup-&gt;end_seq)) &#123; </span><br><span class="line">			<span class="comment">//判断当前 skb 是否被 DSACK block 完整或部分覆盖,这里注意，里面会拆分数据包，如果dsack start在skb序号的右侧这里返回的是0</span></span><br><span class="line">			in_sack = tcp_match_skb_to_sack(sk, skb,</span><br><span class="line">							next_dup-&gt;start_seq,</span><br><span class="line">							next_dup-&gt;end_seq);</span><br><span class="line">			<span class="keyword">if</span> (in_sack &gt; <span class="number">0</span>)</span><br><span class="line">				dup_sack = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* skb reference here is a bit tricky to get right, since</span></span><br><span class="line"><span class="comment">		 * shifting can eat and free both this skb and the next,</span></span><br><span class="line"><span class="comment">		 * so not even _safe variant of the loop is enough.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//不是dsack 或者上面dsack start在skb序号的右侧？</span></span><br><span class="line">		<span class="keyword">if</span> (in_sack &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//优化队列结构，本质思想是合成一个大块，返回空表示无法合并</span></span><br><span class="line">			tmp = tcp_shift_skb_data(sk, skb, state,</span><br><span class="line">						 start_seq, end_seq, dup_sack);</span><br><span class="line">			<span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp != skb) &#123;</span><br><span class="line">					skb = tmp;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				in_sack = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//上面没有合并成功的情况，这里面是拆分数据包，如果这里返回0 表示没有命中sack这也是有可能的因为</span></span><br><span class="line">				in_sack = tcp_match_skb_to_sack(sk, skb,</span><br><span class="line">								start_seq,</span><br><span class="line">								end_seq);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(in_sack &lt; <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//真正的标记数据包，肯定是in_sack才能标记，注意这里接收了返回值</span></span><br><span class="line">		<span class="keyword">if</span> (in_sack) &#123;</span><br><span class="line">			TCP_SKB_CB(skb)-&gt;sacked =</span><br><span class="line">				tcp_sacktag_one(sk,</span><br><span class="line">						state,</span><br><span class="line">						TCP_SKB_CB(skb)-&gt;sacked,</span><br><span class="line">						TCP_SKB_CB(skb)-&gt;seq,</span><br><span class="line">						TCP_SKB_CB(skb)-&gt;end_seq,</span><br><span class="line">						dup_sack,</span><br><span class="line">						tcp_skb_pcount(skb),</span><br><span class="line">						tcp_skb_timestamp_us(skb));</span><br><span class="line">			<span class="comment">//更新拥塞算法用到的字段</span></span><br><span class="line">			tcp_rate_skb_delivered(sk, skb, state-&gt;rate);</span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;sacked &amp; TCPCB_SACKED_ACKED)</span><br><span class="line">				list_del_init(&amp;skb-&gt;tcp_tsorted_anchor);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq,</span><br><span class="line">				    tcp_highest_sack_seq(tp)))</span><br><span class="line">				<span class="comment">//如果需要，更新最高的sack对应的数据包</span></span><br><span class="line">				tcp_advance_highest_sack(sk, skb);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这个数据包貌似已经是不再 sack范围的数据包了</span></span><br><span class="line">	<span class="keyword">return</span> skb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>tcp_sacktag_walk</code>的核心逻辑为把落在某个<code>sack</code>区间的<code>skb</code>找出来并作标记，它做的事不仅简单的判断在不在区间，会为了精确标记而 可能拆分 skb、可能合并 skb，具体逻辑如下</strong>：</p>
<p><code>tcp_sacktag_walk</code>中首先遍历重传队列，当数据包的<code>seq</code>已经超出了<code>sack</code>的右边界那就直接<code>break</code>，否则优先处理<code>dsack</code>双编码的场景，（这里注意如果使用的是<code>cache</code>这里就一定不会走吧），如果<code>next_dup</code> 非空且 当前 skb 起始序列号 &lt; <code>dsack</code>块末尾序号，则调用<code>tcp_match_skb_to_sack</code>可能拆分数据包，拆分数据包的目的是方便整整齐齐的标记：-）tcp_match_skb_to_sack具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带 GSO：如果不刚好对齐 尝试 tcp_fragment</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_match_skb_to_sack</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">				  u32 start_seq, u32 end_seq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">bool</span> in_sack;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pkt_len;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mss;</span><br><span class="line">	<span class="comment">//skb 完全被 SACK 覆盖</span></span><br><span class="line">	in_sack = !after(start_seq, TCP_SKB_CB(skb)-&gt;seq) &amp;&amp;</span><br><span class="line">		  !before(end_seq, TCP_SKB_CB(skb)-&gt;end_seq);</span><br><span class="line">	<span class="comment">// GSO &amp;&amp; 部分的情况</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_skb_pcount(skb) &gt; <span class="number">1</span> &amp;&amp; !in_sack &amp;&amp;</span><br><span class="line">	<span class="comment">////部分重叠 数据包的结束序列号小于块的起始序列号</span></span><br><span class="line">	    after(TCP_SKB_CB(skb)-&gt;end_seq, start_seq)) &#123; </span><br><span class="line">		mss = tcp_skb_mss(skb);</span><br><span class="line">		in_sack = !after(start_seq, TCP_SKB_CB(skb)-&gt;seq); </span><br><span class="line">		<span class="comment">//SACK start在 skb 里面</span></span><br><span class="line">		<span class="keyword">if</span> (!in_sack) &#123;</span><br><span class="line">			pkt_len = start_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">			<span class="keyword">if</span> (pkt_len &lt; mss)</span><br><span class="line">				pkt_len = mss;<span class="comment">//对齐mss</span></span><br><span class="line">		<span class="comment">//SACK start &lt;= skb 起点</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pkt_len = end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">			<span class="keyword">if</span> (pkt_len &lt; mss)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Round if necessary so that SACKs cover only full MSSes</span></span><br><span class="line"><span class="comment">		 * and/or the remaining small portion (if present)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (pkt_len &gt; mss) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> new_len = (pkt_len / mss) * mss;</span><br><span class="line">			<span class="keyword">if</span> (!in_sack &amp;&amp; new_len &lt; pkt_len)</span><br><span class="line">				new_len += mss;</span><br><span class="line">			pkt_len = new_len; <span class="comment">//对齐成 N * MSS</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pkt_len &gt;= skb-&gt;len &amp;&amp; !in_sack)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//切分数据包，这里很关键这次返回0 下次应该就不会了</span></span><br><span class="line">		err = tcp_fragment(sk, TCP_FRAG_IN_RTX_QUEUE, skb,</span><br><span class="line">				   pkt_len, mss, GFP_ATOMIC);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in_sack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_match_skb_to_sack</code>首秀判断当前<code>sack</code>的返回是否覆盖了这个<code>skb</code>如果满足条件则直接返回了，否则只有在是GSO报文的情况下同时可能存在重叠则会进一步处理，首先计算<code>mss</code>然后判断<code>sack</code>从<code>skb</code>的左侧开始还是<code>sack</code>的起点在<code>skb</code>的内部，并进行mss对齐处理，之后调用<code>tcp_fragment</code>切分数据包，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">tcp_fragment</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">enum</span> tcp_queue tcp_queue,</span></span><br><span class="line"><span class="params">		 <span class="keyword">struct</span> sk_buff *skb, u32 len,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">	<span class="type">int</span> old_factor;</span><br><span class="line">	<span class="type">long</span> limit;</span><br><span class="line">	<span class="type">int</span> nlen;</span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(len &gt; skb-&gt;len))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	DEBUG_NET_WARN_ON_ONCE(skb_headlen(skb));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tcp_sendmsg() can overshoot sk_wmem_queued by one full size skb.</span></span><br><span class="line"><span class="comment">	 * We need some allowance to not penalize applications setting small</span></span><br><span class="line"><span class="comment">	 * SO_SNDBUF values.</span></span><br><span class="line"><span class="comment">	 * Also allow first and last skb in retransmit queue to be split.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//发送缓冲区是否够大，是否超出了内存限制</span></span><br><span class="line">	limit = sk-&gt;sk_sndbuf + <span class="number">2</span> * SKB_TRUESIZE(GSO_LEGACY_MAX_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (unlikely((sk-&gt;sk_wmem_queued &gt;&gt; <span class="number">1</span>) &gt; limit &amp;&amp;</span><br><span class="line">		     tcp_queue != TCP_FRAG_IN_WRITE_QUEUE &amp;&amp;</span><br><span class="line">		     skb != tcp_rtx_queue_head(sk) &amp;&amp;</span><br><span class="line">		     skb != tcp_rtx_queue_tail(sk))) &#123;</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb_unclone_keeptruesize(skb, gfp))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get a new skb... force flag on. */</span></span><br><span class="line">	<span class="comment">//申请一个新的skb</span></span><br><span class="line">	buff = tcp_stream_alloc_skb(sk, gfp, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (!buff)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM; <span class="comment">/* We&#x27;ll just try again later. */</span></span><br><span class="line">	skb_copy_decrypted(buff, skb);</span><br><span class="line">	mptcp_skb_ext_copy(buff, skb);</span><br><span class="line">	<span class="comment">//更新内存记账</span></span><br><span class="line">	sk_wmem_queued_add(sk, buff-&gt;truesize);</span><br><span class="line">	sk_mem_charge(sk, buff-&gt;truesize);</span><br><span class="line">	nlen = skb-&gt;len - len;</span><br><span class="line">	<span class="comment">//新的skb</span></span><br><span class="line">	buff-&gt;truesize += nlen;</span><br><span class="line">	<span class="comment">//旧skb</span></span><br><span class="line">	skb-&gt;truesize -= nlen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Correct the sequence numbers. */</span></span><br><span class="line">	<span class="comment">//更新序列号</span></span><br><span class="line">	TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq + len;</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PSH and FIN should only be set in the second packet. */</span></span><br><span class="line">	<span class="comment">//更新标志位</span></span><br><span class="line">	flags = TCP_SKB_CB(skb)-&gt;tcp_flags;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;tcp_flags = flags &amp; ~(TCPHDR_FIN | TCPHDR_PSH);</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;tcp_flags = flags;</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;sacked = TCP_SKB_CB(skb)-&gt;sacked;</span><br><span class="line">	tcp_skb_fragment_eor(skb, buff);</span><br><span class="line">	<span class="comment">//真正的数据分割</span></span><br><span class="line">	skb_split(skb, buff, len);</span><br><span class="line"></span><br><span class="line">	skb_set_delivery_time(buff, skb-&gt;tstamp, <span class="literal">true</span>);</span><br><span class="line">	tcp_fragment_tstamp(skb, buff);</span><br><span class="line">	<span class="comment">//原本数据包的段数</span></span><br><span class="line">	old_factor = tcp_skb_pcount(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fix up tso_factor for both original and new SKB.  */</span></span><br><span class="line">	<span class="comment">//调整GSO字段</span></span><br><span class="line">	tcp_set_skb_tso_segs(skb, mss_now);</span><br><span class="line">	tcp_set_skb_tso_segs(buff, mss_now);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update delivered info for the new segment */</span></span><br><span class="line">	TCP_SKB_CB(buff)-&gt;tx = TCP_SKB_CB(skb)-&gt;tx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this packet has been sent out already, we must</span></span><br><span class="line"><span class="comment">	 * adjust the various packet counters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//判断数据包是否已经发送过</span></span><br><span class="line">	<span class="keyword">if</span> (!before(tp-&gt;snd_nxt, TCP_SKB_CB(buff)-&gt;end_seq)) &#123;</span><br><span class="line">		<span class="type">int</span> diff = old_factor - tcp_skb_pcount(skb) -</span><br><span class="line">			tcp_skb_pcount(buff);</span><br><span class="line">		<span class="comment">//为什么要调整这个已发送未确认的计数呢？？</span></span><br><span class="line">		<span class="keyword">if</span> (diff)</span><br><span class="line">			tcp_adjust_pcount(sk, skb, diff);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Link BUFF into the send queue. */</span></span><br><span class="line">	__skb_header_release(buff);</span><br><span class="line">	<span class="comment">//将新SKB插入到原SKB之后</span></span><br><span class="line">	tcp_insert_write_queue_after(skb, buff, sk, tcp_queue);</span><br><span class="line">	<span class="keyword">if</span> (tcp_queue == TCP_FRAG_IN_RTX_QUEUE)</span><br><span class="line">		list_add(&amp;buff-&gt;tcp_tsorted_anchor, &amp;skb-&gt;tcp_tsorted_anchor);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_fragment</code>核心逻辑为把发送队列里的 <code>skb</code> 按 <code>len</code> 位置切成两个 <code>skb</code>原来的在前面，新的在后面，之后修正 <code>seq</code>&#x2F;<code>end_seq</code>、<code>TCP</code> 标志位、<code>GSO</code> 分段信息、内存记账等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/17/TCP%20sack%E5%A4%84%E7%90%86tcp_sacktag_write_queue%EF%BC%882%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/" class="post-title-link" itemprop="url">TCP确认 tcp_sacktag_write_queue（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-16 22:00:00" itemprop="dateCreated datePublished" datetime="2025-12-16T22:00:00+08:00">2025-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-17 22:32:12" itemprop="dateModified" datetime="2025-12-17T22:32:12+08:00">2025-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在<a href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/" title="TCP确认 tcp_ack（一）">TCP确认 tcp_ack（一）</a>的处理流程中可看到，如果数据包携带了<code>sack</code>的信息则会调用<code>tcp_sacktag_write_queue</code>进行处理，核心逻辑可以总结成一句话：<strong>把<code>ack</code>报文中携带<code>sack</code>信息关联到重传队列的<code>skb</code>上，给<code>skb</code>打上已经选择确认的标记，同时更新各种统计信息（例如乱序检测状态）</strong>，具体流程如下所示：</p>
<ul>
<li>解析sack选项并计算有多少个<code>block</code></li>
<li>判断第一个块是否为<code>dsack</code></li>
<li>处理太旧的<code>ack</code></li>
<li>遍历<code>sack block</code>，使用冒泡排序得到排序后的<code>block</code></li>
<li>如果能使用<code>sack</code>的<code>cache</code>则加速定位需要从队列哪里开始标记</li>
<li>执行真正的标记流程</li>
<li>更新<code>cache</code>为下次处理<code>sack</code>提供加速</li>
</ul>
<p>上述流程具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">tcp_sacktag_write_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *ack_skb,</span></span><br><span class="line"><span class="params">			u32 prior_snd_una, <span class="keyword">struct</span> tcp_sacktag_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//从TCP选项头中提取SACK信息</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ptr = (skb_transport_header(ack_skb) +</span><br><span class="line">				    TCP_SKB_CB(ack_skb)-&gt;sacked);</span><br><span class="line">	<span class="comment">//跳过SACK选项类型和长度字段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sack_block_wire</span> *<span class="title">sp_wire</span> =</span> (<span class="keyword">struct</span> tcp_sack_block_wire *)(ptr+<span class="number">2</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sack_block</span> <span class="title">sp</span>[<span class="title">TCP_NUM_SACKS</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sack_block</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="comment">//计算SACK块数量</span></span><br><span class="line">	<span class="type">int</span> num_sacks = min(TCP_NUM_SACKS, (ptr[<span class="number">1</span>] - TCPOLEN_SACK_BASE) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">	<span class="type">int</span> used_sacks;</span><br><span class="line">	<span class="type">bool</span> found_dup_sack = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">int</span> first_sack_index;</span><br><span class="line"></span><br><span class="line">	state-&gt;flag = <span class="number">0</span>;</span><br><span class="line">	state-&gt;reord = tp-&gt;snd_nxt; <span class="comment">//置重排序检测的基准为下一个发送序号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;sacked_out)</span><br><span class="line">		tcp_highest_sack_reset(sk);</span><br><span class="line">	<span class="comment">//检查是否有重复的SACK</span></span><br><span class="line">	found_dup_sack = tcp_check_dsack(sk, ack_skb, sp_wire,</span><br><span class="line">					 num_sacks, prior_snd_una, state);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Eliminate too old ACKs, but take into</span></span><br><span class="line"><span class="comment">	 * account more or less fresh ones, they can</span></span><br><span class="line"><span class="comment">	 * contain valid SACK info.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//丢弃太旧的ACK</span></span><br><span class="line">	<span class="keyword">if</span> (before(TCP_SKB_CB(ack_skb)-&gt;ack_seq, prior_snd_una - tp-&gt;max_window))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//数据都被确认了</span></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;packets_out)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	used_sacks = <span class="number">0</span>;</span><br><span class="line">	first_sack_index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从 ACK 中提取所有 SACK block，对每一块做合法性验证、排除无效块、排除过旧块</span></span><br><span class="line">	<span class="comment">//最后得到一个干净、有意义的 sp[] SACK 列表，用于后续真正标记发送队列</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_sacks; i++) &#123;</span><br><span class="line">		<span class="type">bool</span> dup_sack = !i &amp;&amp; found_dup_sack;   <span class="comment">//如果 i == 0 并且这次 ACK 确实检测出 DSACK，那么第 0 个块就是 DSACK 块</span></span><br><span class="line">		<span class="comment">//转换网络序到本地序</span></span><br><span class="line">		sp[used_sacks].start_seq = get_unaligned_be32(&amp;sp_wire[i].start_seq);</span><br><span class="line">		sp[used_sacks].end_seq = get_unaligned_be32(&amp;sp_wire[i].end_seq);</span><br><span class="line">		<span class="comment">//合法性检查，不合法进入这个分支，表示不值得处理</span></span><br><span class="line">		<span class="keyword">if</span> (!tcp_is_sackblock_valid(tp, dup_sack,</span><br><span class="line">					    sp[used_sacks].start_seq,</span><br><span class="line">					    sp[used_sacks].end_seq)) &#123;</span><br><span class="line">			<span class="type">int</span> mib_idx;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dup_sack) &#123; <span class="comment">//DSACK 块</span></span><br><span class="line">				<span class="keyword">if</span> (!tp-&gt;undo_marker)  <span class="comment">//D-SACK 太乱太旧</span></span><br><span class="line">					mib_idx = LINUX_MIB_TCPDSACKIGNOREDNOUNDO;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					mib_idx = LINUX_MIB_TCPDSACKIGNOREDOLD; <span class="comment">//不在关心的 undo 区间</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//普通sack块</span></span><br><span class="line">				<span class="comment">/* Don&#x27;t count olds caused by ACK reordering */</span></span><br><span class="line">				<span class="keyword">if</span> ((TCP_SKB_CB(ack_skb)-&gt;ack_seq != tp-&gt;snd_una) &amp;&amp;</span><br><span class="line">				    !after(sp[used_sacks].end_seq, tp-&gt;snd_una))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				mib_idx = LINUX_MIB_TCPSACKDISCARD;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			NET_INC_STATS(sock_net(sk), mib_idx);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">				first_sack_index = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Ignore very old stuff early */</span></span><br><span class="line">		<span class="keyword">if</span> (!after(sp[used_sacks].end_seq, prior_snd_una)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">				first_sack_index = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		used_sacks++; <span class="comment">//tcp_is_sackblock_valid 判定为合法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* order SACK blocks to allow in order walk of the retrans queue */</span></span><br><span class="line">	<span class="comment">//把合法的sack块 按序号从小排序</span></span><br><span class="line">	<span class="keyword">for</span> (i = used_sacks - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (after(sp[j].start_seq, sp[j + <span class="number">1</span>].start_seq)) &#123;</span><br><span class="line">				swap(sp[j], sp[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Track where the first SACK block goes to */</span></span><br><span class="line">				<span class="keyword">if</span> (j == first_sack_index) <span class="comment">//first_sack_index 排序后它可能不再是第 0 个了</span></span><br><span class="line">					first_sack_index = j + <span class="number">1</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state-&gt;mss_now = tcp_current_mss(sk);</span><br><span class="line">	skb = <span class="literal">NULL</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当前发送队列sack 标记的个数</span></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;sacked_out) &#123;</span><br><span class="line">		<span class="comment">/* It&#x27;s already past, so skip checking against it */</span></span><br><span class="line">		cache = tp-&gt;recv_sack_cache + ARRAY_SIZE(tp-&gt;recv_sack_cache); <span class="comment">//指向数组末尾之后的位置，表示禁用cache</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//那证明上一次SACK处理中 打过一些标签 并且这些数据还没完全ack 那就找到这个cache</span></span><br><span class="line">		cache = tp-&gt;recv_sack_cache;</span><br><span class="line">		<span class="comment">/* Skip empty blocks in at head of the cache */</span></span><br><span class="line">		<span class="keyword">while</span> (tcp_sack_cache_ok(tp, cache) &amp;&amp; !cache-&gt;start_seq &amp;&amp;</span><br><span class="line">		       !cache-&gt;end_seq)</span><br><span class="line">			cache++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; used_sacks) &#123;</span><br><span class="line">		u32 start_seq = sp[i].start_seq;</span><br><span class="line">		u32 end_seq = sp[i].end_seq;</span><br><span class="line">		<span class="type">bool</span> dup_sack = (found_dup_sack &amp;&amp; (i == first_sack_index));</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sack_block</span> *<span class="title">next_dup</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (found_dup_sack &amp;&amp; ((i + <span class="number">1</span>) == first_sack_index)) <span class="comment">//DSACK 有两种编码方式，单块模式和双块模式 双块模式就是 SACK block#1: [1000,1200)  SACK block#2: [1000,1500)    </span></span><br><span class="line">			next_dup = &amp;sp[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip too early cached blocks */</span></span><br><span class="line">		<span class="comment">//如果本次收到的 SACK block 落在以前缓存的区间之后，那么把 cache 向前推进</span></span><br><span class="line">		<span class="keyword">while</span> (tcp_sack_cache_ok(tp, cache) &amp;&amp;</span><br><span class="line">		       !before(start_seq, cache-&gt;end_seq))</span><br><span class="line">			cache++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Can skip some work by looking recv_sack_cache? */</span></span><br><span class="line">		<span class="comment">//有cache可以用！！！！，不是dsack块，右边界在cache start的右边(有重叠)</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_sack_cache_ok(tp, cache) &amp;&amp; !dup_sack &amp;&amp;</span><br><span class="line">		    after(end_seq, cache-&gt;start_seq)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Head todo? */</span></span><br><span class="line">			<span class="comment">//头部没有被缓存覆盖</span></span><br><span class="line">			<span class="keyword">if</span> (before(start_seq, cache-&gt;start_seq)) &#123;</span><br><span class="line">				<span class="comment">//二分找到发送队列中第一个 skb，用于作为后续 sacktag_walk 扫描的起点</span></span><br><span class="line">				skb = tcp_sacktag_skip(skb, sk, start_seq); </span><br><span class="line">				<span class="comment">//对 [start_seq, cache-&gt;start_seq) 这段序列范围的数据进行 SACK 标记处理？</span></span><br><span class="line">				skb = tcp_sacktag_walk(skb, sk, next_dup,</span><br><span class="line">						       state,</span><br><span class="line">						       start_seq,</span><br><span class="line">						       cache-&gt;start_seq,</span><br><span class="line">						       dup_sack);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Rest of the block already fully processed? */</span></span><br><span class="line">			<span class="comment">//尾部在缓存内的情况，表示已经可以cover住了，这里直接goto出去</span></span><br><span class="line">			<span class="keyword">if</span> (!after(end_seq, cache-&gt;end_seq))</span><br><span class="line">				<span class="keyword">goto</span> advance_sp;</span><br><span class="line"></span><br><span class="line">			skb = tcp_maybe_skipping_dsack(skb, sk, next_dup,</span><br><span class="line">						       state,</span><br><span class="line">						       cache-&gt;end_seq);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* ...tail remains todo... */</span></span><br><span class="line">			<span class="comment">//尾部超出了缓存</span></span><br><span class="line">			<span class="keyword">if</span> (tcp_highest_sack_seq(tp) == cache-&gt;end_seq) &#123;</span><br><span class="line">				<span class="comment">/* ...but better entrypoint exists! */</span></span><br><span class="line">				skb = tcp_highest_sack(sk);</span><br><span class="line">				<span class="keyword">if</span> (!skb)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				cache++;</span><br><span class="line">				<span class="keyword">goto</span> walk;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//二分查找下一个skb</span></span><br><span class="line">			skb = tcp_sacktag_skip(skb, sk, cache-&gt;end_seq);</span><br><span class="line">			<span class="comment">/* Check overlap against next cached too (past this one already) */</span></span><br><span class="line">			cache++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cache不可用的情况 找到一个skb 这个skb是下面二分查找的起点</span></span><br><span class="line">		<span class="keyword">if</span> (!before(start_seq, tcp_highest_sack_seq(tp))) &#123;</span><br><span class="line">			skb = tcp_highest_sack(sk);</span><br><span class="line">			<span class="keyword">if</span> (!skb)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//二分查找找到skb</span></span><br><span class="line">		skb = tcp_sacktag_skip(skb, sk, start_seq);</span><br><span class="line"></span><br><span class="line">walk:</span><br><span class="line">		skb = tcp_sacktag_walk(skb, sk, next_dup, state,</span><br><span class="line">				       start_seq, end_seq, dup_sack);</span><br><span class="line"></span><br><span class="line">advance_sp:</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clear the head of the cache sack blocks so we can skip it next time */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(tp-&gt;recv_sack_cache) - used_sacks; i++) &#123;</span><br><span class="line">		tp-&gt;recv_sack_cache[i].start_seq = <span class="number">0</span>;</span><br><span class="line">		tp-&gt;recv_sack_cache[i].end_seq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; used_sacks; j++)</span><br><span class="line">		tp-&gt;recv_sack_cache[i++] = sp[j];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Loss || tp-&gt;undo_marker)</span><br><span class="line">		tcp_check_sack_reordering(sk, state-&gt;reord, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	tcp_verify_left_out(tp);</span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FASTRETRANS_DEBUG &gt; 0</span></span><br><span class="line">	WARN_ON((<span class="type">int</span>)tp-&gt;sacked_out &lt; <span class="number">0</span>);</span><br><span class="line">	WARN_ON((<span class="type">int</span>)tp-&gt;lost_out &lt; <span class="number">0</span>);</span><br><span class="line">	WARN_ON((<span class="type">int</span>)tp-&gt;retrans_out &lt; <span class="number">0</span>);</span><br><span class="line">	WARN_ON((<span class="type">int</span>)tcp_packets_in_flight(tp) &lt; <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> state-&gt;flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_sacktag_write_queue</code>首先从TCP选项头中提取SACK信息，然后计算当前数据包<code>sack</code>块的数量，如果当前连接还没有任何<code>skb</code>被<code>ack</code>过，则重置最高<code>sack</code>（可以加速找到需要标记的<code>ack</code>），之后调用<code>tcp_check_dsack</code>，<strong>检查本次<code>sack</code>中是否存在<code>dsack</code></strong>（后续会因为是否为<code>dsack</code>执行不同的流程）具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查dsack 好像rfc的规范是dsack的信息就在前两个块中</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_check_dsack</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *ack_skb,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> tcp_sack_block_wire *sp, <span class="type">int</span> num_sacks,</span></span><br><span class="line"><span class="params">			    u32 prior_snd_una, <span class="keyword">struct</span> tcp_sacktag_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	u32 start_seq_0 = get_unaligned_be32(&amp;sp[<span class="number">0</span>].start_seq);<span class="comment">//起始序列号</span></span><br><span class="line">	u32 end_seq_0 = get_unaligned_be32(&amp;sp[<span class="number">0</span>].end_seq);    <span class="comment">//结束序列号</span></span><br><span class="line">	u32 dup_segs;</span><br><span class="line">	<span class="comment">//第一个SACK块在ACK序号之前，标准的dsack</span></span><br><span class="line">	<span class="keyword">if</span> (before(start_seq_0, TCP_SKB_CB(ack_skb)-&gt;ack_seq)) &#123;</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECV);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num_sacks &gt; <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">//是否存在重叠</span></span><br><span class="line">		u32 end_seq_1 = get_unaligned_be32(&amp;sp[<span class="number">1</span>].end_seq);</span><br><span class="line">		u32 start_seq_1 = get_unaligned_be32(&amp;sp[<span class="number">1</span>].start_seq);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (after(end_seq_0, end_seq_1) || before(start_seq_0, start_seq_1))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKOFORECV);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//走到这里表示一定发生了重复sack，基于mss计算重复的段数</span></span><br><span class="line">	dup_segs = tcp_dsack_seen(tp, start_seq_0, end_seq_0, state);</span><br><span class="line">	<span class="keyword">if</span> (!dup_segs) &#123;	<span class="comment">/* Skip dubious DSACK */</span></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDSACKIGNOREDDUBIOUS);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NET_ADD_STATS(sock_net(sk), LINUX_MIB_TCPDSACKRECVSEGS, dup_segs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* D-SACK for already forgotten data... Do dumb counting. */</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;undo_marker &amp;&amp; tp-&gt;undo_retrans &gt; <span class="number">0</span> &amp;&amp;						<span class="comment">//需要undo，且重传过了</span></span><br><span class="line">	    !after(end_seq_0, prior_snd_una) &amp;&amp;					<span class="comment">//dsack的数据是 una之前的数据 </span></span><br><span class="line">	    after(end_seq_0, tp-&gt;undo_marker))					<span class="comment">//dsack的数据是 una之前的数据 </span></span><br><span class="line">		tp-&gt;undo_retrans = <span class="type">max_t</span>(<span class="type">int</span>, <span class="number">0</span>, tp-&gt;undo_retrans - dup_segs);	<span class="comment">//修正计数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_check_dsack</code>主要工作就是判断是否存在<code>dsack</code>，如果确实是 <code>dsack</code>，就更新 <code>dsack</code>统计、并调用<code>tcp_dsack_seen</code>计算重复段数，同时在必要时修相关的重传计数。计算<code>dup_segs</code>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">tcp_dsack_seen</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tp, u32 start_seq,</span></span><br><span class="line"><span class="params">			  u32 end_seq, <span class="keyword">struct</span> tcp_sacktag_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 seq_len, dup_segs = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">if</span> (!before(start_seq, end_seq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//计算长度</span></span><br><span class="line">	seq_len = end_seq - start_seq;</span><br><span class="line">	<span class="comment">/* Dubious DSACK: DSACKed range greater than maximum advertised rwnd */</span></span><br><span class="line">	<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">if</span> (seq_len &gt; tp-&gt;max_window)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (seq_len &gt; tp-&gt;mss_cache)</span><br><span class="line">		dup_segs = DIV_ROUND_UP(seq_len, tp-&gt;mss_cache);</span><br><span class="line">	<span class="comment">//区分是TLP引起的重复还是真正的虚假重传</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tp-&gt;tlp_high_seq &amp;&amp; tp-&gt;tlp_high_seq == end_seq)</span><br><span class="line">		state-&gt;flag |= FLAG_DSACK_TLP;</span><br><span class="line">	<span class="comment">//记录重复的段数</span></span><br><span class="line">	tp-&gt;dsack_dups += dup_segs;</span><br><span class="line">	<span class="comment">/* Skip the DSACK if dup segs weren&#x27;t retransmitted by sender */</span></span><br><span class="line">	<span class="comment">//合法性检查吧</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;dsack_dups &gt; tp-&gt;total_retrans)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//收到dsack</span></span><br><span class="line">	tp-&gt;rx_opt.sack_ok |= TCP_DSACK_SEEN;</span><br><span class="line">	<span class="comment">/* We increase the RACK ordering window in rounds where we receive</span></span><br><span class="line"><span class="comment">	 * DSACKs that may have been due to reordering causing RACK to trigger</span></span><br><span class="line"><span class="comment">	 * a spurious fast recovery. Thus RACK ignores DSACKs that happen</span></span><br><span class="line"><span class="comment">	 * without having seen reordering, or that match TLP probes (TLP</span></span><br><span class="line"><span class="comment">	 * is timer-driven, not triggered by RACK).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//如果不是tlp导致的重传，就告诉rack，这里会影响undoloss</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;reord_seen &amp;&amp; !(state-&gt;flag &amp; FLAG_DSACK_TLP))</span><br><span class="line">		tp-&gt;rack.dsack_seen = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//标识sack块中包含dsack</span></span><br><span class="line">	state-&gt;flag |= FLAG_DSACKING_ACK;</span><br><span class="line">	<span class="comment">/* A spurious retransmission is delivered */</span></span><br><span class="line">	<span class="comment">//记录重复的段数</span></span><br><span class="line">	state-&gt;sack_delivered += dup_segs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dup_segs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_dsack_seen</code>的主要逻辑为估算重复段数（<code>dup_segs</code>），<strong>区分是否是 TLP 探测导致的重复（会影响后续tlp报文确认的处理），并把 DSACK 结果写回到 <code>tp</code> 和 <code>state</code>，供后续 <code>tcp_ack_is_dubious</code>等逻辑使用</strong></p>
<p>判断是否为<code>dsack</code>后，接下来会调用<code>tcp_is_sackblock_valid</code>把<code>ack</code>报文中的每个<code>sack``block</code>逐个校验**，并丢弃无用的<code>block</code>最终得到一个sp[]数组**，这个数组用于后面指导标记真正的重传队列，同时它还会维护一个<code>first_sack_index</code>标识原始第 0 块是否还能算 dsack</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/16/TCPsack%E5%A4%84%E7%90%86tcp_sacktag_write_queue/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/" class="post-title-link" itemprop="url">TCP确认 tcp_ack（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-14 22:00:00 / 修改时间：19:43:31" itemprop="dateCreated datePublished" datetime="2025-12-14T22:00:00+08:00">2025-12-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>慢速路径中收上来的数据包在<code>tcp_ack</code> 中会调用<code>tcp_ack_update_window</code>尝试更新窗口，之后通过<code>tcp_sacktag_write_queue</code>处理<code>sack</code>，这里对<code>sack</code>的处理逻辑非常复杂，后续分析。处理完成后会更新<code>sack</code>确认的段数，并判断窗口是否被推进并调用拥塞算法的钩子（如果存在）。</p>
<p>接下来调用<code>tcp_clean_rtx_queue</code>移除重传队列中已经确认的数据包，也稍微有点复杂，后续分析，主要工作就是传出<code>flag</code>（标识是否为可疑的<code>ack</code>），用于指导下面拥塞控制处理。</p>
<p>接下来调用<code>tcp_rack_update_reo_wnd</code> 根据上面<code>sack</code>的处理结果（是否看到了重复<code>ack</code>)来调整乱序因子，进而影响后续<code>rack</code>丢包机制的判断，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_rack_update_reo_wnd</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> rate_sample *rs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//默认不进入会在个分支</span></span><br><span class="line">	<span class="keyword">if</span> ((READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_recovery) &amp;</span><br><span class="line">	     TCP_RACK_STATIC_REO_WND) ||</span><br><span class="line">	    !rs-&gt;prior_delivered)  <span class="comment">//本次速率采样区间开始时确认的包数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disregard DSACK if a rtt has not passed since we adjusted reo_wnd */</span></span><br><span class="line">	<span class="comment">//还没有经过一个完整的RTT</span></span><br><span class="line">	<span class="keyword">if</span> (before(rs-&gt;prior_delivered, tp-&gt;rack.last_delivered))</span><br><span class="line">		tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust the reo_wnd if update is pending */</span></span><br><span class="line">	<span class="comment">//这个是处理sack中设置的，如果看到了daack就增大reo_wnd_steps，这个值会影响rack是否标记为丢包，合理</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;rack.dsack_seen) &#123;</span><br><span class="line">		tp-&gt;rack.reo_wnd_steps = <span class="type">min_t</span>(u32, <span class="number">0xFF</span>,</span><br><span class="line">					       tp-&gt;rack.reo_wnd_steps + <span class="number">1</span>);</span><br><span class="line">		tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line">		tp-&gt;rack.last_delivered = tp-&gt;delivered;</span><br><span class="line">		tp-&gt;rack.reo_wnd_persist = TCP_RACK_RECOVERY_THRESH;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!tp-&gt;rack.reo_wnd_persist) &#123;<span class="comment">//这个值是误判丢包的数量</span></span><br><span class="line">		tp-&gt;rack.reo_wnd_steps = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_rack_update_reo_wnd</code>首先判断当前采样区间是否经过了一个<code>rtt</code>，如果经过了一个<code>rtt</code>且<code>sack</code>的处理中发现了重复<code>ack</code>则更新 <code>reo_wnd_steps</code> 。后续会在<code>tcp_rack_reo_wnd</code>中根据<code>reo_wnd_steps</code>计算得到的时间窗口决定 将哪些数据包标记为丢失。</p>
<p>回到<code>tcp_ack</code>中，上述工作完成后会调用<code>tcp_process_tlp_ack</code>处理TLP重传数据包(如果当前存在<code>tlp</code>数据包的话)，核心思想就是判断是否发生了尾部丢包，如果发生则会进入拥塞状态，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_process_tlp_ack</span><span class="params">(<span class="keyword">struct</span> sock *sk, u32 ack, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//没有确认到tlp的序列号，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (before(ack, tp-&gt;tlp_high_seq))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;tlp_retrans) &#123;</span><br><span class="line">		<span class="comment">/* TLP of new data has been acknowledged */</span></span><br><span class="line">		<span class="comment">//TLP探测的是新数据</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp; FLAG_DSACK_TLP) &#123;<span class="comment">//收到了tlp包的重复ack</span></span><br><span class="line">		<span class="comment">/* This DSACK means original and TLP probe arrived; no loss */</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//表示确实发生了丢包，这里有点疑惑，不是有可能也是延迟的情况吗？是不是因为上面没有回复sack？？</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(ack, tp-&gt;tlp_high_seq)) &#123;</span><br><span class="line">		<span class="comment">/* ACK advances: there was a loss, so reduce cwnd. Reset</span></span><br><span class="line"><span class="comment">		 * tlp_high_seq in tcp_init_cwnd_reduction()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_init_cwnd_reduction(sk);</span><br><span class="line">		tcp_set_ca_state(sk, TCP_CA_CWR); <span class="comment">//将状态设置为cwr</span></span><br><span class="line">		tcp_end_cwnd_reduction(sk);</span><br><span class="line">		tcp_try_keep_open(sk);</span><br><span class="line">		NET_INC_STATS(sock_net(sk),</span><br><span class="line">				LINUX_MIB_TCPLOSSPROBERECOVERY);</span><br><span class="line">	<span class="comment">//单纯的重复ack，没有推进窗口，表示就单纯的收到一个重复ack</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(flag &amp; (FLAG_SND_UNA_ADVANCED |</span><br><span class="line">			     FLAG_NOT_DUP | FLAG_DATA_SACKED))) &#123;</span><br><span class="line">		<span class="comment">/* Pure dupack: original and TLP probe arrived; no loss */</span></span><br><span class="line">		tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中<code>tlp_high_seq</code>为 TLP 探测中的最高序列号边界，这里主要分成以下几种情况对序列号进行处理：</p>
<ul>
<li>如果当前<code>ack</code>还没有到<code>tlp</code>的范围直接返回。</li>
<li>如果 ACK 已经到达 <code>tlp_high_seq</code>，且TLP数据包为新数据包（从发送队列中拿到的），则认为没有丢失数据包，清空<code>tlp_high_seq</code>结束本次<code>tlp</code>探测。</li>
<li>如果收到了<code>tlp</code>包的重复ack则表示也没有发生丢包，直接清掉<code>tlp_high_seq</code></li>
<li>如果<code>ack</code>确认了超过<code>tlp_high_seq</code>且<code>tlp</code>数据包是从重传队列中发送的，则认为数据包丢了（这里有个问题，不会是因为延迟没遇到到达的情况吗？）执行一系列拥塞算法的处理流程（重新计算慢启动阈值，设置拥塞状态等）</li>
<li>如果收到是单纯的一个重复<code>ack</code>同时没有推进窗口则也认为没有丢包，清掉<code>tlp_high_seq</code>（这种情况几乎不会有吧）。</li>
</ul>
<p>回到<code>tcp_ack</code>中，接下来会根据<code>ack</code>的处理结果决定是否进入拥塞状态转换的处理逻辑中，在文章<a href="/2025/10/28/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%8B%A5%E5%A1%9E%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/" title="TCP拥塞控制-拥塞状态转换">TCP拥塞控制-拥塞状态转换</a>分析过，这里不再重复：-）。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/14/TCP%20ack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%20tcp_ack(2)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/" class="post-title-link" itemprop="url">TCP确认 tcp_ack（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-11 22:00:00" itemprop="dateCreated datePublished" datetime="2025-12-11T22:00:00+08:00">2025-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-17 22:32:15" itemprop="dateModified" datetime="2025-12-17T22:32:15+08:00">2025-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong><code>tcp_ack</code>(）用于处理接收到所有携带ack标志位的数据包，建立连接状态下的所有数据包几乎都携带<code>ack</code>标志位，慢速路径以及快速路径都会调用。</strong></p>
<p><strong><code>tcp_ack</code>主要目的是根据<code>ack</code>报文调整发送端的状态，整体工作可以分为以下几个部分：</strong></p>
<ul>
<li>ACK 合法性校验</li>
<li>更新 <code>snd_una</code> &#x2F; <code>窗口</code> &#x2F; <code>SACK</code> &#x2F; <code>ECN</code>（确认信息 &amp; 窗口信息）</li>
<li>清理重传队列，更新 <code>RACK</code> &#x2F; <code>TLP</code> &#x2F; 丢包信息</li>
<li>判断 ACK 是否可疑（重复 <code>ACK</code>、<code>DSACK</code> 等），触发快速重传&#x2F;恢复逻辑</li>
<li>拥塞状态转换，调用拥塞算法钩子</li>
</ul>
<p>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This routine deals with incoming acks, but not outgoing ones. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_ack</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sacktag_state</span> <span class="title">sack_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rate_sample</span> <span class="title">rs</span> =</span> &#123; .prior_delivered = <span class="number">0</span> &#125;;</span><br><span class="line">	u32 prior_snd_una = tp-&gt;snd_una; 		<span class="comment">//已经发送未被确认的序列号</span></span><br><span class="line">	<span class="type">bool</span> is_sack_reneg = tp-&gt;is_sack_reneg;  <span class="comment">//是否是sack反悔</span></span><br><span class="line">	u32 ack_seq = TCP_SKB_CB(skb)-&gt;seq;     <span class="comment">//提取数据包的序号</span></span><br><span class="line">	u32 ack = TCP_SKB_CB(skb)-&gt;ack_seq;     <span class="comment">///提取当前数据包确认的序列号</span></span><br><span class="line">	<span class="type">int</span> num_dupack = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> prior_packets = tp-&gt;packets_out;    <span class="comment">//发送出去没有被ack的数量</span></span><br><span class="line">	u32 delivered = tp-&gt;delivered;		   <span class="comment">//被确认的ack总数</span></span><br><span class="line">	u32 lost = tp-&gt;lost;				   <span class="comment">//历史丢包数</span></span><br><span class="line">	<span class="type">int</span> rexmit = REXMIT_NONE; <span class="comment">/* Flag to (re)transmit to recover losses */</span><span class="comment">//是否需要重传的标记</span></span><br><span class="line">	u32 prior_fack;</span><br><span class="line"></span><br><span class="line">	sack_state.first_sackt = <span class="number">0</span>;</span><br><span class="line">	sack_state.rate = &amp;rs;</span><br><span class="line">	sack_state.sack_delivered = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We very likely will need to access rtx queue. */</span></span><br><span class="line">	<span class="comment">//预取</span></span><br><span class="line">	prefetch(sk-&gt;tcp_rtx_queue.rb_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack is older than previous acks</span></span><br><span class="line"><span class="comment">	 * then we can probably ignore it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//当前确认的序列号在una之前</span></span><br><span class="line">	<span class="keyword">if</span> (before(ack, prior_snd_una)) &#123;</span><br><span class="line">		<span class="comment">/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */</span></span><br><span class="line">		<span class="comment">//这个ack太老了(可能是注入攻击)，比往前算一个窗口还要小，那就回一个挑战ack</span></span><br><span class="line">		<span class="keyword">if</span> (before(ack, prior_snd_una - tp-&gt;max_window)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_NO_CHALLENGE_ACK))</span><br><span class="line">				tcp_send_challenge_ack(sk);</span><br><span class="line">			<span class="keyword">return</span> -SKB_DROP_REASON_TCP_TOO_OLD_ACK;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> old_ack; <span class="comment">//返回0，外面也会回复挑战ack</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the ack includes data we haven&#x27;t sent yet, discard</span></span><br><span class="line"><span class="comment">	 * this segment (RFC793 Section 3.9).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//太超前了</span></span><br><span class="line">	<span class="keyword">if</span> (after(ack, tp-&gt;snd_nxt))</span><br><span class="line">		<span class="keyword">return</span> -SKB_DROP_REASON_TCP_ACK_UNSENT_DATA;</span><br><span class="line">	<span class="comment">//确认了新数据</span></span><br><span class="line">	<span class="keyword">if</span> (after(ack, prior_snd_una)) &#123;</span><br><span class="line">		flag |= FLAG_SND_UNA_ADVANCED; <span class="comment">//设置推进ack标志了，下面会用到</span></span><br><span class="line">		icsk-&gt;icsk_retransmits = <span class="number">0</span>;    <span class="comment">//重传清零</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_TLS_DEVICE)</span></span><br><span class="line">		<span class="keyword">if</span> (static_branch_unlikely(&amp;clean_acked_data_enabled.key))</span><br><span class="line">			<span class="keyword">if</span> (icsk-&gt;icsk_clean_acked)</span><br><span class="line">				icsk-&gt;icsk_clean_acked(sk, ack);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回una或者sack最高的序列号</span></span><br><span class="line">	prior_fack = tcp_is_sack(tp) ? tcp_highest_sack_seq(tp) : tp-&gt;snd_una;</span><br><span class="line">	<span class="comment">//设置在途数据包数</span></span><br><span class="line">	rs.prior_in_flight = tcp_packets_in_flight(tp);</span><br><span class="line">	<span class="comment">/* ts_recent update must be made after we are sure that the packet</span></span><br><span class="line"><span class="comment">	 * is in window.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//slowpath会设置这个标志，这里会通过PAWS检查后更新时间戳</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_UPDATE_TS_RECENT)</span><br><span class="line">		tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)-&gt;seq);</span><br><span class="line">	<span class="comment">//这里是fastpath</span></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; (FLAG_SLOWPATH | FLAG_SND_UNA_ADVANCED)) ==</span><br><span class="line">	    FLAG_SND_UNA_ADVANCED) &#123;</span><br><span class="line">		<span class="comment">/* Window is constant, pure forward advance.</span></span><br><span class="line"><span class="comment">		 * No more checks are required.</span></span><br><span class="line"><span class="comment">		 * Note, we use the fact that SND.UNA&gt;=SND.WL2.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//更新发送窗口更新时候的序列号，第二个参数是数据包的序号</span></span><br><span class="line">		tcp_update_wl(tp, ack_seq);</span><br><span class="line">		<span class="comment">//更新una和确认的字节数</span></span><br><span class="line">		tcp_snd_una_update(tp, ack);</span><br><span class="line">		<span class="comment">//设置更新窗口标志位</span></span><br><span class="line">		flag |= FLAG_WIN_UPDATE;</span><br><span class="line">		<span class="comment">//调用拥塞算法钩子，如果有</span></span><br><span class="line">		tcp_in_ack_event(sk, CA_ACK_WIN_UPDATE);</span><br><span class="line"></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPACKS);</span><br><span class="line">	<span class="comment">//这里是走slowpah</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u32 ack_ev_flags = CA_ACK_SLOWPATH;</span><br><span class="line">		<span class="comment">//标记数据包是否携带数据</span></span><br><span class="line">		<span class="keyword">if</span> (ack_seq != TCP_SKB_CB(skb)-&gt;end_seq)</span><br><span class="line">			flag |= FLAG_DATA;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPUREACKS);</span><br><span class="line">		<span class="comment">//这里的第三个参数是确认号， 第四个参数ack_seq是报文的序列号</span></span><br><span class="line">		flag |= tcp_ack_update_window(sk, skb, ack, ack_seq);</span><br><span class="line">		<span class="comment">//处理sack</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;sacked)</span><br><span class="line">			flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">							&amp;sack_state);</span><br><span class="line">		<span class="comment">//发生了拥塞，设置标志位</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_ecn_rcv_ecn_echo(tp, tcp_hdr(skb))) &#123;</span><br><span class="line">			flag |= FLAG_ECE;</span><br><span class="line">			ack_ev_flags |= CA_ACK_ECE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有sack确认的段数，需要更新确认的总数，合理</span></span><br><span class="line">		<span class="keyword">if</span> (sack_state.sack_delivered)</span><br><span class="line">			tcp_count_delivered(tp, sack_state.sack_delivered,</span><br><span class="line">					    flag &amp; FLAG_ECE);</span><br><span class="line">		<span class="comment">//窗口是否推进了</span></span><br><span class="line">		<span class="keyword">if</span> (flag &amp; FLAG_WIN_UPDATE)</span><br><span class="line">			ack_ev_flags |= CA_ACK_WIN_UPDATE;</span><br><span class="line">		<span class="comment">//调用拥塞算法的钩子</span></span><br><span class="line">		tcp_in_ack_event(sk, ack_ev_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This is a deviation from RFC3168 since it states that:</span></span><br><span class="line"><span class="comment">	 * &quot;When the TCP data sender is ready to set the CWR bit after reducing</span></span><br><span class="line"><span class="comment">	 * the congestion window, it SHOULD set the CWR bit only on the first</span></span><br><span class="line"><span class="comment">	 * new data packet that it transmits.&quot;</span></span><br><span class="line"><span class="comment">	 * We accept CWR on pure ACKs to be more robust</span></span><br><span class="line"><span class="comment">	 * with widely-deployed TCP implementations that do this.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//如果是显示拥塞，这里立即设置回复ack的标志位，因为发送端窗口已经很小了，需要立即回复ack</span></span><br><span class="line">	tcp_ecn_accept_cwr(sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We passed data and got it acked, remove any soft error</span></span><br><span class="line"><span class="comment">	 * log. Something worked...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_err_soft, <span class="number">0</span>);</span><br><span class="line">	icsk-&gt;icsk_probes_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rcv_tstamp = tcp_jiffies32;</span><br><span class="line">	<span class="keyword">if</span> (!prior_packets)</span><br><span class="line">		<span class="keyword">goto</span> no_queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we can take anything off of the retransmit queue. */</span></span><br><span class="line">	<span class="comment">//清重传队列</span></span><br><span class="line">	flag |= tcp_clean_rtx_queue(sk, skb, prior_fack, prior_snd_una,</span><br><span class="line">				    &amp;sack_state, flag &amp; FLAG_ECE);</span><br><span class="line">	<span class="comment">//根据sack的处理来调整乱续增长因子进而影响丢包判断</span></span><br><span class="line">	tcp_rack_update_reo_wnd(sk, &amp;rs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag); </span><br><span class="line">	<span class="comment">//当前ack是否可疑（	没有确认数据，窗口更新 纯ack sack 或者dsack ）</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_ack_is_dubious(sk, flag)) &#123;</span><br><span class="line">		<span class="comment">//是否是一个纯粹的重复ack（没有确认新数据）</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (FLAG_SND_UNA_ADVANCED | </span><br><span class="line">			      FLAG_NOT_DUP | FLAG_DSACKING_ACK))) &#123;</span><br><span class="line">			num_dupack = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">/* Consider if pure acks were aggregated in tcp_add_backlog() */</span></span><br><span class="line">			<span class="comment">//统计纯ack的计数，注意这里协议站可能会聚合纯ack</span></span><br><span class="line">			<span class="keyword">if</span> (!(flag &amp; FLAG_DATA)) </span><br><span class="line">				num_dupack = <span class="type">max_t</span>(u16, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//传入的是snd_una, 重复ack的数量，ack的标志位 ，传入传出rexmit会指导下面的重传</span></span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If needed, reset TLP/RTO timer when RACK doesn&#x27;t set. */</span></span><br><span class="line">	<span class="comment">//在清理重传队列的时候可能会设置上这个标志位，比如有新的数据包被确认的时候，或者检测到乱续或者丢包 肯定需要重新设置这个定时器了</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_SET_XMIT_TIMER)</span><br><span class="line">		tcp_set_xmit_timer(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; FLAG_FORWARD_PROGRESS) || !(flag &amp; FLAG_NOT_DUP))</span><br><span class="line">		sk_dst_confirm(sk);</span><br><span class="line">	<span class="comment">//更新统计字段累计收到了多少包</span></span><br><span class="line">	delivered = tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	<span class="comment">//更新丢包总数</span></span><br><span class="line">	lost = tp-&gt;lost - lost;			<span class="comment">/* freshly marked lost */</span></span><br><span class="line">	rs.is_ack_delayed = !!(flag &amp; FLAG_ACK_MAYBE_DELAYED);</span><br><span class="line">	<span class="comment">//更新bbr算法用到的字段</span></span><br><span class="line">	tcp_rate_gen(sk, delivered, lost, is_sack_reneg, sack_state.rate);</span><br><span class="line">	tcp_cong_control(sk, ack, delivered, flag, sack_state.rate);</span><br><span class="line">	tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">no_queue:</span><br><span class="line">	<span class="comment">/* If data was DSACKed, see if we can undo a cwnd reduction. */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; FLAG_DSACKING_ACK) &#123;</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		<span class="comment">////更新统计字段累计收到了多少包</span></span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If this ack opens up a zero window, clear backoff.  It was</span></span><br><span class="line"><span class="comment">	 * being used to time the probes, and is probably far higher than</span></span><br><span class="line"><span class="comment">	 * it needs to be for normal retransmission.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcp_ack_probe(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tlp_high_seq)</span><br><span class="line">		tcp_process_tlp_ack(sk, ack, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">old_ack:</span><br><span class="line">	<span class="comment">/* If data was SACKed, tag it and see if we should send more data.</span></span><br><span class="line"><span class="comment">	 * If data was DSACKed, see if we can undo a cwnd reduction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;sacked) &#123;</span><br><span class="line">		flag |= tcp_sacktag_write_queue(sk, skb, prior_snd_una,</span><br><span class="line">						&amp;sack_state);</span><br><span class="line">		tcp_fastretrans_alert(sk, prior_snd_una, num_dupack, &amp;flag,</span><br><span class="line">				      &amp;rexmit);</span><br><span class="line">		tcp_newly_delivered(sk, delivered, flag);</span><br><span class="line">		tcp_xmit_recovery(sk, rexmit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_ack</code>中<strong>首先判断数据包确认数据的序列号是否太老了，如果确认的序列号比往前移动一个最大接收窗口的的序号还老，会回一个<code>challenge</code> <code>ack</code></strong> （也可能不回复，有速率限制）。如果这个确认号不是太老的话，则直接<code>goto</code>到最下面，判断是否协携带了<code>sack</code>信息，如果没有携带直接返回0，同时也有可能回<code>challenge ack</code>（取决于是否是建立连接的通路上）。</p>
<p>如果数据包确认了还没发送的数据，则直接丢弃。</p>
<p>如果数据包确认了新数据（最常见的情况），则设置推进窗口标志为下面判断<code>slowpath</code>和<code>fastpath</code>会用到。之后判断<strong>如果是慢速路径收上来的数据包，则调用<code>tcp_replace_ts_recent</code>通过PAWS机制决定是否需要更新时间戳</strong>，（这里注意，如果是快速路径上收到 包已经更新过了），具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_replace_ts_recent</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tp, u32 seq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//进入这个分支应该是处理异常的数据包，小心的更新时间戳？</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;rx_opt.saw_tstamp &amp;&amp; !after(seq, tp-&gt;rcv_wup)) &#123;</span><br><span class="line">		<span class="comment">/* PAWS bug workaround wrt. ACK frames, the PAWS discard</span></span><br><span class="line"><span class="comment">		 * extra check below makes sure this can only happen</span></span><br><span class="line"><span class="comment">		 * for pure ACK frames.  -DaveM</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Not only, also it occurs for expired timestamps.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tcp_paws_check(&amp;tp-&gt;rx_opt, <span class="number">0</span>))</span><br><span class="line">			tcp_store_ts_recent(tp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来处理<code>fastpath</code>路径收包的情况，调用<code>tcp_snd_una_update</code>更新发送窗口（<strong>更新<code>una</code></strong>）和确认的总字节数，并设置标志位。具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/11/TCPack%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86tcp_ack()/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">TCP输出 __tcp_transmit_skb(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-09 22:00:00 / 修改时间：22:59:44" itemprop="dateCreated datePublished" datetime="2025-12-09T22:00:00+08:00">2025-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>__tcp_select_window</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">u32 __tcp_select_window(<span class="keyword">struct</span> sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">    <span class="comment">/* MSS for the peer&#x27;s data.  Previous versions used mss_clamp</span></span><br><span class="line"><span class="comment">     * here.  I don&#x27;t know if the value based on our guesses</span></span><br><span class="line"><span class="comment">     * of peer&#x27;s MSS is better for the performance.  It&#x27;s more correct</span></span><br><span class="line"><span class="comment">     * but may be worse for the performance because of rcv_mss</span></span><br><span class="line"><span class="comment">     * fluctuations.  --SAW  1998/11/1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> mss = icsk-&gt;icsk_ack.rcv_mss;  <span class="comment">//估计对端的mss</span></span><br><span class="line">    <span class="type">int</span> free_space = tcp_space(sk); <span class="comment">//这里是rcvbuf大小减去backlog还有接收队列之后实际剩余真实的内存量，当前可用的剩余空间</span></span><br><span class="line">    <span class="type">int</span> allowed_space = tcp_full_space(sk);<span class="comment">//这里是rcvbuf大小</span></span><br><span class="line">    <span class="type">int</span> full_space, window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk_is_mptcp(sk))</span><br><span class="line">        mptcp_space(sk, &amp;free_space, &amp;allowed_space);</span><br><span class="line">    <span class="comment">//取一个最大的 接收端硬限制的最大窗口</span></span><br><span class="line">    full_space = <span class="type">min_t</span>(<span class="type">int</span>, tp-&gt;window_clamp, allowed_space);</span><br><span class="line">    <span class="comment">//连一个mss都装不下</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(mss &gt; full_space)) &#123;</span><br><span class="line">        mss = full_space;</span><br><span class="line">        <span class="keyword">if</span> (mss &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow window shrink if the sysctl is enabled and we have</span></span><br><span class="line"><span class="comment">     * a non-zero scaling factor in effect.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//是否允许窗口缩小，默认不容许</span></span><br><span class="line">    <span class="keyword">if</span> (READ_ONCE(net-&gt;ipv4.sysctl_tcp_shrink_window) &amp;&amp; tp-&gt;rx_opt.rcv_wscale)</span><br><span class="line">        <span class="keyword">goto</span> shrink_window_allowed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do not allow window to shrink */</span></span><br><span class="line">    <span class="comment">//当 free_space 比 full_space 的一半要小，这里可以理解为小于实际窗口的一半吧</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &lt; (full_space &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        icsk-&gt;icsk_ack.quick = <span class="number">0</span>;  <span class="comment">//关闭 quick ACK 避免频繁ack</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_under_memory_pressure(sk)) <span class="comment">//是否在内存压力之下</span></span><br><span class="line">            tcp_adjust_rcv_ssthresh(sk);    <span class="comment">//设置rcv_ssthresh</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* free_space might become our new window, make sure we don&#x27;t</span></span><br><span class="line"><span class="comment">         * increase it due to wscale.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//free_space 齐到 wscale </span></span><br><span class="line">        free_space = round_down(free_space, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if free space is less than mss estimate, or is below 1/16th</span></span><br><span class="line"><span class="comment">         * of the maximum allowed, try to move to zero-window, else</span></span><br><span class="line"><span class="comment">         * tcp_clamp_window() will grow rcv buf up to tcp_rmem[2], and</span></span><br><span class="line"><span class="comment">         * new incoming data is dropped due to memory limits.</span></span><br><span class="line"><span class="comment">         * With large window, mss test triggers way too late in order</span></span><br><span class="line"><span class="comment">         * to announce zero window in time before rmem limit kicks in.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//是否直接变成 0 窗口  当前可用空间 小于最大允许空间的 1/16 || 连一个 MSS 都没有</span></span><br><span class="line">        <span class="keyword">if</span> (free_space &lt; (allowed_space &gt;&gt; <span class="number">4</span>) || free_space &lt; mss)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于发送慢启动阈值，设置为慢启动阈值！</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &gt; tp-&gt;rcv_ssthresh)</span><br><span class="line">        free_space = tp-&gt;rcv_ssthresh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t do rounding if we are using window scaling, since the</span></span><br><span class="line"><span class="comment">     * scaled window will not line up with the MSS boundary anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//开启了窗口缩放</span></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;rx_opt.rcv_wscale) &#123;</span><br><span class="line">        window = free_space;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Advertise enough space so that it won&#x27;t get scaled away.</span></span><br><span class="line"><span class="comment">         * Import case: prevent zero window announcement if</span></span><br><span class="line"><span class="comment">         * 1&lt;&lt;rcv_wscale &gt; mss.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//对齐窗口缩放</span></span><br><span class="line">        window = ALIGN(window, (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没启用窗口缩放的情况</span></span><br><span class="line">        window = tp-&gt;rcv_wnd;</span><br><span class="line">        <span class="comment">/* Get the largest window that is a nice multiple of mss.</span></span><br><span class="line"><span class="comment">         * Window clamp already applied above.</span></span><br><span class="line"><span class="comment">         * If our current window offering is within 1 mss of the</span></span><br><span class="line"><span class="comment">         * free space we just keep it. This prevents the divide</span></span><br><span class="line"><span class="comment">         * and multiply from happening most of the time.</span></span><br><span class="line"><span class="comment">         * We also don&#x27;t do any window rounding when the free space</span></span><br><span class="line"><span class="comment">         * is too small.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//窗口变化太大了，就重新设定一个新的 对齐到 MSS 的整倍数的窗口</span></span><br><span class="line">        <span class="keyword">if</span> (window &lt;= free_space - mss || window &gt; free_space)</span><br><span class="line">            window = rounddown(free_space, mss);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mss == full_space &amp;&amp;   <span class="comment">//一次最大窗口只能装一个 MSS   可用空间超过 window + 一半的实际窗口）</span></span><br><span class="line">             free_space &gt; window + (full_space &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            window = free_space;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> window;</span><br><span class="line"></span><br><span class="line">shrink_window_allowed: <span class="comment">//是否更激进的缩小拥塞窗口吧</span></span><br><span class="line">    <span class="comment">/* new window should always be an exact multiple of scaling factor */</span></span><br><span class="line">    <span class="comment">//向下对齐</span></span><br><span class="line">    free_space = round_down(free_space, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);</span><br><span class="line">    <span class="comment">//如果 free_space 已经小于 full_space 的一半</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &lt; (full_space &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        icsk-&gt;icsk_ack.quick = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否内存压力，修改慢启动阈值</span></span><br><span class="line">        <span class="keyword">if</span> (tcp_under_memory_pressure(sk))</span><br><span class="line">            tcp_adjust_rcv_ssthresh(sk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if free space is too low, return a zero window */</span></span><br><span class="line">        <span class="comment">//表示空闲空间只剩下不足 1/16  ||  不足一个mss</span></span><br><span class="line">        <span class="keyword">if</span> (free_space &lt; (allowed_space &gt;&gt; <span class="number">4</span>) || free_space &lt; mss ||</span><br><span class="line">            free_space &lt; (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大于接收端慢启动阈值</span></span><br><span class="line">    <span class="keyword">if</span> (free_space &gt; tp-&gt;rcv_ssthresh) &#123;</span><br><span class="line">        free_space = tp-&gt;rcv_ssthresh;</span><br><span class="line">        <span class="comment">/* new window should always be an exact multiple of scaling factor</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For this case, we ALIGN &quot;up&quot; (increase free_space) because</span></span><br><span class="line"><span class="comment">         * we know free_space is not zero here, it has been reduced from</span></span><br><span class="line"><span class="comment">         * the memory-based limit, and rcv_ssthresh is not a hard limit</span></span><br><span class="line"><span class="comment">         * (unlike sk_rcvbuf).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//对齐</span></span><br><span class="line">        free_space = ALIGN(free_space, (<span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> free_space;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__tcp_select_window</code>中首先计算接收缓冲区的剩余空间<code>free_space</code> 然后计算接收缓冲区全部的可用大小（按比例计算）<code>allowed_space</code>，拿到这两个值后，计算<strong>理论允许的最大接收窗口</strong><code>full_space</code>。</p>
<p>如果连一个<code>mss</code>都放不下直接0窗口，</p>
<p>之后判断是否允许窗口收缩(是否可以激进的主动缩小窗口)，系统默认是不允许。如果是不收缩的逻辑，则进一步判断剩余的空间大小是否已经小于了缓冲区大小的一半（<strong>已经吃掉了超过半个接收窗口</strong>）则关闭快速<code>ack</code>，如果在内存压力之下，则调用<code>tcp_adjust_rcv_ssthresh</code>设置接收端慢启动阈值**(和拥塞窗口的类似，但是这里是控制接收窗口大小的**)，最后把 <code>free_space</code> 向下对齐到 <code>2^rcv_wscale</code> 的整数倍，如果 当前可用空间 小于最大允许空间的 1&#x2F;16 或连一个 MSS 都没有，则也直接0窗口</p>
<p>上述<code>tcp_adjust_rcv_ssthresh</code> 代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcp_adjust_rcv_ssthresh</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算剩余的内存（用户配置），通常是0</span></span><br><span class="line">    <span class="type">int</span> unused_mem = sk_unused_reserved_mem(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="comment">//钳制一下，最小4个mss</span></span><br><span class="line">    tp-&gt;rcv_ssthresh = min(tp-&gt;rcv_ssthresh, <span class="number">4U</span> * tp-&gt;advmss);</span><br><span class="line">    <span class="keyword">if</span> (unused_mem)</span><br><span class="line">        <span class="comment">//如果由保留的内存则取一个最大值</span></span><br><span class="line">        tp-&gt;rcv_ssthresh = <span class="type">max_t</span>(u32, tp-&gt;rcv_ssthresh,</span><br><span class="line">                     tcp_win_from_space(sk, unuserud_mem));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果剩余空间大于了接收端慢启动阈值，则设置为接收端慢启动阈值，目的就是用来限制窗口增长不要太快。</p>
<p>最后根据是否启用窗口缩放决定最终的window大小，具体分为两种情况，如果启用了窗口缩放，则 <code>window = free_space</code>，再往上对齐到 <code>2^wscale</code> 的倍数。否则判断现在的窗口 <code>（window）</code>是否比 <code>free_space</code> 小太多（差超过 1 MSS），说明应该再增大一点，重新设为 <code>free_space</code> 向下对齐到 MSS 倍数，上述位没开启<code>shrink</code>系统选项的逻辑</p>
<p>如果开启了允许窗口<code>shrink</code>（允许缩小窗口的情况）如果<code>free_space &lt; full_space/2</code>，这里和上述主路径类似，关闭快速<code>ack</code>，内存紧张时候降低慢启动阈值，如果窗口过小则直接零窗口。如果<code>free_space &gt; rcv_ssthresh</code>这里和主路径不同， <strong>向上对齐</strong>到 <code>2^wscale</code> 的倍数。这里感觉主路径和<code>shrink</code>路径没什么区别。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/09/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb%EF%BC%882%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/" class="post-title-link" itemprop="url">TCP输出 __tcp_transmit_skb(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-07 22:00:00 / 修改时间：22:17:00" itemprop="dateCreated datePublished" datetime="2025-12-07T22:00:00+08:00">2025-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>__tcp_transmit_skb</code>为TCP发送路径上交给IP层的最后一个处理函数，主要完成如下工作：</p>
<p>设置时间戳，构建头部各个字段，<code>TCP</code>选项，设置<code>skb</code>属于哪个<code>sk</code>，设置析构函数，更新内存记账。</p>
<p>计算通告给对端的窗口大小，计算伪首部，更新统计字段，数据包的GSO字段。</p>
<p>调用<code>ip</code>层发包函数，更新拥塞算法用到的时间戳字段等等，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __tcp_transmit_skb(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line">			      <span class="type">int</span> clone_it, <span class="type">gfp_t</span> gfp_mask, u32 rcv_nxt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tcp_options_size, tcp_header_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">	u64 prior_wstamp;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line">	tp = tcp_sk(sk);</span><br><span class="line">	<span class="comment">//发包前记录时间戳</span></span><br><span class="line">	prior_wstamp = tp-&gt;tcp_wstamp_ns;</span><br><span class="line">	<span class="comment">//确保时间单调不减？</span></span><br><span class="line">	tp-&gt;tcp_wstamp_ns = max(tp-&gt;tcp_wstamp_ns, tp-&gt;tcp_clock_cache);</span><br><span class="line">	<span class="comment">//给qisc用</span></span><br><span class="line">	skb_set_delivery_time(skb, tp-&gt;tcp_wstamp_ns, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (clone_it) &#123; <span class="comment">//需要重传的情况</span></span><br><span class="line">		oskb = skb; <span class="comment">//原skb的指针</span></span><br><span class="line"></span><br><span class="line">		tcp_skb_tsorted_save(oskb) &#123;          	<span class="comment">//临时把 skb 内部 _skb_refdst 字段清空</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(skb_cloned(oskb)))<span class="comment">//克隆数据包</span></span><br><span class="line">				skb = pskb_copy(oskb, gfp_mask);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				skb = skb_clone(oskb, gfp_mask);</span><br><span class="line">		&#125; tcp_skb_tsorted_restore(oskb);		<span class="comment">//还原</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">		<span class="comment">/* retransmit skbs might have a non zero value in skb-&gt;dev</span></span><br><span class="line"><span class="comment">		 * because skb-&gt;dev is aliased with skb-&gt;rbnode.rb_left</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inet = inet_sk(sk);</span><br><span class="line">	tcb = TCP_SKB_CB(skb);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line">	<span class="comment">//syn 包构建选项走这里</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN)) &#123;</span><br><span class="line">		tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//正常数据包选项走这里</span></span><br><span class="line">		tcp_options_size = tcp_established_options(sk, skb, &amp;opts,</span><br><span class="line">							   &amp;md5);</span><br><span class="line">		<span class="comment">/* Force a PSH flag on all (GSO) packets to expedite GRO flush</span></span><br><span class="line"><span class="comment">		 * at receiver : This slightly improve GRO performance.</span></span><br><span class="line"><span class="comment">		 * Note that we do not force the PSH flag for non GSO packets,</span></span><br><span class="line"><span class="comment">		 * because they might be sent under high congestion events,</span></span><br><span class="line"><span class="comment">		 * and in this case it is better to delay the delivery of 1-MSS</span></span><br><span class="line"><span class="comment">		 * packets and thus the corresponding ACK packet that would</span></span><br><span class="line"><span class="comment">		 * release the following packet.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果是GSO包则促使对端更快地把数据交给上层</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_skb_pcount(skb) &gt; <span class="number">1</span>)</span><br><span class="line">			tcb-&gt;tcp_flags |= TCPHDR_PSH;</span><br><span class="line">	&#125;</span><br><span class="line">	tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We set skb-&gt;ooo_okay to one if this packet can select</span></span><br><span class="line"><span class="comment">	 * a different TX queue than prior packets of this flow,</span></span><br><span class="line"><span class="comment">	 * to avoid self inflicted reorders.</span></span><br><span class="line"><span class="comment">	 * The &#x27;other&#x27; queue decision is based on current cpu number</span></span><br><span class="line"><span class="comment">	 * if XPS is enabled, or sk-&gt;sk_txhash otherwise.</span></span><br><span class="line"><span class="comment">	 * We can switch to another (and better) queue if:</span></span><br><span class="line"><span class="comment">	 * 1) No packet with payload is in qdisc/device queues.</span></span><br><span class="line"><span class="comment">	 *    Delays in TX completion can defeat the test</span></span><br><span class="line"><span class="comment">	 *    even if packets were already sent.</span></span><br><span class="line"><span class="comment">	 * 2) Or rtx queue is empty.</span></span><br><span class="line"><span class="comment">	 *    This mitigates above case if ACK packets for</span></span><br><span class="line"><span class="comment">	 *    all prior packets were already processed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//是否容许这个 skb 选择和前面不同的 TX queue，协议栈几乎没包，或者重传队列为空</span></span><br><span class="line">	skb-&gt;ooo_okay = sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>) ||</span><br><span class="line">			tcp_rtx_queue_empty(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we had to use memory reserve to allocate this skb,</span></span><br><span class="line"><span class="comment">	 * this might cause drops if packet is looped back :</span></span><br><span class="line"><span class="comment">	 * Other socket might not have SOCK_MEMALLOC.</span></span><br><span class="line"><span class="comment">	 * Packets not looped back do not care about pfmemalloc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb-&gt;pfmemalloc = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	skb_push(skb, tcp_header_size);</span><br><span class="line">	skb_reset_transport_header(skb);</span><br><span class="line">	<span class="comment">//清除之前的 skb-&gt;sk 等 owner 信息</span></span><br><span class="line">	skb_orphan(skb);</span><br><span class="line">	skb-&gt;sk = sk;</span><br><span class="line">	<span class="comment">//是否是纯ack，后者析构中会判断TSQ并设置 调度TSQ</span></span><br><span class="line">	skb-&gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree;</span><br><span class="line">	<span class="comment">//增加协议栈使用的内存</span></span><br><span class="line">	refcount_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line">	<span class="comment">///标识路由是否需要验证，收到ack的地方会置位</span></span><br><span class="line">	skb_set_dst_pending_confirm(skb, sk-&gt;sk_dst_pending_confirm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">	<span class="comment">//设置tcp头部字段</span></span><br><span class="line">	th = (<span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line">	th-&gt;source		= inet-&gt;inet_sport;</span><br><span class="line">	th-&gt;dest		= inet-&gt;inet_dport;</span><br><span class="line">	th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">	th-&gt;ack_seq		= htonl(rcv_nxt);</span><br><span class="line">	*(((__be16 *)th) + <span class="number">6</span>)	= htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">					tcb-&gt;tcp_flags);</span><br><span class="line"></span><br><span class="line">	th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">	th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">	<span class="comment">//urg 几乎不会使用吧</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">			th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">			th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//GSO的类型</span></span><br><span class="line">	skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line">	<span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">	<span class="comment">//注意这里算的通告给对端的窗口大小</span></span><br><span class="line">		th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">		tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">		 * is never scaled.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		th-&gt;window	= htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置tcp选项</span></span><br><span class="line">	tcp_options_write(th, tp, &amp;opts);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">	<span class="comment">/* Calculate the MD5 hash, as we have all we need now */</span></span><br><span class="line">	<span class="keyword">if</span> (md5) &#123;</span><br><span class="line">		sk_gso_disable(sk);</span><br><span class="line">		tp-&gt;af_specific-&gt;calc_md5_hash(opts.hash_location,</span><br><span class="line">					       md5, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BPF prog is the last one writing header option */</span></span><br><span class="line">	<span class="comment">//bpf相关</span></span><br><span class="line">	bpf_skops_write_hdr_opt(sk, skb, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;opts);</span><br><span class="line">	<span class="comment">//计算校验和，注意这里只计算伪首部</span></span><br><span class="line">	INDIRECT_CALL_INET(icsk-&gt;icsk_af_ops-&gt;send_check,</span><br><span class="line">			   tcp_v6_send_check, tcp_v4_send_check,</span><br><span class="line">			   sk, skb);</span><br><span class="line">	<span class="comment">//处理快速ack</span></span><br><span class="line">	<span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">		tcp_event_ack_sent(sk, rcv_nxt);</span><br><span class="line">	<span class="comment">//存在负载</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">		tcp_event_data_sent(tp, sk);</span><br><span class="line">		tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">		tp-&gt;bytes_sent += skb-&gt;len - tcp_header_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">		TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">			      tcp_skb_pcount(skb));</span><br><span class="line">	<span class="comment">//累计发出去的段数</span></span><br><span class="line">	tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">	<span class="comment">//选怎发送队列用到</span></span><br><span class="line">	skb_set_hash_from_sk(skb, sk);</span><br><span class="line">	<span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">	<span class="comment">//把段数和mss给到skb</span></span><br><span class="line">	skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">	skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Leave earliest departure time in skb-&gt;tstamp (skb-&gt;skb_mstamp_ns) */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">	<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm),</span><br><span class="line">			       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet6_skb_parm)));</span><br><span class="line">	<span class="comment">//设置一个时间戳</span></span><br><span class="line">	tcp_add_tx_delay(skb, tp);</span><br><span class="line">	<span class="comment">//向ip层发送数据包</span></span><br><span class="line">	err = INDIRECT_CALL_INET(icsk-&gt;icsk_af_ops-&gt;queue_xmit,</span><br><span class="line">				 inet6_csk_xmit, ip_queue_xmit,</span><br><span class="line">				 sk, skb, &amp;inet-&gt;cork.fl);</span><br><span class="line">	<span class="comment">//如果本地发包失败了，则进入显示拥塞状态</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(err &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		tcp_enter_cwr(sk);</span><br><span class="line">		err = net_xmit_eval(err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!err &amp;&amp; oskb) &#123;</span><br><span class="line">		<span class="comment">//更新pacing相关和rack相关用到的时间</span></span><br><span class="line">		tcp_update_skb_after_send(sk, oskb, prior_wstamp);</span><br><span class="line">		<span class="comment">//更新bbr用到的字段</span></span><br><span class="line">		tcp_rate_skb_sent(sk, oskb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__tcp_transmit_skb</code>中首先将<code>tp</code>的时间戳字段给到<code>skb</code>(TC可能会用到？）如果这个数据包需要<code>clone</code>（重传路径需要）则<code>clone</code>这个数据包，之后构建数据包的选项字段，这里其实就是把<code>tp</code>的选项字段拷贝到<code>tcp_out_options</code>中，这里不做分析。</p>
<p>接下来计算数据包的头部长度，并设置<code>ooo_okay</code>(决定是否可以重新选择TX队列)，当协议栈没有数据包，或者重传队列为空时，选择队列的时候可以重新计算使用哪个硬件队列。</p>
<p>之后设置数据包传输的头的指针，并设置<code>skb</code>与当前<code>sk</code>相关联，设置<code>skb</code>的析构函数，<strong>这里注意，如果数据包存在负载，则析构函数中会包括调度TSQ机制的逻辑，当网卡驱动释放数据包时，如果TSQ被置位(<code>tcp_write_xmit</code>中)则会进行调度。</strong></p>
<p>最后设置<code>tcp</code>头部的各个字段，<strong>这里最关键的是调用</strong><code>tcp_select_window</code><strong>计算</strong>(<strong>不是syn包的情况才会调用，这里可以发现syn包是没有窗口缩放的</strong>)通告给对端窗口的计算逻辑，<code>tcp_select_window</code>具体逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u16 <span class="title function_">tcp_select_window</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	u32 old_win = tp-&gt;rcv_wnd;</span><br><span class="line">	u32 cur_win, new_win;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make the window 0 if we failed to queue the data because we</span></span><br><span class="line"><span class="comment">	 * are out of memory. The window is temporary, so we don&#x27;t store</span></span><br><span class="line"><span class="comment">	 * it on the socket.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//内存紧张了，直接通告0窗口</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(inet_csk(sk)-&gt;icsk_ack.pending &amp; ICSK_ACK_NOMEM))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//剩余的窗口空间</span></span><br><span class="line">	cur_win = tcp_receive_window(tp);</span><br><span class="line">	<span class="comment">//计算新窗口</span></span><br><span class="line">	new_win = __tcp_select_window(sk);</span><br><span class="line">	<span class="comment">//新窗口比当前窗口还小</span></span><br><span class="line">	<span class="keyword">if</span> (new_win &lt; cur_win) &#123; </span><br><span class="line">		<span class="comment">/* Danger Will Robinson!</span></span><br><span class="line"><span class="comment">		 * Don&#x27;t update rcv_wup/rcv_wnd here or else</span></span><br><span class="line"><span class="comment">		 * we will not be able to advertise a zero</span></span><br><span class="line"><span class="comment">		 * window in time.  --DaveM</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Relax Will Robinson.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//是否允许 shrink 通常是false吧</span></span><br><span class="line">		<span class="keyword">if</span> (!READ_ONCE(net-&gt;ipv4.sysctl_tcp_shrink_window) || !tp-&gt;rx_opt.rcv_wscale) &#123;</span><br><span class="line">			<span class="comment">/* Never shrink the offered window */</span></span><br><span class="line">			<span class="keyword">if</span> (new_win == <span class="number">0</span>) <span class="comment">//实在是太小了</span></span><br><span class="line">				NET_INC_STATS(net, LINUX_MIB_TCPWANTZEROWINDOWADV);</span><br><span class="line">			new_win = ALIGN(cur_win, <span class="number">1</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale);<span class="comment">//保持窗口大小不变基于当前剩余窗口cur_win</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通告窗口的大小</span></span><br><span class="line">	tp-&gt;rcv_wnd = new_win;</span><br><span class="line">	<span class="comment">//记录本次更新窗口的序号</span></span><br><span class="line">	tp-&gt;rcv_wup = tp-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure we do not exceed the maximum possible</span></span><br><span class="line"><span class="comment">	 * scaled window.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//限制最大窗口</span></span><br><span class="line">	<span class="keyword">if</span> (!tp-&gt;rx_opt.rcv_wscale &amp;&amp;</span><br><span class="line">	    READ_ONCE(net-&gt;ipv4.sysctl_tcp_workaround_signed_windows))</span><br><span class="line">		new_win = min(new_win, MAX_TCP_WINDOW);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		new_win = min(new_win, (<span class="number">65535U</span> &lt;&lt; tp-&gt;rx_opt.rcv_wscale)); <span class="comment">//启用 wscale 时</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RFC1323 scaling applied */</span></span><br><span class="line">	new_win &gt;&gt;= tp-&gt;rx_opt.rcv_wscale; <span class="comment">//变成缩放后的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we advertise zero window, disable fast path. */</span></span><br><span class="line">	<span class="keyword">if</span> (new_win == <span class="number">0</span>) &#123;</span><br><span class="line">		tp-&gt;pred_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (old_win)</span><br><span class="line">			NET_INC_STATS(net, LINUX_MIB_TCPTOZEROWINDOWADV);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_win == <span class="number">0</span>) &#123;</span><br><span class="line">		NET_INC_STATS(net, LINUX_MIB_TCPFROMZEROWINDOWADV);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> new_win;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/07/tcp%E5%8F%91%E5%8C%85tcp_transmit_skb/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/30/tcp_write_xmit(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-30 22:00:00 / 修改时间：22:33:17" itemprop="dateCreated datePublished" datetime="2025-11-30T22:00:00+08:00">2025-11-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/30/tcp_write_xmit(%E4%B8%89)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit</code>中判断完是否会由于<code>nagle</code>算法和<code>tso</code>推迟发送后接下来会基于对端窗口和<code>nagle</code>算法调用<code>tcp_mss_split_point</code>计算一次发包的最大长度（这个值在下面会和<code>skb</code>的<code>len</code>比较，如果小于<code>len</code>就会拆包）具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">tcp_mss_split_point</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> <span class="type">int</span> mss_now,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> <span class="type">int</span> max_segs,</span></span><br><span class="line"><span class="params">					<span class="type">int</span> nonagle)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	u32 partial, needed, window, max_len;</span><br><span class="line"></span><br><span class="line">	window = tcp_wnd_end(tp) - TCP_SKB_CB(skb)-&gt;seq; <span class="comment">//接收窗口剩余空间</span></span><br><span class="line">	max_len = mss_now * max_segs;					<span class="comment">//这里是cwnd</span></span><br><span class="line">	<span class="comment">//如果小于可用窗口的大小，且不是最后一个数据包，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (likely(max_len &lt;= window &amp;&amp; skb != tcp_write_queue_tail(sk)))</span><br><span class="line">		<span class="keyword">return</span> max_len;</span><br><span class="line">	<span class="comment">//计算实际需要长度</span></span><br><span class="line">	needed = min(skb-&gt;len, window);</span><br><span class="line">	<span class="comment">//最大长度检查</span></span><br><span class="line">	<span class="keyword">if</span> (max_len &lt;= needed)</span><br><span class="line">		<span class="keyword">return</span> max_len;</span><br><span class="line">	<span class="comment">//计算最后一段是否是不完整的 MSS</span></span><br><span class="line">	partial = needed % mss_now;</span><br><span class="line">	<span class="comment">/* If last segment is not a full MSS, check if Nagle rules allow us</span></span><br><span class="line"><span class="comment">	 * to include this last segment in this skb.</span></span><br><span class="line"><span class="comment">	 * Otherwise, we&#x27;ll split the skb at last MSS boundary</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//nagle算法检查</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_nagle_check(partial != <span class="number">0</span>, tp, nonagle))</span><br><span class="line">		<span class="keyword">return</span> needed - partial;</span><br><span class="line">	<span class="comment">//返回实际需要的长度</span></span><br><span class="line">	<span class="keyword">return</span> needed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_mss_split_point</code><strong>首先计算对端接收窗口的剩余空间，然后计算拥塞窗口剩余空间</strong>，<strong>如果拥塞窗口大小小于对端通告窗口大小，且不是最后一个数据包，直接返回拥塞窗口大小，表示直接发送一个大包，注意通常都走这里</strong>。</p>
<p>否则需要计算真正可发送的长度（受窗口限制），实际可发送最大长度&#x3D; min(当前包长度, 对端窗口剩余) 如果这个值大于拥塞窗口的大小，那就发送拥塞窗口大小的长度，否则计算最后没有对齐的一部分的大小，并进行<code>nagle</code>算法的判断。如果需要 Nagle则返回 <code>needed - partial</code></p>
<p>上述计算完成可以发送的大小后，则需要和当前数据包的长度进行比较，如果数据包的长度超过了上述计算的长度，则<strong>需要调用<code>tso_fragment</code>在四层就进行分段</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tso_fragment</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nlen = skb-&gt;len - len; <span class="comment">//新包的长度（剩余部分）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">	u8 flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All of a TSO frame must be composed of paged data.  */</span></span><br><span class="line">	<span class="comment">//这里很重要，负载必须要在非线性部分</span></span><br><span class="line">	DEBUG_NET_WARN_ON_ONCE(skb-&gt;len != skb-&gt;data_len);</span><br><span class="line">	<span class="comment">//申请一个数据包</span></span><br><span class="line">	buff = tcp_stream_alloc_skb(sk, gfp, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!buff))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	skb_copy_decrypted(buff, skb);</span><br><span class="line">	mptcp_skb_ext_copy(buff, skb);</span><br><span class="line">	<span class="comment">//更新内存记账 </span></span><br><span class="line">	sk_wmem_queued_add(sk, buff-&gt;truesize);</span><br><span class="line">	sk_mem_charge(sk, buff-&gt;truesize);</span><br><span class="line">	buff-&gt;truesize += nlen;</span><br><span class="line">	skb-&gt;truesize -= nlen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Correct the sequence numbers. */</span></span><br><span class="line">	<span class="comment">//设置序列号</span></span><br><span class="line">	TCP_SKB_CB(buff)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq + len;</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;end_seq = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PSH and FIN should only be set in the second packet. */</span></span><br><span class="line">	<span class="comment">//设置标志位</span></span><br><span class="line">	flags = TCP_SKB_CB(skb)-&gt;tcp_flags;</span><br><span class="line">	TCP_SKB_CB(skb)-&gt;tcp_flags = flags &amp; ~(TCPHDR_FIN | TCPHDR_PSH);</span><br><span class="line">	TCP_SKB_CB(buff)-&gt;tcp_flags = flags;</span><br><span class="line"></span><br><span class="line">	tcp_skb_fragment_eor(skb, buff);</span><br><span class="line">	<span class="comment">//真正的分割数据包</span></span><br><span class="line">	skb_split(skb, buff, len);</span><br><span class="line">	tcp_fragment_tstamp(skb, buff);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fix up tso_factor for both original and new SKB.  */</span></span><br><span class="line">	<span class="comment">//重新计算GSO信息</span></span><br><span class="line">	tcp_set_skb_tso_segs(skb, mss_now);</span><br><span class="line">	tcp_set_skb_tso_segs(buff, mss_now);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Link BUFF into the send queue. */</span></span><br><span class="line">	__skb_header_release(buff);</span><br><span class="line">	<span class="comment">//新 SKB 插入到原 SKB 之后的发送队列中！</span></span><br><span class="line">	tcp_insert_write_queue_after(skb, buff, sk, TCP_FRAG_IN_WRITE_QUEUE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tso_fragment</code>的逻辑中上来就先判断判断负载是否都只存在于非线性部分，<strong>这里就是数据包为什么需要用<code>page</code>来管理的关键，当需要拆分数据包时，仅通过操作指针就可以完成！</strong></p>
<p><code>tso_fragment</code>中首先申请数据包，之后更新内存记账等相关字段，并设置当前数据包的序列号和标志位，调用<code>skb_split</code>完成执行 SKB 数据分页拆分，调用<code>tcp_set_skb_tso_segs</code>重新设置GSO字段，之后将新 <code>skb</code> 插入到原 <code>skb</code> 之后的发送队列中，更新GSO字段的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_set_skb_tso_segs</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">unsigned</span> <span class="type">int</span> mss_now)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置tcp_gso_size 和gso_segs</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt;= mss_now) &#123;</span><br><span class="line">		<span class="comment">/* Avoid the costly divide in the normal</span></span><br><span class="line"><span class="comment">		 * non-TSO case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//设置段数为1</span></span><br><span class="line">		tcp_skb_pcount_set(skb, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//设置gso size</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_gso_size = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tcp_skb_pcount_set(skb, DIV_ROUND_UP(skb-&gt;len, mss_now)); <span class="comment">//设置有多少个段</span></span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_gso_size = mss_now; <span class="comment">//设置每个段有多少个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成数据包的拆分后(如果需要拆分)，则**接下来会判断是否因TSQ机制(限制单个套接字占用协议栈过多资源)，**暂停发送，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/30/tcp_write_xmit(%E4%B8%89)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/27/tcp_write_xmit(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-27 22:00:00 / 修改时间：23:23:28" itemprop="dateCreated datePublished" datetime="2025-11-27T22:00:00+08:00">2025-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit</code>在进入<code>while</code>循环遍历发送数据包之前，首先计算<code>max_segs</code>的大小，这里需要注意，<code>tcp_sendmsg_locked</code>中只是尽可能的将用户数据<code>copy</code>放到一个<code>skb</code>中，而接下来的工作是真正决定是否能发送，能发送多少。</p>
<p>首先调用<code>tcp_tso_segs</code>计算当前数据包的最大段数(<code>max_segs</code>根据<code>rtt</code>计算)，最大段数和当前的<code>mss</code>决定了一次<code>while</code>循环最多能发送多少数据，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">tcp_tso_segs</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_congestion_ops</span> *<span class="title">ca_ops</span> =</span> inet_csk(sk)-&gt;icsk_ca_ops;</span><br><span class="line">	u32 min_tso, tso_segs;</span><br><span class="line">	<span class="comment">//拥塞算法是否提供了钩子，bbr就提供了，否则使用默认的，通常为2 </span></span><br><span class="line">	min_tso = ca_ops-&gt;min_tso_segs ?</span><br><span class="line">			ca_ops-&gt;min_tso_segs(sk) :</span><br><span class="line">			READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_min_tso_segs);</span><br><span class="line">	<span class="comment">//根据rtt计算段数 </span></span><br><span class="line">	tso_segs = tcp_tso_autosize(sk, mss_now, min_tso);</span><br><span class="line">	<span class="keyword">return</span> <span class="type">min_t</span>(u32, tso_segs, sk-&gt;sk_gso_max_segs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>tcp_tso_segs</code>进一步调用<code>tcp_tso_autosize</code>根据<code>rtt</code>自适应调整段数的大小，具体代码如下所示：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">tcp_tso_autosize</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> min_tso_segs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bytes;</span><br><span class="line">	u32 r;</span><br><span class="line">	<span class="comment">//转换成每秒多少字节</span></span><br><span class="line">	bytes = sk-&gt;sk_pacing_rate &gt;&gt; READ_ONCE(sk-&gt;sk_pacing_shift);</span><br><span class="line">	<span class="comment">//基于rtt做调整，r可以理解为延迟的严重程度吧</span></span><br><span class="line">	r = tcp_min_rtt(tcp_sk(sk)) &gt;&gt; READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_tso_rtt_log);<span class="comment">//默认是9 标志512是一个合理的网络延迟变化粒度</span></span><br><span class="line">	<span class="keyword">if</span> (r &lt; BITS_PER_TYPE(sk-&gt;sk_gso_max_size))<span class="comment">//这是什么意思？</span></span><br><span class="line">		bytes += sk-&gt;sk_gso_max_size &gt;&gt; r; <span class="comment">//这里的意思就是延迟越大，max_size 越小</span></span><br><span class="line">	<span class="comment">//钳制</span></span><br><span class="line">	bytes = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, bytes, sk-&gt;sk_gso_max_size);</span><br><span class="line">	<span class="comment">//计算段数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">max_t</span>(u32, bytes / mss_now, min_tso_segs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码根据带宽估算和 <code>RTT</code> 动态决定 <code>GSO</code> 报文大小：<code>RTT</code> 越大网络越远，单个 <code>GSO</code>包越小；<code>RTT</code> 越小网络越近，<code>GSO</code>越大以减少 <code>CPU</code> 负载</p>
<p>计算最大段数之后之后进入主要流程，循环从队列头部中获取数据包。</p>
<p>首先调用<code>tcp_pacing_check</code>，判断是否可以立即发送数据包，<code>tcp_pacing_check</code>中首先判断是否需要<code>tcp</code>内部自己做<code>pacing</code>，下一个数据包要发送的时间小于等于当前的时钟（理想发包时间已经到了 ），则可以直接发送，不需要启动定时器，否则表示时间还没有到，返回<code>true</code>表示不立即发送，<strong>注意：这里启动了<code>pacing</code>定时器</strong>，上述具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_pacing_check</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//sch_fq 开启这个就会返回false，表示不需要tcp内部自己pacing ，反之，如果为brr 会继续向下执行</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_needs_internal_pacing(sk))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//下一个数据包要发送的时间小于等于当前的时钟，则可以直接发送，不需要启动定时器</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;tcp_wstamp_ns &lt;= tp-&gt;tcp_clock_cache)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//如果定时器还没在排队，就启动一个pacing定时器 如果不能发送的情况 这里用软中断上下文去发包</span></span><br><span class="line">	<span class="keyword">if</span> (!hrtimer_is_queued(&amp;tp-&gt;pacing_timer)) &#123;</span><br><span class="line">		hrtimer_start(&amp;tp-&gt;pacing_timer,</span><br><span class="line">			      ns_to_ktime(tp-&gt;tcp_wstamp_ns),</span><br><span class="line">			      HRTIMER_MODE_ABS_PINNED_SOFT);</span><br><span class="line">		sock_hold(sk);<span class="comment">//这里引用计数++，防止socket被提前释放</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以发送，则调用<code>tcp_init_tso_segs</code>根据当前数据包的总长度和<code>mss</code>计算当前数据包的段数，这里注意上面是根据<code>rtt</code>计算最大的段数，这里计算的是当前数据包的段数，不矛盾，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/27/tcp_write_xmit(%E4%BA%8C)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/25/tcp_write_xmit(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/" class="post-title-link" itemprop="url">TCP输出 tcp_write_xmit（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-25 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-25T22:00:00+08:00">2025-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-26 21:43:00" itemprop="dateModified" datetime="2025-11-26T21:43:00+08:00">2025-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/25/tcp_write_xmit(%E4%B8%80)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_write_xmit()</code> 是 TCP 协议栈中负责真正“把待发送数据从发送队列写到网络上”的核心调度函数，它<strong>依据拥塞窗口、接收窗口、Nagle、TSO&#x2F;GSO、 pacing、MTU 探测等策略，决定是否发送、如何发送以及发送多少数据</strong></p>
<p><strong>注意：除了进程上下文中通过<code>push_one</code>, <code>__tcp_push_pending_frames</code>, <code>tcp_push</code>会调用<code>tcp_write_xmit</code>发送报文，软中段上下文中，<code>TLP</code>定时器到期，<code>TSQ</code>机制被触发，或者<code>tcp_data_snd_check</code>等地方也会调用改接口尝试发送数据包。</strong></p>
<p><code>tcp_write_xmit</code>具体逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_write_xmit</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">int</span> nonagle,</span></span><br><span class="line"><span class="params">			   <span class="type">int</span> push_one, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tso_segs, sent_pkts;</span><br><span class="line">	<span class="type">int</span> cwnd_quota;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_cwnd_limited = <span class="literal">false</span>, is_rwnd_limited = <span class="literal">false</span>;</span><br><span class="line">	u32 max_segs;</span><br><span class="line"></span><br><span class="line">	sent_pkts = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//更新两个时间戳</span></span><br><span class="line">	tcp_mstamp_refresh(tp);</span><br><span class="line">	<span class="keyword">if</span> (!push_one) &#123;</span><br><span class="line">		<span class="comment">/* Do MTU probing. */</span></span><br><span class="line">		<span class="comment">//是否需要进行tcp的mtu探</span></span><br><span class="line">		result = tcp_mtu_probe(sk);</span><br><span class="line">		<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			sent_pkts = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据rtt拥塞算法等计算段数 </span></span><br><span class="line">	max_segs = tcp_tso_segs(sk, mss_now);</span><br><span class="line">	<span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tp-&gt;repair) &amp;&amp; tp-&gt;repair_queue == TCP_SEND_QUEUE) &#123;</span><br><span class="line">			<span class="comment">/* &quot;skb_mstamp_ns&quot; is used as a start point for the retransmit timer */</span></span><br><span class="line">			tp-&gt;tcp_wstamp_ns = tp-&gt;tcp_clock_cache;</span><br><span class="line">			skb_set_delivery_time(skb, tp-&gt;tcp_wstamp_ns, <span class="literal">true</span>);</span><br><span class="line">			list_move_tail(&amp;skb-&gt;tcp_tsorted_anchor, &amp;tp-&gt;tsorted_sent_queue);</span><br><span class="line">			tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">			<span class="keyword">goto</span> repair; <span class="comment">/* Skip network transmission */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//根据发送速率计算是否可以立即发送这里可能会直接break</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_pacing_check(sk))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//根据mss计算每个skb有多少个段</span></span><br><span class="line">		tso_segs = tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">		BUG_ON(!tso_segs);</span><br><span class="line">		<span class="comment">//计算拥塞窗口的大小</span></span><br><span class="line">		cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">		<span class="keyword">if</span> (!cwnd_quota) &#123;</span><br><span class="line">			<span class="keyword">if</span> (push_one == <span class="number">2</span>) <span class="comment">//这里表示的是TLP探测包，必须能发出去</span></span><br><span class="line">				<span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">				cwnd_quota = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">//拥塞窗口不够用了，直接返回</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//是否超出了对端窗口的边界，如果超出了则设置标志位</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) &#123;</span><br><span class="line">			is_rwnd_limited = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//是否是一个小包</span></span><br><span class="line">		<span class="keyword">if</span> (tso_segs == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否因为nagle而不发送数据包，注意这里unlikely的</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!tcp_nagle_test(tp, skb, mss_now,</span><br><span class="line">			<span class="comment">//如果不是最后一个数据包，就立即推送，合理 因为不能然后面的包不发吧</span></span><br><span class="line">						     (tcp_skb_is_last(sk, skb) ? </span><br><span class="line">						      nonagle : TCP_NAGLE_PUSH))))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果当前数据包有多个段，且不是发送一个数据包的情况下，判断是否由于tso 推迟发送</span></span><br><span class="line">			<span class="keyword">if</span> (!push_one &amp;&amp;</span><br><span class="line">			    tcp_tso_should_defer(sk, skb, &amp;is_cwnd_limited,</span><br><span class="line">						 &amp;is_rwnd_limited, max_segs))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		limit = mss_now;</span><br><span class="line">		<span class="comment">//多个段的情况</span></span><br><span class="line">		<span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">			<span class="comment">//基于对端窗口和nagle算法，根据对端窗口和拥塞窗口 返回的是实际需要的长度，注意这里是拥塞状态也直接发送了</span></span><br><span class="line">			limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">						    <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">							  cwnd_quota,  <span class="comment">//拥塞窗口的大小</span></span><br><span class="line">							  max_segs),  <span class="comment">//最大的段数，与数据包无关</span></span><br><span class="line">						    nonagle);</span><br><span class="line">		<span class="comment">//如果数据包的长度大于了窗口的限制，那这里要把直接封装的数据包拆分了</span></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">		    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp))) <span class="comment">//这里其实就是为什么负载用页去管理的原因！！！</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//因为TSQ机制直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_small_queue_check(sk, skb, <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Argh, we hit an empty skb(), presumably a thread</span></span><br><span class="line"><span class="comment">		 * is sleeping in sendmsg()/sk_stream_wait_memory().</span></span><br><span class="line"><span class="comment">		 * We do not want to send a pure-ack packet and have</span></span><br><span class="line"><span class="comment">		 * a strange looking rtx queue with empty packet(s).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//空包</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//真正的发送数据包</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">repair:</span><br><span class="line">		<span class="comment">/* Advance the send_head.  This one is sent out.</span></span><br><span class="line"><span class="comment">		 * This call will increment packets_out.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//更新下一个待发送的序列号 ，加入重传队列</span></span><br><span class="line">		tcp_event_new_data_sent(sk, skb);</span><br><span class="line">		<span class="comment">//计算发送小包序列号，nagle算法会设置</span></span><br><span class="line">		tcp_minshall_update(tp, mss_now, skb);</span><br><span class="line">		sent_pkts += tcp_skb_pcount(skb); <span class="comment">//计算发出去的段数</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (push_one)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//更新各个阶段的时间</span></span><br><span class="line">	<span class="keyword">if</span> (is_rwnd_limited)</span><br><span class="line">		tcp_chrono_start(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tcp_chrono_stop(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">	<span class="comment">//拥塞窗口受限</span></span><br><span class="line">	is_cwnd_limited |= (tcp_packets_in_flight(tp) &gt;= tcp_snd_cwnd(tp));</span><br><span class="line">	<span class="keyword">if</span> (likely(sent_pkts || is_cwnd_limited))</span><br><span class="line">		tcp_cwnd_validate(sk, is_cwnd_limited);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(sent_pkts)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tcp_in_cwnd_reduction(sk))</span><br><span class="line">			tp-&gt;prr_out += sent_pkts;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Send one loss probe per tail loss episode. */</span></span><br><span class="line">		<span class="comment">//激活tlp定时器，如果等于2表示已经激活过了</span></span><br><span class="line">		<span class="keyword">if</span> (push_one != <span class="number">2</span>)</span><br><span class="line">			tcp_schedule_loss_probe(sk, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !tp-&gt;packets_out &amp;&amp; !tcp_write_queue_empty(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要关注<code>tcp_write_xmit</code>中第三个参数和第四个参数：</p>
<p> <strong><code>nonagle</code> 用来控制是否绕过 Nagle 算法、是否允许立刻发送小包（例如 <code>TCP_NAGLE_OFF</code> 直接允许发送，<code>TCP_NAGLE_CORK</code> 则尽量攒包）；</strong><br> <strong><code>push_one</code> 则控制本次调用最多发送多少个报文，当为 <code>0</code> 时按正常逻辑尽量多发，当为 <code>1</code> 时最多只发一个报文，而当为 <code>2</code> 时可以临时忽略拥塞窗口限制强制发出去（典型用于 TLP 探测）。</strong></p>
<p><code>tcp_write_xmit</code>首先更新了时间戳字段，<code>bbr</code>算法或者<code>rto</code>计算中会用到。之后会调用<code>tcp_mtu_probe</code>判断是否需要进行MTU探测（只发送一个数据包的情况下肯定不探测了），<strong>注意这里是传输层面的MTU探测，区别于ICMP的MTU探测</strong>，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_mtu_probe</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">nskb</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">	<span class="type">int</span> probe_size;</span><br><span class="line">	<span class="type">int</span> size_needed;</span><br><span class="line">	<span class="type">int</span> copy, len;</span><br><span class="line">	<span class="type">int</span> mss_now;</span><br><span class="line">	<span class="type">int</span> interval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not currently probing/verifying,</span></span><br><span class="line"><span class="comment">	 * not in recovery,</span></span><br><span class="line"><span class="comment">	 * have enough cwnd, and</span></span><br><span class="line"><span class="comment">	 * not SACKing (the variable headers throw things off)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!icsk-&gt;icsk_mtup.enabled ||                 <span class="comment">//MTU 探测功能已启用 </span></span><br><span class="line">		   icsk-&gt;icsk_mtup.probe_size ||				   <span class="comment">//当前没有正在进行的探测</span></span><br><span class="line">		   inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open ||   <span class="comment">//TCP 连接处于 Open 状态</span></span><br><span class="line">		   tcp_snd_cwnd(tp) &lt; <span class="number">11</span> ||						   <span class="comment">//拥塞窗口足够大</span></span><br><span class="line">		   tp-&gt;rx_opt.num_sacks || tp-&gt;rx_opt.dsack))	   <span class="comment">//没有 SACK 数据</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use binary search for probe_size between tcp_mss_base,</span></span><br><span class="line"><span class="comment">	 * and current mss_clamp. if (search_high - search_low)</span></span><br><span class="line"><span class="comment">	 * smaller than a threshold, backoff from probing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//计算当前mss</span></span><br><span class="line">	mss_now = tcp_current_mss(sk);</span><br><span class="line">	<span class="comment">//二分查找计算探测的大小</span></span><br><span class="line">	probe_size = tcp_mtu_to_mss(sk, (icsk-&gt;icsk_mtup.search_high +</span><br><span class="line">				    icsk-&gt;icsk_mtup.search_low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//确认后面还有足够多的数据，否则可能就没法确认探测包了？</span></span><br><span class="line">	size_needed = probe_size + (tp-&gt;reordering + <span class="number">1</span>) * tp-&gt;mss_cache;</span><br><span class="line">	<span class="comment">//计算最大最小探测直接的差值</span></span><br><span class="line">	interval = icsk-&gt;icsk_mtup.search_high - icsk-&gt;icsk_mtup.search_low;</span><br><span class="line">	<span class="comment">/* When misfortune happens, we are reprobing actively,</span></span><br><span class="line"><span class="comment">	 * and then reprobe timer has expired. We stick with current</span></span><br><span class="line"><span class="comment">	 * probing process by not resetting search range to its orignal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//probesize太大 或者搜索区间已经小于系统配置的探测阈值</span></span><br><span class="line">	<span class="keyword">if</span> (probe_size &gt; tcp_mtu_to_mss(sk, icsk-&gt;icsk_mtup.search_high) ||</span><br><span class="line">	    interval &lt; READ_ONCE(net-&gt;ipv4.sysctl_tcp_probe_threshold)) &#123;</span><br><span class="line">		<span class="comment">/* Check whether enough time has elaplased for</span></span><br><span class="line"><span class="comment">		 * another round of probing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//根据时间判断是否需要更新探测的上限</span></span><br><span class="line">		tcp_mtu_check_reprobe(sk);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Have enough data in the send queue to probe? */</span></span><br><span class="line">	<span class="comment">//计算待发送的数据量，如果不足以探测，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;write_seq - tp-&gt;snd_nxt &lt; size_needed)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//对端通告的窗口太小，也直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;snd_wnd &lt; size_needed)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//计算是否超出了窗口的右边界</span></span><br><span class="line">	<span class="keyword">if</span> (after(tp-&gt;snd_nxt + size_needed, tcp_wnd_end(tp)))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do we need to wait to drain cwnd? With none in flight, don&#x27;t stall */</span></span><br><span class="line">	<span class="comment">//在途数据包大于拥塞窗口</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_packets_in_flight(tp) + <span class="number">2</span> &gt; tcp_snd_cwnd(tp)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!tcp_packets_in_flight(tp)) <span class="comment">//没有在途数据包？上面拥塞窗口很小？</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检查数据包是否可以合并</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_can_coalesce_send_queue_head(sk, probe_size))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re allowed to probe.  Build it now. */</span></span><br><span class="line">	<span class="comment">//申请一个skb</span></span><br><span class="line">	nskb = tcp_stream_alloc_skb(sk, GFP_ATOMIC, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!nskb)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* build the payload, and be prepared to abort if this fails. */</span></span><br><span class="line">	<span class="comment">//这里是将发送队列中的数据包，零拷贝的方式放到探测的数据包中</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_clone_payload(sk, nskb, probe_size)) &#123;</span><br><span class="line">		tcp_skb_tsorted_anchor_cleanup(nskb);</span><br><span class="line">		consume_skb(nskb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里要重新更新内存记账</span></span><br><span class="line">	sk_wmem_queued_add(sk, nskb-&gt;truesize);</span><br><span class="line">	sk_mem_charge(sk, nskb-&gt;truesize);</span><br><span class="line">	<span class="comment">//取出队列中的地一个数据包</span></span><br><span class="line">	skb = tcp_send_head(sk);</span><br><span class="line">	skb_copy_decrypted(nskb, skb);</span><br><span class="line">	mptcp_skb_ext_copy(nskb, skb);</span><br><span class="line">	<span class="comment">//设置数据包的序列号和ack标志</span></span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;seq = TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;end_seq = TCP_SKB_CB(skb)-&gt;seq + probe_size;</span><br><span class="line">	TCP_SKB_CB(nskb)-&gt;tcp_flags = TCPHDR_ACK;</span><br><span class="line">	<span class="comment">//插入队列头，并</span></span><br><span class="line">	tcp_insert_write_queue_before(nskb, skb, sk);</span><br><span class="line">	tcp_highest_sack_replace(sk, skb, nskb);</span><br><span class="line"></span><br><span class="line">	len = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//把被和合并的小包unlink</span></span><br><span class="line">	tcp_for_write_queue_from_safe(skb, next, sk) &#123;</span><br><span class="line">		copy = <span class="type">min_t</span>(<span class="type">int</span>, skb-&gt;len, probe_size - len);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len &lt;= copy) &#123;</span><br><span class="line">			<span class="comment">/* We&#x27;ve eaten all the data from this skb.</span></span><br><span class="line"><span class="comment">			 * Throw it away. */</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags;</span><br><span class="line">			<span class="comment">/* If this is the last SKB we copy and eor is set</span></span><br><span class="line"><span class="comment">			 * we need to propagate it to the new skb.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;eor = TCP_SKB_CB(skb)-&gt;eor;</span><br><span class="line">			tcp_skb_collapse_tstamp(nskb, skb);</span><br><span class="line">			tcp_unlink_write_queue(skb, sk); <span class="comment">//从队列中摘下来</span></span><br><span class="line">			tcp_wmem_free_skb(sk, skb);		 <span class="comment">//释放数据包，更新内存记账 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">///处理部分skb的情况 调用__pskb_trim_head减枝</span></span><br><span class="line">			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags &amp;</span><br><span class="line">						   ~(TCPHDR_FIN|TCPHDR_PSH);</span><br><span class="line">			__pskb_trim_head(skb, copy);</span><br><span class="line">			tcp_set_skb_tso_segs(skb, mss_now); <span class="comment">//设置保留数据包的GSO相关字段</span></span><br><span class="line">			TCP_SKB_CB(skb)-&gt;seq += copy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len += copy;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt;= probe_size)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//初始化GSO字段信息</span></span><br><span class="line">	tcp_init_tso_segs(nskb, nskb-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We&#x27;re ready to send.  If this fails, the probe will</span></span><br><span class="line"><span class="comment">	 * be resegmented into mss-sized pieces by tcp_write_xmit().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!tcp_transmit_skb(sk, nskb, <span class="number">1</span>, GFP_ATOMIC)) &#123;</span><br><span class="line">		<span class="comment">/* Decrement cwnd here because we are sending</span></span><br><span class="line"><span class="comment">		 * effectively two packets. */</span></span><br><span class="line">		tcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - <span class="number">1</span>);<span class="comment">//更新拥塞窗口--</span></span><br><span class="line">		tcp_event_new_data_sent(sk, nskb);</span><br><span class="line"></span><br><span class="line">		icsk-&gt;icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb-&gt;len);<span class="comment">//记录mtu探测的相关字段</span></span><br><span class="line">		tp-&gt;mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)-&gt;seq;</span><br><span class="line">		tp-&gt;mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)-&gt;end_seq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_mtu_probe</code>中首先判断是否不需要进行MTU探测，如果MTU 探测功能已启用 ，<strong>当前没有正在进行的探测，TCP 连接处于 Open 状态，拥塞窗口足够大，没有 SACK 数据的情况下不需要探测</strong>，否则进入MTU探测的逻辑。</p>
<p>首先计算当前的<code>mss</code>，之后根据根据二分查找计算<code>probe_size</code>探测报文的大小，<strong>这里注意<code>search_high</code>和 <code>low</code>在<code>tcp_mtup_init</code>中会设置初始值</strong>，计算完成探测报文的大小后，<strong>会进一步确认后续数据是否足够数据确认的这个探测报文</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/25/tcp_write_xmit(%E4%B8%80)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/" class="post-title-link" itemprop="url">TCP输出tcp_sendmsg_locked（三）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-23 22:00:00" itemprop="dateCreated datePublished" datetime="2025-11-23T22:00:00+08:00">2025-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-11-25 21:34:57" itemprop="dateModified" datetime="2025-11-25T21:34:57+08:00">2025-11-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_sendmsg_locked</code>申请数据包成功并调用<code>tcp_skb_entail</code>将数据包入队后，接下来的任务就是将用户数据包<code>copy</code>到<code>skb</code>非线性部分中。</p>
<p>首先调用<code>sk_page_frag</code>从当前进程获取一个<code>page</code>，之后调用<code>sk_page_frag_refill</code>查看是否还有足够的空间可以使用，上述过程具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page_frag *<span class="title function_">sk_page_frag</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_use_task_frag)</span><br><span class="line">		<span class="keyword">return</span> &amp;current-&gt;task_frag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;sk-&gt;sk_frag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">sk_page_frag_refill</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> page_frag *pfrag)</span></span><br><span class="line">&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//是否有32字节可以写的空间</span></span><br><span class="line">	<span class="keyword">if</span> (likely(skb_page_frag_refill(<span class="number">32U</span>, pfrag, sk-&gt;sk_allocation)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//分配失败，进入内存压力</span></span><br><span class="line">	sk_enter_memory_pressure(sk);</span><br><span class="line">	<span class="comment">//减小发送缓冲区</span></span><br><span class="line">	sk_stream_moderate_sndbuf(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>skb_page_frag_refill</code>中会进一步判断拿到的页是否有32字节可写的空间，如果空间不够则会申请一个新的页，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">skb_page_frag_refill</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sz, <span class="keyword">struct</span> page_frag *pfrag, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pfrag-&gt;page) &#123;</span><br><span class="line">		<span class="keyword">if</span> (page_ref_count(pfrag-&gt;page) == <span class="number">1</span>) &#123; 	   <span class="comment">//只有自己在用</span></span><br><span class="line">			pfrag-&gt;offset = <span class="number">0</span>; 						 <span class="comment">//offset设置为0 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pfrag-&gt;offset + sz &lt;= pfrag-&gt;size) 		   <span class="comment">//别人在用，看空间是否够，如果够也直接返回了</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		put_page(pfrag-&gt;page);  					  <span class="comment">//不够，直接put掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//准备分配新页</span></span><br><span class="line">	pfrag-&gt;offset = <span class="number">0</span>; </span><br><span class="line">	<span class="comment">//这里通常不会走把</span></span><br><span class="line">	<span class="keyword">if</span> (SKB_FRAG_PAGE_ORDER &amp;&amp;</span><br><span class="line">	    !static_branch_unlikely(&amp;net_high_order_alloc_disable_key)) &#123;</span><br><span class="line">		<span class="comment">/* Avoid direct reclaim but allow kswapd to wake */</span></span><br><span class="line">		pfrag-&gt;page = alloc_pages((gfp &amp; ~__GFP_DIRECT_RECLAIM) |</span><br><span class="line">					  __GFP_COMP | __GFP_NOWARN |</span><br><span class="line">					  __GFP_NORETRY,</span><br><span class="line">					  SKB_FRAG_PAGE_ORDER);</span><br><span class="line">		<span class="keyword">if</span> (likely(pfrag-&gt;page)) &#123;</span><br><span class="line">			pfrag-&gt;size = PAGE_SIZE &lt;&lt; SKB_FRAG_PAGE_ORDER;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//分配一个page</span></span><br><span class="line">	pfrag-&gt;page = alloc_page(gfp);</span><br><span class="line">	<span class="keyword">if</span> (likely(pfrag-&gt;page)) &#123;</span><br><span class="line">		pfrag-&gt;size = PAGE_SIZE;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述获取到<code>page</code>后，进一步调用<code>skb_can_coalesce</code>判断当前获取到的页是否已经是<code>skb</code>管理的页，如果不是，且当前<code>skb</code>已将有17个非线性部分的页了，则直接重新申请<code>skb</code>同时设置<code>push</code>标志位，并将标记为不能合并（后续用于指导设置页的元数据)</p>
<p>判断是否可以合并的逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">skb_can_coalesce</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="keyword">struct</span> page *page, <span class="type">int</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb_zcopy(skb)) <span class="comment">//零拷贝 skb 不能合并</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (i) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">skb_frag_t</span> *frag = &amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>]; <span class="comment">//skb的最后一个页？</span></span><br><span class="line">		<span class="comment">//当前写入数据使用的 page 与最后的 frag 是同一物理页</span></span><br><span class="line">		<span class="keyword">return</span> page == skb_frag_page(frag) &amp;&amp;   <span class="comment">//判断是否是同一个页</span></span><br><span class="line">		       off == skb_frag_off(frag) + skb_frag_size(frag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述工作完成后，会计算当前获取的页还有头多少可以<code>copy</code>的空间，并调用<code>tcp_wmem_schedule</code>更新内存记账，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_wmem_schedule</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> copy)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> left;</span><br><span class="line">	<span class="comment">//判断是否达到全局的内存压力，如果还有足够发送空间，则直接允许这次请求</span></span><br><span class="line">	<span class="keyword">if</span> (likely(sk_wmem_schedule(sk, copy)))</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We could be in trouble if we have nothing queued.</span></span><br><span class="line"><span class="comment">	 * Use whatever is left in sk-&gt;sk_forward_alloc and tcp_wmem[0]</span></span><br><span class="line"><span class="comment">	 * to guarantee some progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//正常内存预算不够了 TCP 进入资源紧张状态</span></span><br><span class="line">	left = sock_net(sk)-&gt;ipv4.sysctl_tcp_wmem[<span class="number">0</span>] - sk-&gt;sk_wmem_queued;</span><br><span class="line">	<span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="comment">//最低保障区间还有空间，强制额外分配内存，这里可以看到每个sk最少可以用4k，没使用到4k的时候即使资源紧张也会强制调度</span></span><br><span class="line">		sk_forced_mem_schedule(sk, min(left, copy));</span><br><span class="line">	<span class="keyword">return</span> min(copy, sk-&gt;sk_forward_alloc); <span class="comment">//回真正允许写入的数据大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/23/tcp_sendmsg_locked(%E4%B8%89)/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangm</p>
  <div class="site-description" itemprop="description">协议栈源码学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '1c6PW2umhmoCGypfQhPNnfLk-gzGzoHsz',
      appKey     : 'nbVvMAfQXEdOeKD1tmvI3qrQ',
      placeholder: "畅所欲言!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://1c6pw2um.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
