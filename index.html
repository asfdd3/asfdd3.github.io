<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="协议栈源码学习">
<meta property="og:type" content="website">
<meta property="og:title" content="日拱一卒">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="日拱一卒">
<meta property="og:description" content="协议栈源码学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhangm">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日拱一卒</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/27/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/27/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-主动关闭（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-27 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-27T22:00:00+08:00">2026-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-26 23:37:46" itemprop="dateModified" datetime="2026-01-26T23:37:46+08:00">2026-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/27/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/27/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>tcp_time_wait</code>主要做了四件事，创建<code>tw</code>套接字，拷贝sk必要的字段到<code>tw sock</code>中，插入<code>ehash</code>中（完成<code>hashdance</code>），释放<code>sk</code>资源。</p>
<p>上述创建<code>tw</code>套接字的过程中设置了<code>tw</code>定时器的回调(注意并没有激活定时器)，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inet_timewait_sock *<span class="title function_">inet_twsk_alloc</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> inet_timewait_death_row *dr,</span></span><br><span class="line"><span class="params">					   <span class="type">const</span> <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_sock</span> *<span class="title">tw</span>;</span></span><br><span class="line">	<span class="comment">//是否超过了最大的tw套接字的数量</span></span><br><span class="line">	<span class="keyword">if</span> (refcount_read(&amp;dr-&gt;tw_refcount) - <span class="number">1</span> &gt;=</span><br><span class="line">	    READ_ONCE(dr-&gt;sysctl_max_tw_buckets))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//申请tw套接字</span></span><br><span class="line">	tw = kmem_cache_alloc(sk-&gt;sk_prot_creator-&gt;twsk_prot-&gt;twsk_slab,</span><br><span class="line">			      GFP_ATOMIC);</span><br><span class="line">	<span class="comment">//copy必要的字段</span></span><br><span class="line">	<span class="keyword">if</span> (tw) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line"></span><br><span class="line">		tw-&gt;tw_dr	    = dr;</span><br><span class="line">		<span class="comment">/* Give us an identity. */</span></span><br><span class="line">		tw-&gt;tw_daddr	    = inet-&gt;inet_daddr;</span><br><span class="line">		tw-&gt;tw_rcv_saddr    = inet-&gt;inet_rcv_saddr;</span><br><span class="line">		tw-&gt;tw_bound_dev_if = sk-&gt;sk_bound_dev_if;</span><br><span class="line">		tw-&gt;tw_tos	    = inet-&gt;tos;</span><br><span class="line">		tw-&gt;tw_num	    = inet-&gt;inet_num;</span><br><span class="line">		tw-&gt;tw_state	    = TCP_TIME_WAIT;</span><br><span class="line">		tw-&gt;tw_substate	    = state; <span class="comment">//这个状态很关键，用于区别是什么状态下收到的套接字</span></span><br><span class="line">		tw-&gt;tw_sport	    = inet-&gt;inet_sport;</span><br><span class="line">		tw-&gt;tw_dport	    = inet-&gt;inet_dport;</span><br><span class="line">		tw-&gt;tw_family	    = sk-&gt;sk_family;</span><br><span class="line">		tw-&gt;tw_reuse	    = sk-&gt;sk_reuse;</span><br><span class="line">		tw-&gt;tw_reuseport    = sk-&gt;sk_reuseport;</span><br><span class="line">		tw-&gt;tw_hash	    = sk-&gt;sk_hash;</span><br><span class="line">		tw-&gt;tw_ipv6only	    = <span class="number">0</span>;</span><br><span class="line">		tw-&gt;tw_transparent  = inet_test_bit(TRANSPARENT, sk);</span><br><span class="line">		tw-&gt;tw_prot	    = sk-&gt;sk_prot_creator;</span><br><span class="line">		atomic64_set(&amp;tw-&gt;tw_cookie, atomic64_read(&amp;sk-&gt;sk_cookie));</span><br><span class="line">		twsk_net_set(tw, sock_net(sk));</span><br><span class="line">		<span class="comment">//这里设置tw 定时器的回调</span></span><br><span class="line">		timer_setup(&amp;tw-&gt;tw_timer, tw_timer_handler, TIMER_PINNED);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Because we use RCU lookups, we should not set tw_refcnt</span></span><br><span class="line"><span class="comment">		 * to a non null value before everything is setup for this</span></span><br><span class="line"><span class="comment">		 * timewait socket.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		refcount_set(&amp;tw-&gt;tw_refcnt, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		__module_get(tw-&gt;tw_prot-&gt;owner);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重点关注<code>tw-&gt;tw_substate</code>状态的处理，这里区分了当前<code>tw sock</code> 是finwait2状态创建的还是<code>timewati</code>状态下创建的。当创建<code>tw</code>状态套接字插入到<code>ehash</code>中之后，后续收到的数据包都找到的是<code>tw</code>状态的<code>sk</code>并跳转到<code>tw</code>状态进行处理，具体代码逻辑如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	sk = __inet_lookup_skb(net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">			       skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">			       th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">process:</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)</span><br><span class="line">		<span class="keyword">goto</span> do_time_wait;</span><br><span class="line">	...</span><br><span class="line"><span class="comment">//tw状态的处理</span></span><br><span class="line">do_time_wait:</span><br><span class="line">	<span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb)) &#123;</span><br><span class="line">		drop_reason = SKB_DROP_REASON_XFRM_POLICY;</span><br><span class="line">		inet_twsk_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">		inet_twsk_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//决定怎么处理这个包</span></span><br><span class="line">	<span class="keyword">switch</span> (tcp_timewait_state_process(inet_twsk(sk), skb, th)) &#123;</span><br><span class="line">	<span class="comment">//允许重新开始三次握手</span></span><br><span class="line">	<span class="keyword">case</span> TCP_TW_SYN: &#123;</span><br><span class="line">		<span class="comment">//找到监听套接字</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> =</span> inet_lookup_listener(net,</span><br><span class="line">							net-&gt;ipv4.tcp_death_row.hashinfo,</span><br><span class="line">							skb, __tcp_hdrlen(th),</span><br><span class="line">							iph-&gt;saddr, th-&gt;source,</span><br><span class="line">							iph-&gt;daddr, th-&gt;dest,</span><br><span class="line">							inet_iif(skb),</span><br><span class="line">							sdif);</span><br><span class="line">		<span class="keyword">if</span> (sk2) &#123;</span><br><span class="line">			<span class="comment">//将tw套接字直接释放</span></span><br><span class="line">			inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">			sk = sk2;</span><br><span class="line">			tcp_v4_restore_cb(skb);</span><br><span class="line">			refcounted = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">goto</span> process;<span class="comment">//注意这里回到三次握手的处理中</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">/* to ACK */</span></span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_ACK:</span><br><span class="line">		<span class="comment">//对端重传fin，或者发了窗口外的数据包这里在回复一个ack，或者最后一个ack</span></span><br><span class="line">		tcp_v4_timewait_ack(sk, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_RST:</span><br><span class="line">		<span class="comment">//比如在finwait2阶段收到了syn包</span></span><br><span class="line">		tcp_v4_send_reset(sk, skb);</span><br><span class="line">		<span class="comment">//真正释放资源</span></span><br><span class="line">		inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">		<span class="keyword">goto</span> discard_it;</span><br><span class="line">	<span class="keyword">case</span> TCP_TW_SUCCESS:;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> discard_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code>到<code>timewait</code>处理逻辑后首先调用<code>tcp_timewait_state_process</code>根据返回值决定怎么处理这个数据包，<code>tcp_timewait_state_process</code>具体实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> tcp_tw_status</span><br><span class="line"><span class="title function_">tcp_timewait_state_process</span><span class="params">(<span class="keyword">struct</span> inet_timewait_sock *tw, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">			   <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_options_received</span> <span class="title">tmp_opt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_timewait_sock</span> *<span class="title">tcptw</span> =</span> tcp_twsk((<span class="keyword">struct</span> sock *)tw);</span><br><span class="line">	<span class="type">bool</span> paws_reject = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	tmp_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//如果存在时间戳，再通过PAWS机制判断是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;doff &gt; (<span class="keyword">sizeof</span>(*th) &gt;&gt; <span class="number">2</span>) &amp;&amp; tcptw-&gt;tw_ts_recent_stamp) &#123;</span><br><span class="line">		tcp_parse_options(twsk_net(tw), skb, &amp;tmp_opt, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tmp_opt.rcv_tsecr)</span><br><span class="line">				tmp_opt.rcv_tsecr -= tcptw-&gt;tw_ts_offset;</span><br><span class="line">			tmp_opt.ts_recent	= tcptw-&gt;tw_ts_recent;</span><br><span class="line">			tmp_opt.ts_recent_stamp	= tcptw-&gt;tw_ts_recent_stamp;</span><br><span class="line">			paws_reject = tcp_paws_reject(&amp;tmp_opt, th-&gt;rst);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果是finwait2状态下创建的套接字</span></span><br><span class="line">	<span class="keyword">if</span> (tw-&gt;tw_substate == TCP_FIN_WAIT2) &#123;</span><br><span class="line">		<span class="comment">/* Just repeat all the checks of tcp_rcv_state_process() */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Out of window, send ACK */</span></span><br><span class="line">		<span class="comment">//如果没有通过paws机制检查，或者超出了窗口则会回一个ack</span></span><br><span class="line">		<span class="keyword">if</span> (paws_reject ||</span><br><span class="line">		    !tcp_in_window(TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq,</span><br><span class="line">				   tcptw-&gt;tw_rcv_nxt,</span><br><span class="line">				   tcptw-&gt;tw_rcv_nxt + tcptw-&gt;tw_rcv_wnd))</span><br><span class="line">			<span class="keyword">return</span> tcp_timewait_check_oow_rate_limit(</span><br><span class="line">				tw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);</span><br><span class="line">		<span class="comment">//如果通过了检查携带rst，直接清除tw套接字释放资源</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line">			<span class="keyword">goto</span> kill;</span><br><span class="line">		<span class="comment">//TCP_FIN_WAIT2状态下收到syn包 同时syn包大于下一个待接收的序列号，则直接回rst</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;syn &amp;&amp; !before(TCP_SKB_CB(skb)-&gt;seq, tcptw-&gt;tw_rcv_nxt))</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_RST;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Dup ACK? */</span></span><br><span class="line">		<span class="comment">//没有ack标志位，或者是重复的ack</span></span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;ack ||</span><br><span class="line">		    !after(TCP_SKB_CB(skb)-&gt;end_seq, tcptw-&gt;tw_rcv_nxt) ||</span><br><span class="line">		    TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq) &#123;</span><br><span class="line">			inet_twsk_put(tw);</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_SUCCESS; <span class="comment">//外面默默丢弃了</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* New data or FIN. If new data arrive after half-duplex close,</span></span><br><span class="line"><span class="comment">		 * reset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//不是fin或者是新数据，直接回rst，这里是意味着finwait2就不能接对端继续发呆数据包吗？</span></span><br><span class="line">		<span class="comment">//注意可能是因为这里是tw套接字承载着finwait2</span></span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;fin ||</span><br><span class="line">		    TCP_SKB_CB(skb)-&gt;end_seq != tcptw-&gt;tw_rcv_nxt + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> TCP_TW_RST;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* FIN arrived, enter true time-wait state. */</span></span><br><span class="line">		<span class="comment">//走到这里表示收到了合法的fin包</span></span><br><span class="line">		tw-&gt;tw_substate	  = TCP_TIME_WAIT;</span><br><span class="line">		<span class="comment">//更新下一个待接收的序号</span></span><br><span class="line">		tcptw-&gt;tw_rcv_nxt = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			tcptw-&gt;tw_ts_recent_stamp = ktime_get_seconds();</span><br><span class="line">			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//注意这里是重新开始tw 计时</span></span><br><span class="line">		inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_ACK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Now real TIME-WAIT state.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	RFC 1122:</span></span><br><span class="line"><span class="comment">	 *	&quot;When a connection is [...] on TIME-WAIT state [...]</span></span><br><span class="line"><span class="comment">	 *	[a TCP] MAY accept a new SYN from the remote TCP to</span></span><br><span class="line"><span class="comment">	 *	reopen the connection directly, if it:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	(1)  assigns its initial sequence number for the new</span></span><br><span class="line"><span class="comment">	 *	connection to be larger than the largest sequence</span></span><br><span class="line"><span class="comment">	 *	number it used on the previous connection incarnation,</span></span><br><span class="line"><span class="comment">	 *	and</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	(2)  returns to TIME-WAIT state if the SYN turns out</span></span><br><span class="line"><span class="comment">	 *	to be an old duplicate&quot;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//正常timewait状态的处理，通过了检查如果是纯ack或者是rst</span></span><br><span class="line">	<span class="keyword">if</span> (!paws_reject &amp;&amp;</span><br><span class="line">	    (TCP_SKB_CB(skb)-&gt;seq == tcptw-&gt;tw_rcv_nxt &amp;&amp;</span><br><span class="line">	     (TCP_SKB_CB(skb)-&gt;seq == TCP_SKB_CB(skb)-&gt;end_seq || th-&gt;rst))) &#123;</span><br><span class="line">		<span class="comment">/* In window segment, it may be only reset or bare ack. */</span></span><br><span class="line">		<span class="comment">//如果收到了rst 直接释放资源</span></span><br><span class="line">		<span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line">			<span class="comment">/* This is TIME_WAIT assassination, in two flavors.</span></span><br><span class="line"><span class="comment">			 * Oh well... nobody has a sufficient solution to this</span></span><br><span class="line"><span class="comment">			 * protocol bug yet.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!READ_ONCE(twsk_net(tw)-&gt;ipv4.sysctl_tcp_rfc1337)) &#123;</span><br><span class="line">kill:</span><br><span class="line">				inet_twsk_deschedule_put(tw);</span><br><span class="line">				<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//重新开始定时器，因为可能是ack丢失了</span></span><br><span class="line">			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tmp_opt.saw_tstamp) &#123;</span><br><span class="line">			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;</span><br><span class="line">			tcptw-&gt;tw_ts_recent_stamp = ktime_get_seconds();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		inet_twsk_put(tw);</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Out of window segment.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   All the segments are ACKed immediately.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   The only exception is new SYN. We accept it, if it is</span></span><br><span class="line"><span class="comment">	   not old duplicate and we are not in danger to be killed</span></span><br><span class="line"><span class="comment">	   by delayed old duplicates. RFC check is that it has</span></span><br><span class="line"><span class="comment">	   newer sequence number works at rates &lt;40Mbit/sec.</span></span><br><span class="line"><span class="comment">	   However, if paws works, it is reliable AND even more,</span></span><br><span class="line"><span class="comment">	   we even may relax silly seq space cutoff.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   RED-PEN: we violate main RFC requirement, if this SYN will appear</span></span><br><span class="line"><span class="comment">	   old duplicate (i.e. we receive RST in reply to SYN-ACK),</span></span><br><span class="line"><span class="comment">	   we must return socket to time-wait state. It is not good,</span></span><br><span class="line"><span class="comment">	   but not fatal yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//窗口外的数据包，如果是纯syn包，注意这里会重新在外面找listne套接字</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;syn &amp;&amp; !th-&gt;rst &amp;&amp; !th-&gt;ack &amp;&amp; !paws_reject &amp;&amp;</span><br><span class="line">	    (after(TCP_SKB_CB(skb)-&gt;seq, tcptw-&gt;tw_rcv_nxt) ||<span class="comment">//序列号大于下一个待接收的</span></span><br><span class="line">	     (tmp_opt.saw_tstamp &amp;&amp;</span><br><span class="line">	      (s32)(tcptw-&gt;tw_ts_recent - tmp_opt.rcv_tsval) &lt; <span class="number">0</span>))) &#123;<span class="comment">//时间戳合理</span></span><br><span class="line">		u32 isn = tcptw-&gt;tw_snd_nxt + <span class="number">65535</span> + <span class="number">2</span>;<span class="comment">//必须大于旧连接的序列号</span></span><br><span class="line">		<span class="keyword">if</span> (isn == <span class="number">0</span>)</span><br><span class="line">			isn++;</span><br><span class="line">		TCP_SKB_CB(skb)-&gt;tcp_tw_isn = isn;</span><br><span class="line">		<span class="keyword">return</span> TCP_TW_SYN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由于PAWS拒绝</span></span><br><span class="line">	<span class="keyword">if</span> (paws_reject)</span><br><span class="line">		__NET_INC_STATS(twsk_net(tw), LINUX_MIB_PAWSESTABREJECTED);</span><br><span class="line">	<span class="comment">//没有携带rst，但是由于序列号被拒绝 会ack，但是限速</span></span><br><span class="line">	<span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line">		<span class="comment">/* In this case we must reset the TIMEWAIT timer.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If it is ACKless SYN it may be both old duplicate</span></span><br><span class="line"><span class="comment">		 * and new good SYN with random sequence number &lt;rcv_nxt.</span></span><br><span class="line"><span class="comment">		 * Do not reschedule in the last case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (paws_reject || th-&gt;ack)</span><br><span class="line">			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> tcp_timewait_check_oow_rate_limit(</span><br><span class="line">			tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);</span><br><span class="line">	&#125;</span><br><span class="line">	inet_twsk_put(tw);</span><br><span class="line">	<span class="keyword">return</span> TCP_TW_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_timewait_state_process</code>首先PAWS机制检查数据包是否合法，</p>
<p>如果当前的<code>tw</code>套接字是<code>fin_wait2</code>状态下创建的，具体处理情况如下所示：</p>
<ul>
<li>窗口外 &#x2F; PAWS 失 回 ACK（限速）</li>
<li>收到 RST 直接 <code>kill tw_sock</code></li>
<li>收到 SYN 且 seq 合法 → 回 RST</li>
<li>防止旧连接干扰新连接建立。</li>
<li>纯 ACK &#x2F; 重复 ACK  丢弃报文</li>
<li>如果不是 FIN，或者 FIN 位置不对 回RST</li>
<li>收到了和发<code>fin</code>真正进入<code>timewait</code>状态</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/27/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%94%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-主动关闭（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-26 22:00:00 / 修改时间：23:43:15" itemprop="dateCreated datePublished" datetime="2026-01-26T22:00:00+08:00">2026-01-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在TCP连接终止的过程中，主动关闭连接的一方会经历如下所示的四个状态：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ESTABLISHED</span><br><span class="line">    ↓ <span class="built_in">close</span>()</span><br><span class="line">FIN_WAIT_1</span><br><span class="line">    ↓ 收到 <span class="built_in">ACK</span>(对方确认FIN)</span><br><span class="line">FIN_WAIT_2</span><br><span class="line">    ↓ 收到 对方FIN</span><br><span class="line">TIME_WAIT   ← 核心</span><br><span class="line">    ↓ <span class="number">2MS</span>L</span><br><span class="line">CLOSED</span><br></pre></td></tr></table></figure>

<p>主动关闭方发送<code>fin</code>段之后会进入到FIN_WAIT_1状态，如果收到了<code>fin</code>的确认则状态迁移到FIN_WAIT_2，并有可能创建<code>tw</code>套接字（也有可能不创建，取决于用户配置，也取决于系统当前<code>tw</code>套接字数量），如果在FIN_WAIT_2状态下收到了对端的<code>fin</code>则会发送<code>ack</code>并启动TIME_WAIT定时器。<strong>TIME_WAIT状态存在的原因其实就一个，防止旧的连接干扰新的连接。</strong></p>
<p>由于主动关闭方发送<code>fin</code>段之后由于已经不是建立连接状态，因此接收到的数据包都有由<code>cp_rcv_state_process</code>处理，这里重点分析发送<code>fin</code>段之后进入FIN_WAIT_1状态，等待对端确认的逻辑，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcp_rcv_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1: &#123;</span><br><span class="line">		<span class="type">int</span> tmo;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (req)</span><br><span class="line">			tcp_rcv_synrecv_state_fastopen(sk);</span><br><span class="line">		<span class="comment">//这如果break了，表示对端还没有收到本段发出的fin</span></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;snd_una != tp-&gt;write_seq)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//对端确认了本端发送的fin，这里设置为fin_wait2状态</span></span><br><span class="line">		tcp_set_state(sk, TCP_FIN_WAIT2);</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_shutdown, sk-&gt;sk_shutdown | SEND_SHUTDOWN);</span><br><span class="line"></span><br><span class="line">		sk_dst_confirm(sk);</span><br><span class="line">		<span class="comment">//如果在close中还没有设置dead 那这里就直接推出了！ 什么情况下还么没有设置dead？ 当启用linger的时候（注意区分linger2）</span></span><br><span class="line">		<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">			<span class="comment">/* Wake up lingering close() */</span></span><br><span class="line">			sk-&gt;sk_state_change(sk);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (READ_ONCE(tp-&gt;linger2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			tcp_done(sk);</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">		    after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">			<span class="comment">/* Receive out of order FIN after close() */</span></span><br><span class="line">			<span class="keyword">if</span> (tp-&gt;syn_fastopen &amp;&amp; th-&gt;fin)</span><br><span class="line">				tcp_fastopen_active_disable(sk);</span><br><span class="line">			tcp_done(sk);</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 这里的代码逻辑如下：首先是围绕这个tmo来处理，这个tmo的值简单可以概括成用户是否配置，</span></span><br><span class="line"><span class="comment">		如果配置了那就要看这个值大还是小，如果没有配置，那就是</span></span><br><span class="line"><span class="comment">		走正常1分钟超时逻辑。如果用户配置了linger2 且 大于1分钟的话，</span></span><br><span class="line"><span class="comment">		那就先启动fin_wait2d定时器，注意这个定时器到期的时间时配置的时间减去一分钟，</span></span><br><span class="line"><span class="comment">		然后在这样就会先在 FIN_WAIT2 等 tmo - TIMEWAIT_LEN，</span></span><br><span class="line"><span class="comment">		到点再进 TIME_WAIT*/</span></span><br><span class="line">		<span class="comment">//用户配置的时间，或者是默认的60s</span></span><br><span class="line">		tmo = tcp_fin_time(sk);</span><br><span class="line">		<span class="comment">//tmo超过60s的情况,这里启动fin_wait2定时器，当定时到期还没有收到对方的fin包的话当定时器到期的时候tcp_time_wait，</span></span><br><span class="line">		<span class="comment">// 里面会启动一个定时器，如果此时收到了fin包则会找到tw套接字重新经过60秒的时间</span></span><br><span class="line">		<span class="comment">// 如果还超时了则直接释放资源。</span></span><br><span class="line">		<span class="comment">// 如果fin_wait2定时器没有到期的时候收到了fin包，则会在下tcp_fin中调用tcp_time_wait</span></span><br><span class="line">		<span class="keyword">if</span> (tmo &gt; TCP_TIMEWAIT_LEN) &#123;</span><br><span class="line">			<span class="comment">//fin_wait2定时器</span></span><br><span class="line">			inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);</span><br><span class="line">		<span class="comment">//这里是正常抓包三次挥手时候走的逻辑，如果收到fin 或者 用户锁住了sock 就会进入这个分支</span></span><br><span class="line">		<span class="comment">// 问题是收到fin包为什么会启动一个定时器呢？不应该直接进入timewwwai吗？？</span></span><br><span class="line">		<span class="comment">// 这里的逻辑如果linger2小于60秒 则启动一个时常为linger2的定时器，如果这里右fin标志后面回直接tcp_fin的处理中回直接进入timewait状态</span></span><br><span class="line">		<span class="comment">//如果是由于用户持有锁进入这个分支则启动一个60s的fin_wati2定时器当定时器到期还没有收到fin 的话就rst，如果期间收到了fin的话则tcp_fin会处理</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (th-&gt;fin || sock_owned_by_user(sk)) &#123;</span><br><span class="line">			<span class="comment">/* Bad case. We could lose such FIN otherwise.</span></span><br><span class="line"><span class="comment">			 * It is not a big problem, but it looks confusing</span></span><br><span class="line"><span class="comment">			 * and not so rare event. We still can lose it now,</span></span><br><span class="line"><span class="comment">			 * if it spins in bh_lock_sock(), but it is really</span></span><br><span class="line"><span class="comment">			 * marginal case.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">////对端的数据包带fin或者用户持有sock</span></span><br><span class="line">			<span class="comment">//fin_wait2定时器 tcp_keepalive_timer</span></span><br><span class="line">			inet_csk_reset_keepalive_timer(sk, tmo);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//正常四次挥手的逻辑，没有fin 标志位，这里启动一个60s的fin_wait2定时器</span></span><br><span class="line">		<span class="comment">//注意这里直接创建了tw套接字，进入了tw状态，如果60s每有收到fin则直接释放资源，如果收到了fin则在</span></span><br><span class="line">		<span class="comment">//外层中会直接找到这个tw套接字，并重新开始计时！！！！，这个和上面linger2大于60 有点类似 本质上是防止对端不发fin 我方不释放资源</span></span><br><span class="line">			tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);</span><br><span class="line">			<span class="keyword">goto</span> consume;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 6: check the URG bit */</span></span><br><span class="line">	tcp_urg(sk, skb, th);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 7: process the segment text */</span></span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">	<span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">		<span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">			<span class="comment">/* If a subflow has been reset, the packet should not</span></span><br><span class="line"><span class="comment">			 * continue to be processed, drop the packet.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (sk_is_mptcp(sk) &amp;&amp; !mptcp_incoming_options(sk, skb))</span><br><span class="line">				<span class="keyword">goto</span> discard;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">		<span class="comment">/* RFC 793 says to queue data in these states,</span></span><br><span class="line"><span class="comment">		 * RFC 1122 says we MUST send a reset.</span></span><br><span class="line"><span class="comment">		 * BSD 4.4 also does reset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//收到了对端的fin</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) &#123;</span><br><span class="line">			<span class="comment">//如果数据包携带数据，发rst复位连接</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">			    after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">				NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">				tcp_reset(sk, skb);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fallthrough;<span class="comment">//注意这里如果是处于finwai2状态，则直接继续执行，fin包交给tcp_data_queuec处理</span></span><br><span class="line">	<span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">		tcp_data_queue(sk, skb);</span><br><span class="line">		queued = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当主动关闭方发送<code>fin</code>包之后，后续收到的报文都会交由这个处理逻辑来处理，首先判断发出去的fin是否已经被确认过了，如果没有确认则直接<code>break</code>，如果确认了则将状态设置为TCP_FIN_WAIT2，<strong>接下来判断是否优雅的关闭（linger2 &lt;0）或者收到了<code>fin</code>但携带额外数据，则调用<code>tcp_done</code>直接关闭，不经历完整的四次挥手。</strong></p>
<p><strong>接下来的处理则根据<code>tmo</code>的值走不同的处理逻辑</strong>，<code>tmo</code>的计算逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tcp_fin_time</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//如果设置了linger2就用用户配置的，否则用系统的</span></span><br><span class="line">	<span class="type">int</span> fin_timeout = tcp_sk(sk)-&gt;linger2 ? :</span><br><span class="line">		READ_ONCE(sock_net(sk)-&gt;ipv4.sysctl_tcp_fin_timeout);</span><br><span class="line">	<span class="comment">//在拿到rto</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> rto = inet_csk(sk)-&gt;icsk_rto;</span><br><span class="line">	<span class="comment">//如果基础超时时间 fin_timeout小于3.5 * RTO 则设置为3.5个rto </span></span><br><span class="line">	<span class="comment">// 大概率不会进来吧 </span></span><br><span class="line">	<span class="keyword">if</span> (fin_timeout &lt; (rto &lt;&lt; <span class="number">2</span>) - (rto &gt;&gt; <span class="number">1</span>))</span><br><span class="line">		fin_timeout = (rto &lt;&lt; <span class="number">2</span>) - (rto &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fin_timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户配置了大于60s的<code>tmo</code>则启动一个<code>finwait2</code>定时器，如果这个定时器到期了则会创建一个TCP_FIN_WAIT2状态的<code>tw</code>套接字。如果没到期的情况下收到了<code>fin</code>包则会被下面的<code>tcp_fin</code>处理，启动正常<code>tw</code>状态的定时器。</p>
<p>如果没有配置<code>tmo</code>，则进一步判断当前数据包是否已经携带了<code>fin</code>（四次握手合并成了三次的情况）或者<code>sk</code>当前被用户持有则会启动fin_wait2定时器，防止对端不发送<code>fin</code>（用户被锁住的情况），如果携带了<code>fin</code>则会在下面的处理逻辑中同样交由<code>tcp_fin</code>处理（注意法<code>fall through</code>），里面会启动<code>tw</code>状态的定时器，<strong>注意这里和第一种启动定时器的类似，都是复用保活定时器(保活定时器中增加了对<code>fin_wait2</code>状态的特殊处理)具体代码如下所示：</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/26/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-被动关闭</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-24 22:00:00 / 修改时间：23:56:07" itemprop="dateCreated datePublished" datetime="2026-01-24T22:00:00+08:00">2026-01-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>被动关闭方在处于ESTABLISHED状态时，收到的TCP段都由<code>tcp_rcv_established</code>来处理，若此时收到主动关闭方的FIN段无法命中快速路径（因为标志中不包含<code>fin</code>）所以必然走慢速路径，前文分析过慢速路径如果序列号是预期也会直接放到接收队列，否则放入乱序队列。在接收队列的处理逻辑中会判断是否携带<code>fin</code>标志，如果携带<code>fin</code>标志则会调用<code>tcp_fin</code>进行处理，具体代码如下所示 :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_data_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) &#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">		<span class="comment">//四次挥手fin包处理逻辑</span></span><br><span class="line">			tcp_fin(sk);</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	tcp_data_queue_ofo(sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_fin</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="comment">//收到了fin包肯定需要确认</span></span><br><span class="line">	inet_csk_schedule_ack(sk);</span><br><span class="line">	<span class="comment">//接收方向shutdown 因为对端关闭了,进程上下文从接收队列获取数据的时候会判断</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_shutdown, sk-&gt;sk_shutdown | RCV_SHUTDOWN);</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	sock_set_flag(sk, SOCK_DONE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">	<span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">	<span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">		<span class="comment">/* Move to CLOSE_WAIT */</span></span><br><span class="line">		<span class="comment">//建连接或者客户端已经认为建立连接成功的情况下进入closewait状态</span></span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE_WAIT);</span><br><span class="line">		<span class="comment">//进入pingpong模式，因为四次挥手对时延要求高，所以回复ack要快</span></span><br><span class="line">		inet_csk_enter_pingpong_mode(sk);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//认为时重传的ifn不处理</span></span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">	<span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">		<span class="comment">/* Received a retransmission of the FIN, do</span></span><br><span class="line"><span class="comment">		 * nothing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">		<span class="comment">/* RFC793: Remain in the LAST-ACK state. */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//发送fin后收到fin表示同时关闭</span></span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">		<span class="comment">/* This case occurs when a simultaneous close</span></span><br><span class="line"><span class="comment">		 * happens, we must ack the received FIN and</span></span><br><span class="line"><span class="comment">		 * enter the CLOSING state.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//发送ack</span></span><br><span class="line">		tcp_send_ack(sk);</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSING);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">		<span class="comment">/* Received a FIN -- send ACK and enter TIME_WAIT. */</span></span><br><span class="line">		<span class="comment">//主动关闭的一方收到了对端的fin，发送最后一个ack 并进入tw状态，合理</span></span><br><span class="line">		tcp_send_ack(sk);</span><br><span class="line">		tcp_time_wait(sk, TCP_TIME_WAIT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* Only TCP_LISTEN and TCP_CLOSE are left, in these</span></span><br><span class="line"><span class="comment">		 * cases we should never reach this piece of code.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pr_err(<span class="string">&quot;%s: Impossible, sk-&gt;sk_state=%d\n&quot;</span>,</span><br><span class="line">		       __func__, sk-&gt;sk_state);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* It _is_ possible, that we have something out-of-order _after_ FIN.</span></span><br><span class="line"><span class="comment">	 * Probably, we should reset in this case. For now drop them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//清理乱序队列，概率很小吧，都发送fin了后面还有数据&gt;</span></span><br><span class="line">	skb_rbtree_purge(&amp;tp-&gt;out_of_order_queue);</span><br><span class="line">	<span class="keyword">if</span> (tcp_is_sack(tp))</span><br><span class="line">	<span class="comment">//复位sack的信息</span></span><br><span class="line">		tcp_sack_reset(&amp;tp-&gt;rx_opt);</span><br><span class="line">	<span class="comment">//如果没死，则唤醒用户的进程</span></span><br><span class="line">	<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD)) &#123;</span><br><span class="line">		sk-&gt;sk_state_change(sk);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not send POLL_HUP for half duplex close. */</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK ||</span><br><span class="line">		    sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);<span class="comment">//两个方向都关闭</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);<span class="comment">//关闭了一个方向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注建连状态下的处理，<code>tcp_fin</code>中首先设置需要发送<code>ack</code>的标志位（<strong>由于收到了<code>fin</code>包需要确认，注意这里其实就是第二次挥手发送的<code>ack</code>报文</strong>），并处理了关闭流程中不同状态的迁移，之后设置 <code>RCV_SHUTDOWN</code>，表示发送端已经关闭，之后将状态设置为TCP_CLOSE_WAIT（应用程序程序读取数据时发现设置该标志位会立刻返回），并进入<code>pingpong</code>模式（快速回复<code>ack</code>）。最后完成乱序队列的清理，并复位<code>sack</code>的信息。</p>
<p>上述代码可以看到，当被动关闭方收到主动关闭方发送的<code>fin</code>后设置了<code>sk</code>的状态为<code>SOCK_DONE</code>，并且设置了RCV_SHUTDOWN标志，表示发送端已经关闭，<strong>此时用户程序调用<code>recv</code>时会发现 数据包携带<code>fin</code></strong>（<strong>注意<code>fin</code>包是会放到接收队列中的</strong>）标志位会停止继续拷贝数据，如果拷贝的长度为0，或者下一次调用会发现设置了<code>shutdown</code>标志位，<strong>都会返回用户0</strong>，通知用户对端已经关闭，具体代码在前文<code>tcp_recvmsg</code>中分析过，这里不在重复，对应处理逻辑如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_recvmsg_locked</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> flags, <span class="keyword">struct</span> scm_timestamping_internal *tss,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> *cmsg_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//不断从 sk_receive_queue 找到当前 seq 对应的 skb，拷贝数据</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Next get a buffer. */</span></span><br><span class="line">		<span class="comment">//获取当前队列尾部的skb</span></span><br><span class="line">		last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">		skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) &#123;</span><br><span class="line">		...</span><br><span class="line">			<span class="comment">//数据包中存在fin标志</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">				<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Well, if we have backlog, try to process it now yet. */</span></span><br><span class="line">		<span class="comment">//如果没找到skb 同时没有读够数据，且backlog为空，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (copied &gt;= target &amp;&amp; !READ_ONCE(sk-&gt;sk_backlog.tail))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//已经读了一些数据</span></span><br><span class="line">		<span class="keyword">if</span> (copied) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!timeo ||							<span class="comment">//非阻塞</span></span><br><span class="line">			    sk-&gt;sk_err ||						<span class="comment">//存在错误</span></span><br><span class="line">			    sk-&gt;sk_state == TCP_CLOSE ||		<span class="comment">//已经close</span></span><br><span class="line">			    (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) ||	<span class="comment">//被动关闭</span></span><br><span class="line">			    signal_pending(current))			<span class="comment">//ctrl c？？</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (sock_flag(sk, SOCK_DONE))		<span class="comment">//比如说主动关闭 或被动收到fin</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_err) &#123;						<span class="comment">//比如说收到rst，icmp</span></span><br><span class="line">				copied = sock_error(sk);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)		 <span class="comment">//被动关闭</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">found_fin_ok:</span><br><span class="line">		<span class="comment">/* Process the FIN. */</span></span><br><span class="line">		<span class="comment">//处理fin包</span></span><br><span class="line">		WRITE_ONCE(*seq, *seq + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">			tcp_eat_recv_skb(sk, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	tcp_cleanup_rbuf(sk, copied);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码为被动关闭方收到<code>fin</code>包的处理逻辑，<strong>用户会通过<code>recv</code>返回0来感知对端已经关闭连接</strong>，此时仍是半关闭状态，此时用户程序通常会发完需要待发送的数之后调用<code>close</code>(如果应用程序不调用<code>close</code>，对端也会起一个定时器防止本端不发送<code>fin</code>包)，也就是前文分析的<code>tcp_close</code>，<strong>区别是此时调用<code>tcp_close</code>的状态时<code>TCP_CLOSE_WAIT</code>。</strong></p>
<p>**被动关闭方应用程序调用<code>close</code>后的行为与主动关闭方类似，也是判断是否由有未读数据，是否有<code>linger</code>选项，还是走正常关闭，不同的地方在于状态由CLOSE_WAIT 变成 LAST_ACK（发送FIN等待对端ack）**具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里传入的第二个参数就是solinger设置的超时时间</span></span><br><span class="line"><span class="type">void</span> __tcp_close(<span class="keyword">struct</span> sock *sk, <span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//遍历接收队列，判断是否存在未接收的数据，记录字节数</span></span><br><span class="line">	<span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			len--;</span><br><span class="line">		data_was_unread += len;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//repaire模式</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_sk(sk)-&gt;repair)) &#123;</span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//存在未读的数据，不能让对端认为数据包已经收到了（发fin表示正常接收）</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">		<span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">		<span class="comment">//直接发rst</span></span><br><span class="line">		tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line">	<span class="comment">//用户启用了so linger选项但是超时时间为0 大概率直接发rst</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line">		<span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line"></span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">	<span class="comment">//正常情况，设置为下个状态发送fin包</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">		<span class="comment">//发送fin包</span></span><br><span class="line">		tcp_send_fin(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//close状态的处理</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">		req = rcu_dereference_protected(tcp_sk(sk)-&gt;fastopen_rsk,</span><br><span class="line">						lockdep_sock_is_held(sk));</span><br><span class="line">		<span class="comment">/* We could get here with a non-NULL req if the socket is</span></span><br><span class="line"><span class="comment">		 * aborted (e.g., closed with unread data) before 3WHS</span></span><br><span class="line"><span class="comment">		 * finishes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (req)</span><br><span class="line">			reqsk_fastopen_remove(sk, req, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//最终释放资源</span></span><br><span class="line">		inet_csk_destroy_sock(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Otherwise, socket is reprieved until protocol close. */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	bh_unlock_sock(sk);</span><br><span class="line">	local_bh_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当被动关闭方发送<code>fin</code>包之后进入到了LAST_ACK状态，此时需要等待主动关闭方发送最后一个<code>ack</code>，当收到最后一个<code>ack</code>后会<code>tcp_rcv_state_process</code>交由对应的LAST_ACK状态进行处理，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%89%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-tcp_close（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-22 22:00:00 / 修改时间：21:48:51" itemprop="dateCreated datePublished" datetime="2026-01-22T22:00:00+08:00">2026-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>**<code>inet_child_forget</code>首先调用TCP注册的<code>disconnect</code>释放资源（关闭定时器，清理重传队列等,重置字段），并大概率会发送一个<code>rst</code>**终止连接，具体代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_disconnect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="type">int</span> old_state = sk-&gt;sk_state;</span><br><span class="line">	u32 seq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_state != TCP_CLOSE)</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ABORT function of RFC793 */</span></span><br><span class="line">	<span class="comment">//listen状态的处理</span></span><br><span class="line">	<span class="keyword">if</span> (old_ state == TCP_LISTEN) &#123;</span><br><span class="line">		inet_csk_listen_stop(sk);</span><br><span class="line">	<span class="comment">//repair</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNABORTED);</span><br><span class="line">	<span class="comment">//建链或者断开连接或者syn——recv 会发rst，也就是说大概率发rst</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_need_reset(old_state) ||</span><br><span class="line">		   (tp-&gt;snd_nxt != tp-&gt;write_seq &amp;&amp;</span><br><span class="line">		    (<span class="number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSING | TCPF_LAST_ACK))) &#123;</span><br><span class="line">		<span class="comment">/* The last check adjusts for discrepancy of Linux wrt. RFC</span></span><br><span class="line"><span class="comment">		 * states</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		tcp_send_active_reset(sk, gfp_any());</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNRESET);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old_state == TCP_SYN_SENT)</span><br><span class="line">		WRITE_ONCE(sk-&gt;sk_err, ECONNRESET);</span><br><span class="line">	<span class="comment">//停掉所有的定时器</span></span><br><span class="line">	tcp_clear_xmit_timers(sk);</span><br><span class="line">	<span class="comment">//清掉接收队列</span></span><br><span class="line">	__skb_queue_purge(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">	WRITE_ONCE(tp-&gt;copied_seq, tp-&gt;rcv_nxt);</span><br><span class="line">	WRITE_ONCE(tp-&gt;urg_data, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//清发送队列</span></span><br><span class="line">	tcp_write_queue_purge(sk);</span><br><span class="line">	tcp_fastopen_active_disable_ofo_check(sk);</span><br><span class="line">	<span class="comment">//清重传队列</span></span><br><span class="line">	skb_rbtree_purge(&amp;tp-&gt;out_of_order_queue);</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//对用户调用bind的情况，移除bhash2后复位ip地址并重新加入</span></span><br><span class="line">	inet_bhash2_reset_saddr(sk);</span><br><span class="line">	<span class="comment">//清除shutdown</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_shutdown, <span class="number">0</span>);</span><br><span class="line">	sock_reset_flag(sk, SOCK_DONE);</span><br><span class="line">	<span class="comment">//rtt相关</span></span><br><span class="line">	tp-&gt;srtt_us = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);</span><br><span class="line">	tp-&gt;rcv_rtt_last_tsecr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//让新发送的序列号离当前序列号远一点</span></span><br><span class="line">	seq = tp-&gt;write_seq + tp-&gt;max_window + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (!seq)</span><br><span class="line">		seq = <span class="number">1</span>;</span><br><span class="line">	WRITE_ONCE(tp-&gt;write_seq, seq);</span><br><span class="line">	<span class="comment">//rto  延迟ack</span></span><br><span class="line">	icsk-&gt;icsk_backoff = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_probes_out = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_probes_tstamp = <span class="number">0</span>;</span><br><span class="line">	icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;</span><br><span class="line">	icsk-&gt;icsk_rto_min = TCP_RTO_MIN;</span><br><span class="line">	icsk-&gt;icsk_delack_max = TCP_DELACK_MAX;</span><br><span class="line">	<span class="comment">//拥塞</span></span><br><span class="line">	tp-&gt;snd_ssthresh = TCP_INFINITE_SSTHRESH;</span><br><span class="line">	tcp_snd_cwnd_set(tp, TCP_INIT_CWND);</span><br><span class="line">	tp-&gt;snd_cwnd_cnt = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;is_cwnd_limited = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;max_packets_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;window_clamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;delivered = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;delivered_ce = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (icsk-&gt;icsk_ca_ops-&gt;release)</span><br><span class="line">		icsk-&gt;icsk_ca_ops-&gt;release(sk);</span><br><span class="line">	<span class="built_in">memset</span>(icsk-&gt;icsk_ca_priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(icsk-&gt;icsk_ca_priv));</span><br><span class="line">	icsk-&gt;icsk_ca_initialized = <span class="number">0</span>;</span><br><span class="line">	tcp_set_ca_state(sk, TCP_CA_Open);</span><br><span class="line">	tp-&gt;is_sack_reneg = <span class="number">0</span>;</span><br><span class="line">	tcp_clear_retrans(tp);</span><br><span class="line">	tp-&gt;total_retrans = <span class="number">0</span>;</span><br><span class="line">	inet_csk_delack_init(sk);</span><br><span class="line">	<span class="comment">/* Initialize rcv_mss to TCP_MIN_MSS to avoid division by 0</span></span><br><span class="line"><span class="comment">	 * issue in __tcp_select_window()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	icsk-&gt;icsk_ack.rcv_mss = TCP_MIN_MSS;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;tp-&gt;rx_opt, <span class="number">0</span>, <span class="keyword">sizeof</span>(tp-&gt;rx_opt));</span><br><span class="line">	<span class="comment">//清除路由</span></span><br><span class="line">	__sk_dst_reset(sk);</span><br><span class="line">	dst_release(xchg((__force <span class="keyword">struct</span> dst_entry **)&amp;sk-&gt;sk_rx_dst, <span class="literal">NULL</span>));</span><br><span class="line">	tcp_saved_syn_free(tp);</span><br><span class="line">	<span class="comment">//清除统计计数</span></span><br><span class="line">	tp-&gt;compressed_ack = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;segs_in = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;segs_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_sent = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_acked = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_received = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;bytes_retrans = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;data_segs_in = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;data_segs_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;duplicate_sack[<span class="number">0</span>].start_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;duplicate_sack[<span class="number">0</span>].end_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;dsack_dups = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;reord_seen = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;retrans_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;sacked_out = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;tlp_high_seq = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;last_oow_ack_time = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;plb_rehash = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* There&#x27;s a bubble in the pipe until at least the first ACK. */</span></span><br><span class="line">	tp-&gt;app_limited = ~<span class="number">0U</span>;</span><br><span class="line">	tp-&gt;rate_app_limited = <span class="number">1</span>;</span><br><span class="line">	tp-&gt;rack.mstamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.advanced = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.reo_wnd_steps = <span class="number">1</span>;</span><br><span class="line">	tp-&gt;rack.last_delivered = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.reo_wnd_persist = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rack.dsack_seen = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;syn_data_acked = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.dsack = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rx_opt.num_sacks = <span class="number">0</span>;</span><br><span class="line">	tp-&gt;rcv_ooopack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up fastopen related fields */</span></span><br><span class="line">	tcp_free_fastopen_req(tp);</span><br><span class="line">	inet_clear_bit(DEFER_CONNECT, sk);</span><br><span class="line">	tp-&gt;fastopen_client_fail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	WARN_ON(inet-&gt;inet_num &amp;&amp; !icsk-&gt;icsk_bind_hash);</span><br><span class="line">	<span class="comment">//释放管理的页</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_frag.page) &#123;</span><br><span class="line">		put_page(sk-&gt;sk_frag.page);</span><br><span class="line">		sk-&gt;sk_frag.page = <span class="literal">NULL</span>;</span><br><span class="line">		sk-&gt;sk_frag.offset = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上送错误</span></span><br><span class="line">	sk_error_report(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_disconnect</code>核心思想就是根据当前<code>sk</code>状态决定是否发送<code>rst</code>（例如<code>ESTABLISHED</code>，<code>SYN_RECV</code>四次挥手中间状态等 ）然后无论是否发包，都清理与旧连接相关的定时器，清理接收&#x2F;发送&#x2F;乱序队列，清除远端端口并重置 bhash2 中的源地址关联，重置 shutdown 标志，接着重新设置序列号避旧包污染，恢复 RTO&#x2F;RTT&#x2F;延迟 ACK 和拥塞控制到初始值，清空 SACK&#x2F;RACK&#x2F;重传与各种统计计数，释放路由缓存，最后释放临时页并向用户上报错误。</p>
<p>回到<code>tcp_close</code>中，如果处理的不是<code>listen</code>状态的套接字（大概率都不是），则遍历接收队列记录未读取的字节数并释放数据包（后续会决定是否发送<code>rst</code>），之后判断套接字是否已经被关闭了，比如收到了或者发送了<code>rst</code>？之后判断是否存在未被读取的数据，如果有则不会走正常的四次挥手，而是发送<code>rst</code>，<strong>如果用户设置了linger选项同时<code>linger=0</code>则调用disconnect，表示不走四次挥手，而是直接发送RST终止连接</strong>。</p>
<p>如果不满足上述条件，则走正常挥手发送<code>fin</code>包的流程，首先调用<code>tcp_close_state</code>将状态切换为FIN_WAIT1，之后调用<code>tcp_send_fin</code>发送FIN包，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">tcp_send_fin</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tskb</span>, *<span class="title">tail</span> =</span> tcp_write_queue_tail(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Optimization, tack on the FIN if we have one skb in write queue and</span></span><br><span class="line"><span class="comment">	 * this skb was not yet sent, or we are under memory pressure.</span></span><br><span class="line"><span class="comment">	 * Note: in the latter case, FIN packet will be sent after a timeout,</span></span><br><span class="line"><span class="comment">	 * as TCP stack thinks it has already been transmitted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//首先从发送队列尾部尝试获取，如果没有且在内存压力之下则直接</span></span><br><span class="line">	<span class="comment">//从重传队列中获取skb</span></span><br><span class="line">	tskb = tail;</span><br><span class="line">	<span class="keyword">if</span> (!tskb &amp;&amp; tcp_under_memory_pressure(sk))</span><br><span class="line">		tskb = skb_rb_last(&amp;sk-&gt;tcp_rtx_queue);</span><br><span class="line">	<span class="comment">//拿到了一个skb则加上fin标志 同时增加一个序列号</span></span><br><span class="line">	<span class="keyword">if</span> (tskb) &#123;</span><br><span class="line">		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span><br><span class="line">		TCP_SKB_CB(tskb)-&gt;end_seq++;</span><br><span class="line">		tp-&gt;write_seq++;</span><br><span class="line">		<span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">			<span class="comment">/* This means tskb was already sent.</span></span><br><span class="line"><span class="comment">			 * Pretend we included the FIN on previous transmit.</span></span><br><span class="line"><span class="comment">			 * We need to set tp-&gt;snd_nxt to the value it would have</span></span><br><span class="line"><span class="comment">			 * if FIN had been sent. This is because retransmit path</span></span><br><span class="line"><span class="comment">			 * does not change tp-&gt;snd_nxt.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			WRITE_ONCE(tp-&gt;snd_nxt, tp-&gt;snd_nxt + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//没有获取到可以用的skb则申请一个skb</span></span><br><span class="line">		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		INIT_LIST_HEAD(&amp;skb-&gt;tcp_tsorted_anchor);</span><br><span class="line">		<span class="comment">//resever一下</span></span><br><span class="line">		skb_reserve(skb, MAX_TCP_HEADER);</span><br><span class="line">		sk_forced_mem_schedule(sk, skb-&gt;truesize);</span><br><span class="line">		<span class="comment">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span></span><br><span class="line">		<span class="comment">//初始化数据</span></span><br><span class="line">		tcp_init_nondata_skb(skb, tp-&gt;write_seq,</span><br><span class="line">				     TCPHDR_ACK | TCPHDR_FIN);</span><br><span class="line">		<span class="comment">//数据包入队列</span></span><br><span class="line">		tcp_queue_skb(sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//发送</span></span><br><span class="line">	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>tcp_send_fin</code>主要逻辑就是在关闭连接时发送 FIN（<strong>占用 1 个序列号字节</strong>）。首先尽量把 FIN 挂在现有的最后一个发送 <code>skb</code> 上，如果没有则会申请并构造一个带 FIN 标志的 <code>skb</code>，并发送出去。</p>
<p>回到<code>tcp_close</code>中<strong>发送完<code>fin</code>包之后会调用<code>sk_stream_wait_close</code>睡眠（如果用户设置了需要等待的话），睡眠最大的意义应该是希望发送队列中的数据被发送完？？？</strong> 之后调用<code>sock_orphan</code>将套接字设置为<code>SOCK_DEAD</code>（收包逻辑中会针对这个状态处理）<strong>此时套接字与进程上下文就脱离关系了</strong>。</p>
<p>接下来处理后备队列中的数据包（重走收报逻辑，后面会释放资源），同时增加孤儿套接字统计计数，之后进一步判断当前套接字是否处于关闭状态了，由于在软中断上下文中可能已经关闭了套接字(<strong>感觉这种概率并不大，但是如果上面睡眠了的话是有可能的</strong>)。</p>
<p><strong>之后判断是否处于FIN_WAIT2状态，当发送的<code>fin</code>被对端确认后会进入该状态</strong>，（该状态<strong>下如果对端一直不发送<code>fin</code>包则本端会一直停留在该状态</strong>，为避免这种情况发送，所以在收到<code>ack</code>后会起一个定时器，或者直接回<code>rst</code>），如果用户设置了<code>linger2</code>的时间的话可能会直接发送一个<code>rst</code>，或者可能会创建一个<code>tw</code>状态的套接字，同时把原来的<code>sk</code>从<code>ehash</code>中移除，并启动一个定时器<strong>注意这里不是启动<code>tw</code>定时器，应该叫FIN_WAIT2定时器</strong>（<strong>复用了保活的定时器</strong>），因为<strong>如果收包路径中收到了对端的<code>fin</code>则会找到该<code>tw</code>套接字并判断<code>substate</code>之后启动真正的<code>tw</code> 定时器。</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/22/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/20/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/20/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">TCP四次挥手-tcp_close（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-20 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-20T22:00:00+08:00">2026-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-22 22:00:43" itemprop="dateModified" datetime="2026-01-22T22:00:43+08:00">2026-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/20/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%80%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/20/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于TCP连接是全双工的，发送的同时也能接收数据，所以关闭连接时两个方向必须单独进行，当一端完成数据发送的任务后，应用层可以调用<code>close</code>发送FIN来终止该方向上的连接，当另一端收到这个FIN后，必须通知应用层已经终止了数据传输。同时对端需要确认这个FIN包，因此分手通常需要四次（有时候第二次和第三次可能合并成一个报文）。</p>
<p><code>tcp_close</code>时TCP的<code>close</code>系统调用的传输层实现，在关闭TCP套接字时由<code>inet_release</code>调用，无论是主动关闭还是被动关闭通常都会调用（很少有应用程序，收到对端的FIN包之后不关闭本端吧）<code>close</code>除了释放资源之外的核心逻辑就是决定优雅关闭（正常四次挥手）还是异常中止（发<code>rst</code>）。</p>
<p><code>tcp_close</code>具体实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __tcp_close(<span class="keyword">struct</span> sock *sk, <span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">	<span class="type">int</span> data_was_unread = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> state;</span><br><span class="line">	<span class="comment">//表示这个socket不允许收发数据</span></span><br><span class="line">	WRITE_ONCE(sk-&gt;sk_shutdown, SHUTDOWN_MASK);</span><br><span class="line">	<span class="comment">//listen sk的特殊处理，把监听套接字给关闭了</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Special case. */</span></span><br><span class="line">		<span class="comment">//尝试迁移sock</span></span><br><span class="line">		inet_csk_listen_stop(sk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> adjudge_to_death;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  We need to flush the recv. buffs.  We do this only on the</span></span><br><span class="line"><span class="comment">	 *  descriptor close, not protocol-sourced closes, because the</span></span><br><span class="line"><span class="comment">	 *  reader process may not have drained the data yet!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//遍历接收队列，判断是否存在未接收的数据，记录字节数</span></span><br><span class="line">	<span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			len--;</span><br><span class="line">		data_was_unread += len;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */</span></span><br><span class="line">	<span class="comment">//如果已经是close状态（比如刚发了rst？或者刚收到rst）</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">		<span class="keyword">goto</span> adjudge_to_death;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* As outlined in RFC 2525, section 2.17, we send a RST here because</span></span><br><span class="line"><span class="comment">	 * data was lost. To witness the awful effects of the old behavior of</span></span><br><span class="line"><span class="comment">	 * always doing a FIN, run an older 2.1.x kernel or 2.0.x, start a bulk</span></span><br><span class="line"><span class="comment">	 * GET in an FTP client, suspend the process, wait for the client to</span></span><br><span class="line"><span class="comment">	 * advertise a zero window, then kill -9 the FTP client, wheee...</span></span><br><span class="line"><span class="comment">	 * Note: timeout is always zero in such a case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//repaire模式</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_sk(sk)-&gt;repair)) &#123;</span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//存在未读的数据，不能让对端认为数据包已经收到了（发fin表示正常接收）</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">		<span class="comment">/* Unread data was tossed, zap the connection. */</span></span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONCLOSE);</span><br><span class="line">		tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">		<span class="comment">//直接发rst</span></span><br><span class="line">		tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line">	<span class="comment">//用户启用了so linger选项但是超时时间为0 大概率直接发rst</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sock_flag(sk, SOCK_LINGER) &amp;&amp; !sk-&gt;sk_lingertime) &#123;</span><br><span class="line">		<span class="comment">/* Check zero linger _after_ checking for unread data. */</span></span><br><span class="line"></span><br><span class="line">		sk-&gt;sk_prot-&gt;disconnect(sk, <span class="number">0</span>);</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">	<span class="comment">//正常情况，设置为close状态发送fin包</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">		<span class="comment">/* We FIN if the application ate all the data before</span></span><br><span class="line"><span class="comment">		 * zapping the connection.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* RED-PEN. Formally speaking, we have broken TCP state</span></span><br><span class="line"><span class="comment">		 * machine. State transitions:</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * TCP_ESTABLISHED -&gt; TCP_FIN_WAIT1</span></span><br><span class="line"><span class="comment">		 * TCP_SYN_RECV	-&gt; TCP_FIN_WAIT1 (forget it, it&#x27;s impossible)</span></span><br><span class="line"><span class="comment">		 * TCP_CLOSE_WAIT -&gt; TCP_LAST_ACK</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * are legal only when FIN has been sent (i.e. in window),</span></span><br><span class="line"><span class="comment">		 * rather than queued out of window. Purists blame.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * F.e. &quot;RFC state&quot; is ESTABLISHED,</span></span><br><span class="line"><span class="comment">		 * if Linux state is FIN-WAIT-1, but FIN is still not sent.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The visible declinations are that sometimes</span></span><br><span class="line"><span class="comment">		 * we enter time-wait state, when it is not required really</span></span><br><span class="line"><span class="comment">		 * (harmless), do not send active resets, when they are</span></span><br><span class="line"><span class="comment">		 * required by specs (TCP_ESTABLISHED, TCP_CLOSE_WAIT, when</span></span><br><span class="line"><span class="comment">		 * they look as CLOSING or LAST_ACK for Linux)</span></span><br><span class="line"><span class="comment">		 * Probably, I missed some more holelets.</span></span><br><span class="line"><span class="comment">		 * 						--ANK</span></span><br><span class="line"><span class="comment">		 * XXX (TFO) - To start off we don&#x27;t support SYN+ACK+FIN</span></span><br><span class="line"><span class="comment">		 * in a single packet! (May consider it later but will</span></span><br><span class="line"><span class="comment">		 * probably need API support or TCP_CORK SYN-ACK until</span></span><br><span class="line"><span class="comment">		 * data is written and socket is closed.)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//发送fin包</span></span><br><span class="line">		tcp_send_fin(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里通常是直接返回，否则阻塞一会儿，等待数据发送完毕？</span></span><br><span class="line">	sk_stream_wait_close(sk, timeout);</span><br><span class="line"></span><br><span class="line">adjudge_to_death:</span><br><span class="line">	state = sk-&gt;sk_state;</span><br><span class="line">	sock_hold(sk);</span><br><span class="line">	<span class="comment">//相当于跟用户态断开关系了</span></span><br><span class="line">	sock_orphan(sk);</span><br><span class="line"></span><br><span class="line">	local_bh_disable();</span><br><span class="line">	bh_lock_sock(sk);</span><br><span class="line">	<span class="comment">/* remove backlog if any, without releasing ownership. */</span></span><br><span class="line">	<span class="comment">//处理backlog</span></span><br><span class="line">	__release_sock(sk);</span><br><span class="line"></span><br><span class="line">	this_cpu_inc(tcp_orphan_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Have we already been destroyed by a softirq or backlog? */</span></span><br><span class="line">	<span class="comment">//在其他上下文已经被close调了，这个是很有可能的情况吧？</span></span><br><span class="line">	<span class="keyword">if</span> (state != TCP_CLOSE &amp;&amp; sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*	This is a (useful) BSD violating of the RFC. There is a</span></span><br><span class="line"><span class="comment">	 *	problem with TCP as specified in that the other end could</span></span><br><span class="line"><span class="comment">	 *	keep a socket open forever with no application left this end.</span></span><br><span class="line"><span class="comment">	 *	We use a 1 minute timeout (about the same as BSD) then kill</span></span><br><span class="line"><span class="comment">	 *	our end. If they send after that then tough - BUT: long enough</span></span><br><span class="line"><span class="comment">	 *	that we won&#x27;t make the old 4*rto = almost no time - whoops</span></span><br><span class="line"><span class="comment">	 *	reset mistake.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	Nope, it was not mistake. It is really desired behaviour</span></span><br><span class="line"><span class="comment">	 *	f.e. on http servers, when such sockets are useless, but</span></span><br><span class="line"><span class="comment">	 *	consume significant resources. Let&#x27;s do it with special</span></span><br><span class="line"><span class="comment">	 *	linger2	option.					--ANK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//防止对端一直不发送fin起一个定时器，注意这里和软中断收报逻辑是类似的！！！注意区分linger2和solinger！</span></span><br><span class="line">	<span class="comment">//通常应该不会进入吧，</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_FIN_WAIT2) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">		<span class="keyword">if</span> (READ_ONCE(tp-&gt;linger2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">			tcp_send_active_reset(sk, GFP_ATOMIC);</span><br><span class="line">			__NET_INC_STATS(sock_net(sk),</span><br><span class="line">					LINUX_MIB_TCPABORTONLINGER);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//和收包逻辑处理tmo相同，默认60s或者用户配置的一个时间。</span></span><br><span class="line">			<span class="type">const</span> <span class="type">int</span> tmo = tcp_fin_time(sk);</span><br><span class="line">			<span class="comment">//如果大于60s 就起一个保活定时器，里面有队finwait2的特殊处理</span></span><br><span class="line">			<span class="comment">//到期后进入定时器，这里注意超时时间是用户设置的时间减去一个60s</span></span><br><span class="line">			<span class="keyword">if</span> (tmo &gt; TCP_TIMEWAIT_LEN) &#123;</span><br><span class="line">				inet_csk_reset_keepalive_timer(sk,</span><br><span class="line">						tmo - TCP_TIMEWAIT_LEN);</span><br><span class="line">			<span class="comment">//默认的情况，这创建了tw套接字，并插入了ehash中，注意这里第二个参数是表示的是finwait2状态下创建的</span></span><br><span class="line">			<span class="comment">//如果收到了对端的fin则会找到tw套接字并判断substate之后重新启动tw 定时器</span></span><br><span class="line">			<span class="comment">// 否则这个定时器到期后没收到fin，也会直接释放资源</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//几乎不会发送rst吧</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE) &#123;</span><br><span class="line">		<span class="comment">//判断是否孤儿套接字太多了默认16k</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_check_oom(sk, <span class="number">0</span>)) &#123;</span><br><span class="line">			tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">			tcp_send_active_reset(sk, GFP_ATOMIC);</span><br><span class="line">			__NET_INC_STATS(sock_net(sk),</span><br><span class="line">					LINUX_MIB_TCPABORTONMEMORY);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!check_net(sock_net(sk))) &#123;</span><br><span class="line">			<span class="comment">/* Not possible to send reset; just close */</span></span><br><span class="line">			tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//close状态的处理</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">		req = rcu_dereference_protected(tcp_sk(sk)-&gt;fastopen_rsk,</span><br><span class="line">						lockdep_sock_is_held(sk));</span><br><span class="line">		<span class="comment">/* We could get here with a non-NULL req if the socket is</span></span><br><span class="line"><span class="comment">		 * aborted (e.g., closed with unread data) before 3WHS</span></span><br><span class="line"><span class="comment">		 * finishes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (req)</span><br><span class="line">			reqsk_fastopen_remove(sk, req, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//最终释放资源</span></span><br><span class="line">		inet_csk_destroy_sock(sk);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Otherwise, socket is reprieved until protocol close. */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	bh_unlock_sock(sk);</span><br><span class="line">	local_bh_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_close</code>首先设置 <code>shutdown</code>标志，表示不在允许正常收发数据，如果关闭的是监听套接字或者套接字处于监听状态，则会尝试调用</p>
<p><code>inet_csk_listen_stop</code>迁移三次握手成功但是还未取走的<code>sk</code>（肯定是小概率情况，这里的处理逻辑类似三次握手监听套接字没了的情况）具体代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inet_csk_listen_stop</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> *<span class="title">queue</span> =</span> &amp;icsk-&gt;icsk_accept_queue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">next</span>, *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Following specs, it would be better either to send FIN</span></span><br><span class="line"><span class="comment">	 * (and enter FIN-WAIT-1, it is normal close)</span></span><br><span class="line"><span class="comment">	 * or to send active reset (abort).</span></span><br><span class="line"><span class="comment">	 * Certainly, it is pretty dangerous while synflood, but it is</span></span><br><span class="line"><span class="comment">	 * bad justification for our negligence 8)</span></span><br><span class="line"><span class="comment">	 * To be honest, we are not able to make either</span></span><br><span class="line"><span class="comment">	 * of the variants now.			--ANK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//循环遍历全连接队列</span></span><br><span class="line">	<span class="keyword">while</span> ((req = reqsk_queue_remove(<span class="built_in">queue</span>, sk)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">child</span> =</span> req-&gt;sk, *nsk;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">nreq</span>;</span></span><br><span class="line"></span><br><span class="line">		local_bh_disable();</span><br><span class="line">		bh_lock_sock(child);</span><br><span class="line">		WARN_ON(sock_owned_by_user(child));</span><br><span class="line">		sock_hold(child);</span><br><span class="line">		<span class="comment">//如果启用了reuseport，看看能不能把连接给其他的sk</span></span><br><span class="line">		nsk = reuseport_migrate_sock(sk, child, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (nsk) &#123;</span><br><span class="line">			<span class="comment">//这里的nreq是新listener的节点 req是旧listener的节点</span></span><br><span class="line">			nreq = inet_reqsk_clone(req, nsk);</span><br><span class="line">			<span class="keyword">if</span> (nreq) &#123;</span><br><span class="line">				refcount_set(&amp;nreq-&gt;rsk_refcnt, <span class="number">1</span>);</span><br><span class="line">				<span class="comment">//加到新listen sk的接收队列中</span></span><br><span class="line">				<span class="keyword">if</span> (inet_csk_reqsk_queue_add(nsk, nreq, child)) &#123;</span><br><span class="line">					__NET_INC_STATS(sock_net(nsk),</span><br><span class="line">							LINUX_MIB_TCPMIGRATEREQSUCCESS);</span><br><span class="line">					reqsk_migrate_reset(req);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					__NET_INC_STATS(sock_net(nsk),</span><br><span class="line">							LINUX_MIB_TCPMIGRATEREQFAILURE);</span><br><span class="line">					reqsk_migrate_reset(nreq);</span><br><span class="line">					__reqsk_free(nreq);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* inet_csk_reqsk_queue_add() has already</span></span><br><span class="line"><span class="comment">				 * called inet_child_forget() on failure case.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="comment">//不论时候加入新的listensk了 都跳过下面资源释放的逻辑，因为已经旧的已经释放了</span></span><br><span class="line">				<span class="keyword">goto</span> skip_child_forget;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//上面根本没有启用reuseport的情况,真正的释放资源。</span></span><br><span class="line">		inet_child_forget(sk, req, child);</span><br><span class="line">skip_child_forget:</span><br><span class="line">		reqsk_put(req);</span><br><span class="line">		bh_unlock_sock(child);</span><br><span class="line">		local_bh_enable();</span><br><span class="line">		sock_put(child);</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;fastopenq.rskq_rst_head) &#123;</span><br><span class="line">		<span class="comment">/* Free all the reqs queued in rskq_rst_head. */</span></span><br><span class="line">		spin_lock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">		req = <span class="built_in">queue</span>-&gt;fastopenq.rskq_rst_head;</span><br><span class="line">		<span class="built_in">queue</span>-&gt;fastopenq.rskq_rst_head = <span class="literal">NULL</span>;</span><br><span class="line">		spin_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">		<span class="keyword">while</span> (req != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			next = req-&gt;dl_next;</span><br><span class="line">			reqsk_put(req);</span><br><span class="line">			req = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	WARN_ON_ONCE(sk-&gt;sk_ack_backlog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inet_csk_listen_stop</code>中循环遍历全连接队列，取出没有被accept的套接字**，调用<code>reuseport_migrate_sock</code>尝试找到可以接管当前套接字的的监听套接字，并加入到这个监听套接字的接收队列中**，同时增加统计计数。</p>
<p>如果没有启用<code>reuseport</code>则直接调用<code>inet_child_forget</code>释放这个三次握手成功但是没有被用户接收的<code>sock</code>（也就是<code>child</code>），具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">inet_child_forget</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> request_sock *req,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> sock *child)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//复位字段</span></span><br><span class="line">	sk-&gt;sk_prot-&gt;disconnect(child, O_NONBLOCK);</span><br><span class="line">	<span class="comment">//孤儿套接字</span></span><br><span class="line">	sock_orphan(child);</span><br><span class="line">	<span class="comment">//增加统计计数</span></span><br><span class="line">	this_cpu_inc(*sk-&gt;sk_prot-&gt;orphan_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_protocol == IPPROTO_TCP &amp;&amp; tcp_rsk(req)-&gt;tfo_listener) &#123;</span><br><span class="line">		BUG_ON(rcu_access_pointer(tcp_sk(child)-&gt;fastopen_rsk) != req);</span><br><span class="line">		BUG_ON(sk != req-&gt;rsk_listener);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Paranoid, to prevent race condition if</span></span><br><span class="line"><span class="comment">		 * an inbound pkt destined for child is</span></span><br><span class="line"><span class="comment">		 * blocked by sock lock in tcp_v4_rcv().</span></span><br><span class="line"><span class="comment">		 * Also to satisfy an assertion in</span></span><br><span class="line"><span class="comment">		 * tcp_v4_destroy_sock().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RCU_INIT_POINTER(tcp_sk(child)-&gt;fastopen_rsk, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	inet_csk_destroy_sock(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/20/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%B8%80%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/14/TCP%E6%8E%A5%E6%94%B6recvmsg%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/14/TCP%E6%8E%A5%E6%94%B6recvmsg%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">TCP输入 recvmsg实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-14 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-14T22:00:00+08:00">2026-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-19 20:46:34" itemprop="dateModified" datetime="2026-01-19T20:46:34+08:00">2026-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/14/TCP%E6%8E%A5%E6%94%B6recvmsg%E5%AE%9E%E7%8E%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/14/TCP%E6%8E%A5%E6%94%B6recvmsg%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用户态调用<code>read</code>或者<code>recv</code>等系统调用接收数据时，最终会调用到传输层（<code>sk_prot</code>）的回调，对应TCP的实现为<code>tcp_recvmsg</code>,该接口主要目的就是将<code>sk_receive_queue</code>（接收队列）里按序列号找数据，把 <code>payload</code> 拷贝到用户缓冲区，如果暂时没有合适的数据，就根据阻塞等条件决定等还是返回，最后根据这次读走的数据量决定要不要发 ACK&#x2F;更新窗口。</p>
<p><code>tcp_recvmsg</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_recvmsg</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> *addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cmsg_flags = <span class="number">0</span>, ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">scm_timestamping_internal</span> <span class="title">tss</span>;</span></span><br><span class="line">	<span class="comment">//用户态获取错误对立的数据</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; MSG_ERRQUEUE))</span><br><span class="line">		<span class="keyword">return</span> inet_recv_error(sk, msg, len, addr_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_can_busy_loop(sk) &amp;&amp;									<span class="comment">//用户启用了busypoll</span></span><br><span class="line">	    skb_queue_empty_lockless(&amp;sk-&gt;sk_receive_queue) &amp;&amp; <span class="comment">//接收对立为空</span></span><br><span class="line">	    sk-&gt;sk_state == TCP_ESTABLISHED)						<span class="comment">//建立连接的状态</span></span><br><span class="line">		sk_busy_loop(sk, flags &amp; MSG_DONTWAIT);		<span class="comment">//直接调用驱动的poll函数貌似不需要驱动支持</span></span><br><span class="line"></span><br><span class="line">	lock_sock(sk);<span class="comment">//加锁</span></span><br><span class="line">	<span class="comment">//返回值是拷贝给用户的字节数</span></span><br><span class="line">	ret = tcp_recvmsg_locked(sk, msg, len, flags, &amp;tss, &amp;cmsg_flags);</span><br><span class="line">	<span class="comment">//解锁</span></span><br><span class="line">	release_sock(sk);</span><br><span class="line">	<span class="comment">//是否有控制信息</span></span><br><span class="line">	<span class="keyword">if</span> ((cmsg_flags || msg-&gt;msg_get_inq) &amp;&amp; ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//接收时间戳返给用户</span></span><br><span class="line">		<span class="keyword">if</span> (cmsg_flags &amp; TCP_CMSG_TS)</span><br><span class="line">			tcp_recv_timestamp(msg, sk, &amp;tss);</span><br><span class="line">		<span class="comment">//接收队列还有多少可读字节</span></span><br><span class="line">		<span class="keyword">if</span> (msg-&gt;msg_get_inq) &#123;</span><br><span class="line">			msg-&gt;msg_inq = tcp_inq_hint(sk);</span><br><span class="line">			<span class="keyword">if</span> (cmsg_flags &amp; TCP_CMSG_INQ)</span><br><span class="line">				<span class="comment">//拷贝给用户</span></span><br><span class="line">				put_cmsg(msg, SOL_TCP, TCP_CM_INQ,</span><br><span class="line">					 <span class="keyword">sizeof</span>(msg-&gt;msg_inq), &amp;msg-&gt;msg_inq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_recvmsg</code>中首先判断是否需要从错误队列读取错误信息，如果读取错误信息则直接走<code>inet_recv_error</code>不走正常收包流程。</p>
<p>如果用户启用了busy_poll，且接收队列为空的情况下，则会尝试轮询收报，这里网卡应该是感知不到的， 应该是通过DD位保证数据一致性的吧？</p>
<p>之后调用<code>tcp_recvmsg_locked</code>将数据包真正的从内核拷贝到用户态，并返回拷贝的字节数。<code>tcp_recvmsg_locked</code>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tcp_recvmsg_locked</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> flags, <span class="keyword">struct</span> scm_timestamping_internal *tss,</span></span><br><span class="line"><span class="params">			      <span class="type">int</span> *cmsg_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="type">int</span> copied = <span class="number">0</span>;</span><br><span class="line">	u32 peek_seq;</span><br><span class="line">	u32 *seq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> target;		<span class="comment">/* Read at least this many bytes */</span></span><br><span class="line">	<span class="type">long</span> timeo;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">last</span>;</span></span><br><span class="line">	u32 urg_hole = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = -ENOTCONN;</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">//用户选项设置，看一下接收队列还有多少数据</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;recvmsg_inq) &#123;</span><br><span class="line">		*cmsg_flags = TCP_CMSG_INQ;</span><br><span class="line">		msg-&gt;msg_get_inq = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取超时时间</span></span><br><span class="line">	timeo = sock_rcvtimeo(sk, flags &amp; MSG_DONTWAIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Urgent data needs to be handled specially. */</span></span><br><span class="line">	<span class="comment">//紧急数据的处理</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_OOB)</span><br><span class="line">		<span class="keyword">goto</span> recv_urg;</span><br><span class="line">	<span class="comment">//repair模式下的处理</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">		err = -EPERM;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_SEND_QUEUE)</span><br><span class="line">			<span class="keyword">goto</span> recv_sndq;</span><br><span class="line"></span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;repair_queue == TCP_NO_QUEUE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* &#x27;common&#x27; recv queue MSG_PEEK-ing */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//应用程序已经读到哪个序列号的位置</span></span><br><span class="line">	seq = &amp;tp-&gt;copied_seq;</span><br><span class="line">	<span class="comment">//是否设置了peek</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_PEEK) &#123;</span><br><span class="line">		peek_seq = tp-&gt;copied_seq;</span><br><span class="line">		seq = &amp;peek_seq;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//至少读多少才行，默认是1</span></span><br><span class="line">	target = sock_rcvlowat(sk, flags &amp; MSG_WAITALL, len);</span><br><span class="line">	<span class="comment">//不断从 sk_receive_queue 找到当前 seq 对应的 skb，拷贝数据</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		u32 offset;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Are we at urgent data? Stop if we have read anything or have SIGURG pending. */</span></span><br><span class="line">		<span class="comment">//处理紧急数据</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tp-&gt;urg_data) &amp;&amp; tp-&gt;urg_seq == *seq) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copied)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">				copied = timeo ? sock_intr_errno(timeo) : -EAGAIN;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Next get a buffer. */</span></span><br><span class="line">		<span class="comment">//获取当前队列尾部的skb</span></span><br><span class="line">		last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">		skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) &#123;</span><br><span class="line">			last = skb;</span><br><span class="line">			<span class="comment">/* Now that we have two receive queues this</span></span><br><span class="line"><span class="comment">			 * shouldn&#x27;t happen.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//seq 不能在skb的序号之前，</span></span><br><span class="line">			<span class="keyword">if</span> (WARN(before(*seq, TCP_SKB_CB(skb)-&gt;seq),</span><br><span class="line">				 <span class="string">&quot;TCP recvmsg seq # bug: copied %X, seq %X, rcvnxt %X, fl %X\n&quot;</span>,</span><br><span class="line">				 *seq, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt,</span><br><span class="line">				 flags))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="comment">//找到skb中的偏移</span></span><br><span class="line">			offset = *seq - TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">			<span class="comment">//不能有syn标志</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_SYN)) &#123;</span><br><span class="line">				pr_err_once(<span class="string">&quot;%s: found a SYN, please report !\n&quot;</span>, __func__);</span><br><span class="line">				offset--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//表示序列号落在当前这个skb的范围内</span></span><br><span class="line">			<span class="keyword">if</span> (offset &lt; skb-&gt;len)</span><br><span class="line">				<span class="keyword">goto</span> found_ok_skb;</span><br><span class="line">			<span class="comment">//数据包中存在fin标志</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">				<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">			WARN(!(flags &amp; MSG_PEEK),</span><br><span class="line">			     <span class="string">&quot;TCP recvmsg seq # bug 2: copied %X, seq %X, rcvnxt %X, fl %X\n&quot;</span>,</span><br><span class="line">			     *seq, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt, flags);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Well, if we have backlog, try to process it now yet. */</span></span><br><span class="line">		<span class="comment">//如果没找到skb 同时没有读够数据，且backlog为空，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (copied &gt;= target &amp;&amp; !READ_ONCE(sk-&gt;sk_backlog.tail))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//已经读了一些数据</span></span><br><span class="line">		<span class="keyword">if</span> (copied) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!timeo ||							<span class="comment">//非阻塞</span></span><br><span class="line">			    sk-&gt;sk_err ||						<span class="comment">//存在错误</span></span><br><span class="line">			    sk-&gt;sk_state == TCP_CLOSE ||		<span class="comment">//已经close</span></span><br><span class="line">			    (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) ||	<span class="comment">//被动关闭</span></span><br><span class="line">			    signal_pending(current))			<span class="comment">//ctrl c？？</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (sock_flag(sk, SOCK_DONE))		<span class="comment">//比如说主动关闭</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_err) &#123;						<span class="comment">//比如说收到rst，icmp</span></span><br><span class="line">				copied = sock_error(sk);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)		 <span class="comment">//被动关闭</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE) &#123;</span><br><span class="line">				<span class="comment">/* This occurs when user tries to read</span></span><br><span class="line"><span class="comment">				 * from never connected socket.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				copied = -ENOTCONN;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!timeo) &#123;<span class="comment">//非阻塞模式，没有copy到数据</span></span><br><span class="line">				copied = -EAGAIN;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//ctrl +c</span></span><br><span class="line">			<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">				copied = sock_intr_errno(timeo);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//已经读够了数据，处理后备队列</span></span><br><span class="line">		<span class="keyword">if</span> (copied &gt;= target) &#123;</span><br><span class="line">			<span class="comment">/* Do not sleep, just process backlog. */</span></span><br><span class="line">			__sk_flush_backlog(sk);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//是否立即回ack</span></span><br><span class="line">			tcp_cleanup_rbuf(sk, copied);</span><br><span class="line">			<span class="comment">//睡眠等待数据</span></span><br><span class="line">			err = sk_wait_data(sk, &amp;timeo, last);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				err = copied ? : err;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//peek</span></span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; MSG_PEEK) &amp;&amp;</span><br><span class="line">		    (peek_seq - copied - urg_hole != tp-&gt;copied_seq)) &#123;</span><br><span class="line">			net_dbg_ratelimited(<span class="string">&quot;TCP(%s:%d): Application bug, race in MSG_PEEK\n&quot;</span>,</span><br><span class="line">					    current-&gt;comm,</span><br><span class="line">					    task_pid_nr(current));</span><br><span class="line">			peek_seq = tp-&gt;copied_seq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">found_ok_skb:</span><br><span class="line">		<span class="comment">/* Ok so how much can we use? */</span></span><br><span class="line">		<span class="comment">//计算当前数据包有多少可以copy</span></span><br><span class="line">		used = skb-&gt;len - offset;</span><br><span class="line">		<span class="keyword">if</span> (len &lt; used)</span><br><span class="line">			used = len;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do we have urgent data here? */</span></span><br><span class="line">		<span class="comment">//紧急数据处理</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tp-&gt;urg_data)) &#123;</span><br><span class="line">			u32 urg_offset = tp-&gt;urg_seq - *seq;</span><br><span class="line">			<span class="keyword">if</span> (urg_offset &lt; used) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!urg_offset) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!sock_flag(sk, SOCK_URGINLINE)) &#123;</span><br><span class="line">						WRITE_ONCE(*seq, *seq + <span class="number">1</span>);</span><br><span class="line">						urg_hole++;</span><br><span class="line">						offset++;</span><br><span class="line">						used--;</span><br><span class="line">						<span class="keyword">if</span> (!used)</span><br><span class="line">							<span class="keyword">goto</span> skip_copy;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					used = urg_offset;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里是把数据真正拷贝到用户态！！</span></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_TRUNC)) &#123;</span><br><span class="line">			err = skb_copy_datagram_msg(skb, offset, msg, used);</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				<span class="comment">/* Exception. Bailout! */</span></span><br><span class="line">				<span class="keyword">if</span> (!copied)</span><br><span class="line">					copied = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新seq， copy总量，用户还希望接收的字节数</span></span><br><span class="line">		WRITE_ONCE(*seq, *seq + used);</span><br><span class="line">		copied += used;</span><br><span class="line">		len -= used;</span><br><span class="line">		<span class="comment">//自动调大tcp的接收缓冲区</span></span><br><span class="line">		tcp_rcv_space_adjust(sk);</span><br><span class="line"></span><br><span class="line">skip_copy:</span><br><span class="line">		<span class="comment">//紧急数据处理</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tp-&gt;urg_data) &amp;&amp; after(tp-&gt;copied_seq, tp-&gt;urg_seq)) &#123;</span><br><span class="line">			WRITE_ONCE(tp-&gt;urg_data, <span class="number">0</span>);</span><br><span class="line">			tcp_fast_path_check(sk);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果设置了时间戳，提取时间戳的到tss参数中，并设置控制标志位</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;has_rxtstamp) &#123;</span><br><span class="line">			tcp_update_recv_tstamps(skb, tss);</span><br><span class="line">			*cmsg_flags |= TCP_CMSG_TS;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//还没有读完这个skb的数据 继续读</span></span><br><span class="line">		<span class="keyword">if</span> (used + offset &lt; skb-&gt;len)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			<span class="keyword">goto</span> found_fin_ok;</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">		<span class="comment">//从接收队列中移除skb</span></span><br><span class="line">			tcp_eat_recv_skb(sk, skb);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">found_fin_ok:</span><br><span class="line">		<span class="comment">/* Process the FIN. */</span></span><br><span class="line">		<span class="comment">//处理fin包</span></span><br><span class="line">		WRITE_ONCE(*seq, *seq + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">			tcp_eat_recv_skb(sk, skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* According to UNIX98, msg_name/msg_namelen are ignored</span></span><br><span class="line"><span class="comment">	 * on connected socket. I was just happy when found this 8) --ANK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clean up data we have read: This will do ACK frames. */</span></span><br><span class="line">	<span class="comment">//是否需要立即回复ack</span></span><br><span class="line">	tcp_cleanup_rbuf(sk, copied);</span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">recv_urg:</span><br><span class="line">	err = tcp_recv_urg(sk, msg, len, flags);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">recv_sndq:</span><br><span class="line">	err = tcp_peek_sndq(sk, msg, len);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>tcp_recvmsg_locked</code>中首先判断用户是否启用INQ，启用时会将接收队列的剩余字节数通过<code>put_cmsg</code>返给用户，之后获取用户的超时时间和当前用户已经读到的序列号的位置，以及获取至少需要读多少才允许返回的阈值（默认是1）。</p>
<p>接下进入大循环中，核心就是按照序列号找到对应的<code>skb</code>，计算<code>offset</code>，把数据包拷贝到用户态，如果没找到，就处理后备队列或者睡眠等待。</p>
<p>首先获取当前接收队列尾部的<code>skb</code>之后计算当前序列号在当前<code>skb</code>中的偏移位置，同时进行一系列的安全检查（<strong>如果是<code>fin</code>包则会有专门的处理逻辑，因为<code>fin</code>包是会放到接收队列中的</strong>）。如果没找到<code>skb</code> 同时没有读够数据，且<code>backlog</code>为空，则直接退出循环。如果读取了部分数据，同时非阻塞|| 存在错误||已经close||被动关闭||等情况，则也直接退出循环。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/14/TCP%E6%8E%A5%E6%94%B6recvmsg%E5%AE%9E%E7%8E%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/09/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E5%9B%9B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/09/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E5%9B%9B%EF%BC%89/" class="post-title-link" itemprop="url">TCP输入 慢速路径（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-09 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-09T22:00:00+08:00">2026-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-08 22:57:03" itemprop="dateModified" datetime="2026-01-08T22:57:03+08:00">2026-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/09/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E5%9B%9B%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/09/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E5%9B%9B%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上文<a href="/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/" title="TCP输入 慢速路径（一）">TCP输入 慢速路径（一）</a>说到TCP慢速路径收到报文后，如果数据包序列号是预期的，则首先进行内存压力检查，如果不存在内存压力或者解决了内存压力，会直接将数据包放入接收队列，随后会判断乱序队列是否为空，如果乱序队列不为空，则会调用<code>tcp_ofo_queue</code>尝试将乱序队列中的数据尝试放到有序接收队列中，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_ofo_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	__u32 dsack_high = tp-&gt;rcv_nxt;</span><br><span class="line">	<span class="type">bool</span> fin, fragstolen, eaten;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tail</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">//乱序队列</span></span><br><span class="line">	p = rb_first(&amp;tp-&gt;out_of_order_queue);</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		skb = rb_to_skb(p);</span><br><span class="line">		<span class="comment">//需要比下一个预期接收的大直接break</span></span><br><span class="line">		<span class="keyword">if</span> (after(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//这里判断是否发生重叠</span></span><br><span class="line">		<span class="keyword">if</span> (before(TCP_SKB_CB(skb)-&gt;seq, dsack_high)) &#123;</span><br><span class="line">			__u32 dsack = dsack_high;<span class="comment">//保存起来</span></span><br><span class="line">			<span class="comment">//整个skb都在旧的部分</span></span><br><span class="line">			<span class="keyword">if</span> (before(TCP_SKB_CB(skb)-&gt;end_seq, dsack_high))</span><br><span class="line">				dsack_high = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">			<span class="comment">//用于告诉发送端收到了重复的数据</span></span><br><span class="line">			tcp_dsack_extend(sk, TCP_SKB_CB(skb)-&gt;seq, dsack);</span><br><span class="line">		&#125;</span><br><span class="line">		p = rb_next(p);</span><br><span class="line">		rb_erase(&amp;skb-&gt;rbnode, &amp;tp-&gt;out_of_order_queue);</span><br><span class="line">		<span class="comment">//完全是旧的数据直接 continue</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt))) &#123;</span><br><span class="line">			tcp_drop_reason(sk, skb, SKB_DROP_REASON_TCP_OFO_DROP);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取接收队列的最后一个数据包</span></span><br><span class="line">		tail = skb_peek_tail(&amp;sk-&gt;sk_receive_queue);</span><br><span class="line">		<span class="comment">//追加新的skb，这里注意如果序列号不正正好好的连续这里直接false</span></span><br><span class="line">		eaten = tail &amp;&amp; tcp_try_coalesce(sk, tail, skb, &amp;fragstolen);</span><br><span class="line">		<span class="comment">//更新下一个待接收的序列号</span></span><br><span class="line">		tcp_rcv_nxt_update(tp, TCP_SKB_CB(skb)-&gt;end_seq);</span><br><span class="line">		fin = TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN;</span><br><span class="line">		<span class="comment">//没有追加上，入队列，这里有问题啊 部分重叠的数也入队了？？</span></span><br><span class="line">		<span class="keyword">if</span> (!eaten)</span><br><span class="line">			__skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			</span><br><span class="line">			kfree_skb_partial(skb, fragstolen);</span><br><span class="line">		<span class="comment">//乱序队列中有个fin 走fin包处理逻辑</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(fin)) &#123;</span><br><span class="line">			tcp_fin(sk);</span><br><span class="line">			<span class="comment">/* tcp_fin() purges tp-&gt;out_of_order_queue,</span></span><br><span class="line"><span class="comment">			 * so we must end this loop right now.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_ofo_queue</code>核心工作就是当接收端发现乱序队列中已有的数据已经连续可用时，就按序从 <code>out-of-order</code> 红黑树中取出这些 <code>skb</code>：一边生成 <code>DSACK</code> 记录重复区间，一边丢弃完全过期的数据，能与接收队列尾部合并的就合并，不能的就入接收队列，同时推进 <code>rcv_nxt</code>；如果遇到 <code>FIN</code> 就进入连接关闭处理。这里注意：貌似部分重叠的数据也直接入队了！。</p>
<p>回到<code>tcp_data_queue</code>中处理完乱序队列后，会重新处理<code>sack</code>选项的信息，因为此时整理的乱序丢列，需要重新更新。之后调用<code>tcp_fast_path_check</code>重新设置快速路径用到的<code>flag</code>。最后通知用户态的进程，有数据到了。</p>
<p>如果是完全旧的数据包（数据包的结束序列号在下一个待接收序列号的左侧）则认为是一次虚假的重传设置<code>dsack</code>并进入快速<code>ack</code>模式，目的是即使通知对端收到了虚假重传。</p>
<p>如果数据包的序列号超出了本端的接窗口则直接丢弃书包</p>
<p>如果数据包存在部分重叠的情况，则设置<code>dsack</code>的信息，并直接入队，这里注意：重叠的部分也直接入队了？，应用程序读取的时候会处理这种情况？</p>
<p>其他情况则认为就是收到了乱序的报文，调用<code>tcp_data_queue_ofo</code>进行进一步处理，<code>tcp_data_queue_ofo</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_data_queue_ofo</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span>, *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb1</span>;</span></span><br><span class="line">	u32 seq, end_seq;</span><br><span class="line">	<span class="type">bool</span> fragstolen;</span><br><span class="line"></span><br><span class="line">	tcp_ecn_check_ce(sk, skb);</span><br><span class="line">	<span class="comment">//判断是否内存原因无法继续处理，和外面处理逻辑一样</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(tcp_try_rmem_schedule(sk, skb, skb-&gt;truesize))) &#123;</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);</span><br><span class="line">		sk-&gt;sk_data_ready(sk);</span><br><span class="line">		tcp_drop_reason(sk, skb, SKB_DROP_REASON_PROTO_MEM);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disable header prediction. */</span></span><br><span class="line">	<span class="comment">//这里直接关掉了fastpath</span></span><br><span class="line">	tp-&gt;pred_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置需要回复ack 的标志</span></span><br><span class="line">	inet_csk_schedule_ack(sk);</span><br><span class="line">	<span class="comment">//乱序包统计计数++</span></span><br><span class="line">	tp-&gt;rcv_ooopack += <span class="type">max_t</span>(u16, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs);</span><br><span class="line">	NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE); <span class="comment">//这可以观测乱序数据包的数量</span></span><br><span class="line">	<span class="comment">//数据包的开始序列号</span></span><br><span class="line">	seq = TCP_SKB_CB(skb)-&gt;seq;</span><br><span class="line">	<span class="comment">//数据包的结束序列号</span></span><br><span class="line">	end_seq = TCP_SKB_CB(skb)-&gt;end_seq;</span><br><span class="line">	<span class="comment">//乱序队列</span></span><br><span class="line">	p = &amp;tp-&gt;out_of_order_queue.rb_node;</span><br><span class="line">	<span class="comment">//乱序队列为空的情况</span></span><br><span class="line">	<span class="keyword">if</span> (RB_EMPTY_ROOT(&amp;tp-&gt;out_of_order_queue)) &#123;</span><br><span class="line">		<span class="comment">/* Initial out of order segment, build 1 SACK. */</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_is_sack(tp)) &#123;</span><br><span class="line">			<span class="comment">//构造sack的信息</span></span><br><span class="line">			tp-&gt;rx_opt.num_sacks = <span class="number">1</span>;</span><br><span class="line">			tp-&gt;selective_acks[<span class="number">0</span>].start_seq = seq;</span><br><span class="line">			tp-&gt;selective_acks[<span class="number">0</span>].end_seq = end_seq;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//插入乱序队列</span></span><br><span class="line">		rb_link_node(&amp;skb-&gt;rbnode, <span class="literal">NULL</span>, p);</span><br><span class="line">		rb_insert_color(&amp;skb-&gt;rbnode, &amp;tp-&gt;out_of_order_queue);</span><br><span class="line">		tp-&gt;ooo_last_skb = skb;<span class="comment">//乱序队列中最后一个书包</span></span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In the typical case, we are adding an skb to the end of the list.</span></span><br><span class="line"><span class="comment">	 * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//这里是尝试将当前数据包加入到末尾skb上 注意序列号必须和最后一个连续</span></span><br><span class="line">	<span class="comment">//感觉通常不会走到这个逻辑吧</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_ooo_try_coalesce(sk, tp-&gt;ooo_last_skb,</span><br><span class="line">				 skb, &amp;fragstolen)) &#123;</span><br><span class="line">coalesce_done:</span><br><span class="line">		<span class="comment">/* For non sack flows, do not grow window to force DUPACK</span></span><br><span class="line"><span class="comment">		 * and trigger fast retransmit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_is_sack(tp))</span><br><span class="line">			tcp_grow_window(sk, skb, <span class="literal">true</span>);</span><br><span class="line">		kfree_skb_partial(skb, fragstolen);</span><br><span class="line">		skb = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> add_sack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Can avoid an rbtree lookup if we are adding skb after ooo_last_skb */</span></span><br><span class="line">	<span class="comment">//还在当前乱序数据包的最后一个的后面，那就直接插入就可以了</span></span><br><span class="line">	<span class="keyword">if</span> (!before(seq, TCP_SKB_CB(tp-&gt;ooo_last_skb)-&gt;end_seq)) &#123;</span><br><span class="line">		parent = &amp;tp-&gt;ooo_last_skb-&gt;rbnode;</span><br><span class="line">		p = &amp;parent-&gt;rb_right;</span><br><span class="line">		<span class="keyword">goto</span> insert;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find place to insert this segment. Handle overlaps on the way. */</span></span><br><span class="line">	<span class="comment">//真正的核心，在红黑树中查找插入点，同时处理重叠和覆盖</span></span><br><span class="line">	parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//这里p是红黑树的根</span></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		skb1 = rb_to_skb(parent);</span><br><span class="line">		<span class="comment">//一直往左左走</span></span><br><span class="line">		<span class="keyword">if</span> (before(seq, TCP_SKB_CB(skb1)-&gt;seq)) &#123;</span><br><span class="line">			p = &amp;parent-&gt;rb_left;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断右边</span></span><br><span class="line">		<span class="keyword">if</span> (before(seq, TCP_SKB_CB(skb1)-&gt;end_seq)) &#123;</span><br><span class="line">			<span class="comment">//新段完全被当前段覆盖 直接丢弃了，注意和外面区分，这里是乱序队列完全是旧的</span></span><br><span class="line">			<span class="keyword">if</span> (!after(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) &#123;</span><br><span class="line">				<span class="comment">/* All the bits are present. Drop. */</span></span><br><span class="line">				NET_INC_STATS(sock_net(sk),</span><br><span class="line">					      LINUX_MIB_TCPOFOMERGE);</span><br><span class="line">				tcp_drop_reason(sk, skb,</span><br><span class="line">						SKB_DROP_REASON_TCP_OFOMERGE);</span><br><span class="line">				skb = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="comment">//构造sack</span></span><br><span class="line">				tcp_dsack_set(sk, seq, end_seq);</span><br><span class="line">				<span class="keyword">goto</span> add_sack;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//部分重叠的情况</span></span><br><span class="line">			<span class="keyword">if</span> (after(seq, TCP_SKB_CB(skb1)-&gt;seq)) &#123;</span><br><span class="line">				<span class="comment">/* Partial overlap. */</span></span><br><span class="line">				tcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)-&gt;end_seq);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/* skb&#x27;s seq == skb1&#x27;s seq and skb covers skb1.</span></span><br><span class="line"><span class="comment">				 * Replace skb1 with skb.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="comment">//这里是一定是起点相同的情况！！！</span></span><br><span class="line">				rb_replace_node(&amp;skb1-&gt;rbnode, &amp;skb-&gt;rbnode,</span><br><span class="line">						&amp;tp-&gt;out_of_order_queue);</span><br><span class="line">				<span class="comment">//设置dsack 这里是一个扩展，在原有的基础上？</span></span><br><span class="line">				tcp_dsack_extend(sk,</span><br><span class="line">						 TCP_SKB_CB(skb1)-&gt;seq,</span><br><span class="line">						 TCP_SKB_CB(skb1)-&gt;end_seq);</span><br><span class="line">				NET_INC_STATS(sock_net(sk),</span><br><span class="line">					      LINUX_MIB_TCPOFOMERGE);</span><br><span class="line">				</span><br><span class="line">				tcp_drop_reason(sk, skb1,</span><br><span class="line">						SKB_DROP_REASON_TCP_OFOMERGE);</span><br><span class="line">				<span class="comment">//处理右侧可能重叠的部分</span></span><br><span class="line">				<span class="keyword">goto</span> merge_right;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//在skb1的右侧，如果进入分支表示合并成功！</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_ooo_try_coalesce(sk, skb1,</span><br><span class="line">						skb, &amp;fragstolen)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> coalesce_done;</span><br><span class="line">		&#125;</span><br><span class="line">		p = &amp;parent-&gt;rb_right;</span><br><span class="line">	&#125;</span><br><span class="line">insert:</span><br><span class="line">	<span class="comment">/* Insert segment into RB tree. */</span></span><br><span class="line">	rb_link_node(&amp;skb-&gt;rbnode, parent, p);</span><br><span class="line">	rb_insert_color(&amp;skb-&gt;rbnode, &amp;tp-&gt;out_of_order_queue);</span><br><span class="line"></span><br><span class="line">merge_right:</span><br><span class="line">	<span class="comment">//把右边的重复数据段干掉!</span></span><br><span class="line">	<span class="comment">/* Remove other segments covered by skb. */</span></span><br><span class="line">	<span class="keyword">while</span> ((skb1 = skb_rb_next(skb)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//和右侧没有重叠的 直接break</span></span><br><span class="line">		<span class="keyword">if</span> (!after(end_seq, TCP_SKB_CB(skb1)-&gt;seq))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//部分重叠，不处理</span></span><br><span class="line">		<span class="keyword">if</span> (before(end_seq, TCP_SKB_CB(skb1)-&gt;end_seq)) &#123;</span><br><span class="line">			tcp_dsack_extend(sk, TCP_SKB_CB(skb1)-&gt;seq,</span><br><span class="line">					 end_seq);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//重叠的情况，完全覆盖，从红黑树中移除</span></span><br><span class="line">		rb_erase(&amp;skb1-&gt;rbnode, &amp;tp-&gt;out_of_order_queue);</span><br><span class="line">	</span><br><span class="line">		tcp_dsack_extend(sk, TCP_SKB_CB(skb1)-&gt;seq,</span><br><span class="line">				 TCP_SKB_CB(skb1)-&gt;end_seq);</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);</span><br><span class="line">		tcp_drop_reason(sk, skb1, SKB_DROP_REASON_TCP_OFOMERGE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* If there is no skb after us, we are the last_skb ! */</span></span><br><span class="line">	<span class="comment">//更新最后一个skb</span></span><br><span class="line">	<span class="keyword">if</span> (!skb1)</span><br><span class="line">		tp-&gt;ooo_last_skb = skb;</span><br><span class="line"></span><br><span class="line">add_sack:<span class="comment">//更新sack 的信息</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_is_sack(tp))</span><br><span class="line">		tcp_sack_new_ofo_skb(sk, seq, end_seq);</span><br><span class="line">end:</span><br><span class="line"><span class="comment">//如果skb没被丢弃</span></span><br><span class="line">	<span class="keyword">if</span> (skb) &#123;</span><br><span class="line">		<span class="comment">/* For non sack flows, do not grow window to force DUPACK</span></span><br><span class="line"><span class="comment">		 * and trigger fast retransmit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//尝试增大窗口，目的是让对端发送更多数据？触发快重传？</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_is_sack(tp))</span><br><span class="line">			tcp_grow_window(sk, skb, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">//整理skb内存布局</span></span><br><span class="line">		skb_condense(skb);</span><br><span class="line">		<span class="comment">//内存记账！</span></span><br><span class="line">		skb_set_owner_r(skb, sk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_data_queue_ofo</code>核心逻辑就是将乱序到达的数据包按序插入到红黑树中，并更新<code>sack</code>的信息。首先也检查是否在内存压力之下，和外层处理逻辑类似，之后直接关闭快速路径，累加乱序数据包计数，之后拿到数据包的起始和结束序号。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/09/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E5%9B%9B%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">TCP输入 慢速路径（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-07 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-07T22:00:00+08:00">2026-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-08 22:03:26" itemprop="dateModified" datetime="2026-01-08T22:03:26+08:00">2026-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP建立连接下的收包路径中，如果没有命中<code>fastpath</code>（例如窗口为0，头部长度变化, 序列号不是预期的情况）会进入到慢速路径的处理逻辑中。</p>
<p>慢速路径中首先计算校验和，如果校验和错误或者没有任何控制标志，直接丢弃数据包，否则调用<code>tcp_validate_incoming</code>进一步检查报文的合法性（<strong><code>PAWS</code>机制，是否在窗口内等</strong>），具体代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Does PAWS and seqno based validation of an incoming segment, flags will</span></span><br><span class="line"><span class="comment"> * play significant role here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_validate_incoming</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th, <span class="type">int</span> syn_inerr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	SKB_DR(reason);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RFC1323: H1. Apply PAWS check first. */</span></span><br><span class="line">	<span class="comment">//paws检查 检查没过进入这个分支</span></span><br><span class="line">	<span class="keyword">if</span> (tcp_fast_parse_options(sock_net(sk), skb, th, tp) &amp;&amp;</span><br><span class="line">	    tp-&gt;rx_opt.saw_tstamp &amp;&amp;</span><br><span class="line">	    tcp_paws_discard(sk, skb)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line">			<span class="comment">//如果不是rst 是syn的化回挑战ack，正常数据包就会一个dupack</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(th-&gt;syn))</span><br><span class="line">				<span class="keyword">goto</span> syn_challenge;</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);</span><br><span class="line">			<span class="keyword">if</span> (!tcp_oow_rate_limited(sock_net(sk), skb,</span><br><span class="line">						  LINUX_MIB_TCPACKSKIPPEDPAWS,</span><br><span class="line">						  &amp;tp-&gt;last_oow_ack_time))</span><br><span class="line">				tcp_send_dupack(sk, skb);</span><br><span class="line">			SKB_DR_SET(reason, TCP_RFC7323_PAWS);</span><br><span class="line">			<span class="keyword">goto</span> discard;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Reset is accepted even if it did not pass PAWS. */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: check sequence number */</span></span><br><span class="line">	<span class="comment">//检查学列好是否在接收窗口内，不接受进入下面处理逻辑</span></span><br><span class="line">	reason = tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);</span><br><span class="line">	<span class="keyword">if</span> (reason) &#123;</span><br><span class="line">		<span class="comment">/* RFC793, page 37: &quot;In all states except SYN-SENT, all reset</span></span><br><span class="line"><span class="comment">		 * (RST) segments are validated by checking their SEQ-fields.&quot;</span></span><br><span class="line"><span class="comment">		 * And page 69: &quot;If an incoming segment is not acceptable,</span></span><br><span class="line"><span class="comment">		 * an acknowledgment should be sent in reply (unless the RST</span></span><br><span class="line"><span class="comment">		 * bit is set, if so drop the segment and return)&quot;.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//同上</span></span><br><span class="line">		<span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line">			<span class="keyword">if</span> (th-&gt;syn)</span><br><span class="line">				<span class="keyword">goto</span> syn_challenge;</span><br><span class="line">			<span class="keyword">if</span> (!tcp_oow_rate_limited(sock_net(sk), skb,</span><br><span class="line">						  LINUX_MIB_TCPACKSKIPPEDSEQ,</span><br><span class="line">						  &amp;tp-&gt;last_oow_ack_time))</span><br><span class="line">				tcp_send_dupack(sk, skb);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_reset_check(sk, skb)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> reset;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> discard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: check RST bit */</span></span><br><span class="line">	<span class="comment">//建立连接状态下收到了rst就进入这个分支把</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line">		<span class="comment">/* RFC 5961 3.2 (extend to match against (RCV.NXT - 1) after a</span></span><br><span class="line"><span class="comment">		 * FIN and SACK too if available):</span></span><br><span class="line"><span class="comment">		 * If seq num matches RCV.NXT or (RCV.NXT - 1) after a FIN, or</span></span><br><span class="line"><span class="comment">		 * the right-most SACK block,</span></span><br><span class="line"><span class="comment">		 * then</span></span><br><span class="line"><span class="comment">		 *     RESET the connection</span></span><br><span class="line"><span class="comment">		 * else</span></span><br><span class="line"><span class="comment">		 *     Send a challenge ACK</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//一个合法的rst直接复位</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt ||</span><br><span class="line">		    tcp_reset_check(sk, skb))</span><br><span class="line">			<span class="keyword">goto</span> reset;</span><br><span class="line">		<span class="comment">//如果有sack 则允许匹配最右端的sack边界</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_is_sack(tp) &amp;&amp; tp-&gt;rx_opt.num_sacks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sack_block</span> *<span class="title">sp</span> =</span> &amp;tp-&gt;selective_acks[<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> max_sack = sp[<span class="number">0</span>].end_seq;</span><br><span class="line">			<span class="type">int</span> this_sack;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (this_sack = <span class="number">1</span>; this_sack &lt; tp-&gt;rx_opt.num_sacks;</span><br><span class="line">			     ++this_sack) &#123;</span><br><span class="line">				max_sack = after(sp[this_sack].end_seq,</span><br><span class="line">						 max_sack) ?</span><br><span class="line">					sp[this_sack].end_seq : max_sack;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == max_sack)</span><br><span class="line">				<span class="keyword">goto</span> reset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Disable TFO if RST is out-of-order</span></span><br><span class="line"><span class="comment">		 * and no data has been received</span></span><br><span class="line"><span class="comment">		 * for current active TFO socket</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果rst不可信，则回复挑战ack</span></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;syn_fastopen &amp;&amp; !tp-&gt;data_segs_in &amp;&amp;</span><br><span class="line">		    sk-&gt;sk_state == TCP_ESTABLISHED)</span><br><span class="line">			tcp_fastopen_active_disable(sk);</span><br><span class="line">		tcp_send_challenge_ack(sk);</span><br><span class="line">		SKB_DR_SET(reason, TCP_RESET);</span><br><span class="line">		<span class="keyword">goto</span> discard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 3: check security and precedence [ignored] */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 4: Check for a SYN</span></span><br><span class="line"><span class="comment">	 * RFC 5961 4.2 : Send a challenge ack</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//这里是建立连接状态下收到syn 发一个challenge ack</span></span><br><span class="line">	<span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">syn_challenge:</span><br><span class="line">		<span class="keyword">if</span> (syn_inerr)</span><br><span class="line">			TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);</span><br><span class="line">		tcp_send_challenge_ack(sk);</span><br><span class="line">		SKB_DR_SET(reason, TCP_INVALID_SYN);</span><br><span class="line">		<span class="keyword">goto</span> discard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bpf_skops_parse_hdr(sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">	tcp_drop_reason(sk, skb, reason);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	tcp_reset(sk, skb);</span><br><span class="line">	__kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_validate_incoming</code>中首先判断是否存在时间戳选项，如果存在进行PAWS机制检查，若PAWS失败，判断是否为<code>syn</code>包，<code>syn</code>会回复<code>challenge ack</code>。不是<code>syn</code>包回复<code>dupack</code>，并默默丢弃，如果为<code>rst</code>报文则会在下面进一步判断。</p>
<p>之后判断数据包的序列号是否在接收窗口内，<strong>如果不在接收窗口内</strong>和上面处理逻辑类似，如果是合法<code>rst</code>（是预期的）则直接复位连接。</p>
<p><strong>如果在接收窗口内</strong>，收到了合法<code>rst</code>也直接复位连接，如果同时携带<code>sack</code>则也有可能直接复位连接，如果当前<code>rst</code>报文不可信（序列号有问题）会回复挑战<code>ack</code>， 合理！</p>
<p><strong>如果在建立连接状态下收到了syn包，这里列直接回复挑战<code>ack</code>，合理</strong></p>
<p>回到<code>tcp_rcv_established</code>中，判断完慢速路径报文是否合法后，如果合法会调用<code>tcp_ack</code>进一步处理，之后和快速路径类似，计算接收端<code>rtt</code>，并调用<code>tcp_data_queue</code>进一步处理，之后调用<code>tcp_data_snd_check</code>检查是否有需要待发送的数据，最终调用<code>tcp_ack_snd_check</code>决定是否立即发送<code>ack</code>。</p>
<p><strong>上述<code>tcp_data_queue</code>是慢速路径处理的核心</strong>，涉及到乱序队列等逻辑的处理具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_data_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">skb_drop_reason</span> <span class="title">reason</span>;</span></span><br><span class="line">	<span class="type">bool</span> fragstolen;</span><br><span class="line">	<span class="type">int</span> eaten;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If a subflow has been reset, the packet should not continue</span></span><br><span class="line"><span class="comment">	 * to be processed, drop the packet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sk_is_mptcp(sk) &amp;&amp; !mptcp_incoming_options(sk, skb)) &#123;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空数据包</span></span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == TCP_SKB_CB(skb)-&gt;end_seq) &#123;</span><br><span class="line">		__kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	skb_dst_drop(skb);</span><br><span class="line">	__skb_pull(skb, tcp_hdr(skb)-&gt;doff * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	reason = SKB_DROP_REASON_NOT_SPECIFIED;</span><br><span class="line">	tp-&gt;rx_opt.dsack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  Queue data for delivery to the user.</span></span><br><span class="line"><span class="comment">	 *  Packets in sequence go to the receive queue.</span></span><br><span class="line"><span class="comment">	 *  Out of sequence packets to the out_of_order_queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//数据包时顺序到达的走这里，否则走下面进入乱序队列</span></span><br><span class="line">	<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) &#123;</span><br><span class="line">		<span class="comment">//如果接收窗口变成0了，这里直接丢弃数据包，快速回复一个ack告诉对端窗口为0了</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_receive_window(tp) == <span class="number">0</span>) &#123;</span><br><span class="line">			reason = SKB_DROP_REASON_TCP_ZEROWINDOW;</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);</span><br><span class="line">			<span class="keyword">goto</span> out_of_window;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Ok. In sequence. In window. */</span></span><br><span class="line">queue_and_out:</span><br><span class="line">		<span class="comment">//这里很关键，如果缓冲区大小紧张，这里可能直接丢弃乱序队列的数据包，返回-1表示无法拯救了！</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_try_rmem_schedule(sk, skb, skb-&gt;truesize)) &#123;</span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> maybe ratelimit these WIN 0 ACK ? */</span></span><br><span class="line">			<span class="comment">//立即发ack通告给对端</span></span><br><span class="line">			inet_csk(sk)-&gt;icsk_ack.pending |=</span><br><span class="line">					(ICSK_ACK_NOMEM | ICSK_ACK_NOW);</span><br><span class="line">			inet_csk_schedule_ack(sk);</span><br><span class="line">			<span class="comment">//通知用户态尽力读数据！</span></span><br><span class="line">			sk-&gt;sk_data_ready(sk);</span><br><span class="line">			<span class="comment">//receive_queue 不为空丢弃数据包</span></span><br><span class="line">			<span class="keyword">if</span> (skb_queue_len(&amp;sk-&gt;sk_receive_queue)) &#123;</span><br><span class="line">				reason = SKB_DROP_REASON_PROTO_MEM;</span><br><span class="line">				NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新内存记账，还是有机会入队的！有可能吗</span></span><br><span class="line">			sk_forced_mem_schedule(sk, skb-&gt;truesize);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里是数据包入队</span></span><br><span class="line">		eaten = tcp_queue_rcv(sk, skb, &amp;fragstolen);</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len)</span><br><span class="line">		<span class="comment">//计算接收端rtt mss等信息</span></span><br><span class="line">			tcp_event_data_recv(sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">		<span class="comment">//四次挥手fin包处理逻辑</span></span><br><span class="line">			tcp_fin(sk);</span><br><span class="line">		<span class="comment">//乱序队列不为空</span></span><br><span class="line">		<span class="keyword">if</span> (!RB_EMPTY_ROOT(&amp;tp-&gt;out_of_order_queue)) &#123;</span><br><span class="line">			<span class="comment">//这里就是处理乱序队列的逻辑，尝试把乱序数据放到有序队列中</span></span><br><span class="line">			tcp_ofo_queue(sk);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* RFC5681. 4.2. SHOULD send immediate ACK, when</span></span><br><span class="line"><span class="comment">			 * gap in queue is filled.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//乱序队列为空立即回复ack</span></span><br><span class="line">			<span class="keyword">if</span> (RB_EMPTY_ROOT(&amp;tp-&gt;out_of_order_queue))</span><br><span class="line">				inet_csk(sk)-&gt;icsk_ack.pending |= ICSK_ACK_NOW;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//数据包携带了sack选项，因为可能有些sack需要清理了</span></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;rx_opt.num_sacks)</span><br><span class="line">			tcp_sack_remove(tp);</span><br><span class="line">		<span class="comment">//是否能走到快速路径中</span></span><br><span class="line">		tcp_fast_path_check(sk);</span><br><span class="line">		<span class="comment">//貌似是被合并释放部分</span></span><br><span class="line">		<span class="keyword">if</span> (eaten &gt; <span class="number">0</span>)</span><br><span class="line">			kfree_skb_partial(skb, fragstolen);</span><br><span class="line">		<span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD))</span><br><span class="line">		<span class="comment">//通知用户</span></span><br><span class="line">			tcp_data_ready(sk);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//完全是旧的数据</span></span><br><span class="line">	<span class="keyword">if</span> (!after(TCP_SKB_CB(skb)-&gt;end_seq, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">		<span class="comment">//虚假重传</span></span><br><span class="line">		tcp_rcv_spurious_retrans(sk, skb);</span><br><span class="line">		<span class="comment">/* A retransmit, 2nd most common case.  Force an immediate ack. */</span></span><br><span class="line">		reason = SKB_DROP_REASON_TCP_OLD_DATA;</span><br><span class="line">		NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOST);</span><br><span class="line">		<span class="comment">//告诉发送端收到了重复数据</span></span><br><span class="line">		tcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq);</span><br><span class="line"></span><br><span class="line">out_of_window:</span><br><span class="line">		<span class="comment">//进入快速 ACK 模式，可能是告诉对端收到了虚假重传了</span></span><br><span class="line">		tcp_enter_quickack_mode(sk, TCP_MAX_QUICKACKS);</span><br><span class="line">		inet_csk_schedule_ack(sk);</span><br><span class="line">drop:</span><br><span class="line">		<span class="comment">//直接释放数据包</span></span><br><span class="line">		tcp_drop_reason(sk, skb, reason);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Out of window. F.e. zero window probe. */</span></span><br><span class="line">	<span class="comment">//是否超出了接收窗口，直接释放数据包</span></span><br><span class="line">	<span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq,</span><br><span class="line">		    tp-&gt;rcv_nxt + tcp_receive_window(tp))) &#123;</span><br><span class="line">		reason = SKB_DROP_REASON_TCP_OVERWINDOW;</span><br><span class="line">		<span class="keyword">goto</span> out_of_window;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果存在部分重叠的情况</span></span><br><span class="line">	<span class="keyword">if</span> (before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">		<span class="comment">/* Partial packet, seq &lt; rcv_next &lt; end_seq */</span></span><br><span class="line">		<span class="comment">//设置dsack信息</span></span><br><span class="line">		tcp_dsack_set(sk, TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If window is closed, drop tail of packet. But after</span></span><br><span class="line"><span class="comment">		 * remembering D-SACK for its head made in previous line.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//没有窗口可用了 直接丢弃</span></span><br><span class="line">		<span class="keyword">if</span> (!tcp_receive_window(tp)) &#123;</span><br><span class="line">			reason = SKB_DROP_REASON_TCP_ZEROWINDOW;</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);</span><br><span class="line">			<span class="keyword">goto</span> out_of_window;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里部分重叠的数据包也入队了，那怎么处理重叠的部分呢？？貌似是不处理</span></span><br><span class="line">		<span class="keyword">goto</span> queue_and_out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//其他情况，进入乱序队列</span></span><br><span class="line">	tcp_data_queue_ofo(sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/07/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%B8%89%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/05/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/05/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">TCP输入 快速路径（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2026-01-05 22:00:00 / 修改时间：00:05:50" itemprop="dateCreated datePublished" datetime="2026-01-05T22:00:00+08:00">2026-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/05/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/05/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前文在<a href="/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/" title="TCP输入 快速路径（一）">TCP输入 快速路径（一）</a>说到快速路径的处理逻辑<code>tcp_event_data_recv</code>中会调用<code>tcp_measure_rcv_mss</code>估算发送方的<code>mss</code>，这里计算估算对端的<code>mss</code>的目的是给延迟<code>ack</code>的计算做准备工作（注意区分压缩ack），估算<code>mss</code>的具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_measure_rcv_mss</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> lss = icsk-&gt;icsk_ack.last_seg_size;<span class="comment">//上1轮的估计mss</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	icsk-&gt;icsk_ack.last_seg_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* skb-&gt;len may jitter because of SACKs, even if peer</span></span><br><span class="line"><span class="comment">	 * sends good full-sized frames.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//大包就是gsosize的大小</span></span><br><span class="line">	len = skb_shinfo(skb)-&gt;gso_size ? : skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= icsk-&gt;icsk_ack.rcv_mss) &#123;</span><br><span class="line">		<span class="comment">/* Note: divides are still a bit expensive.</span></span><br><span class="line"><span class="comment">		 * For the moment, only adjust scaling_ratio</span></span><br><span class="line"><span class="comment">		 * when we update icsk_ack.rcv_mss.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//len发生了变化？更新scaling_ratio，这个就是实际能用多少空间的比例把</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(len != icsk-&gt;icsk_ack.rcv_mss)) &#123;</span><br><span class="line">			u64 val = (u64)skb-&gt;len &lt;&lt; TCP_RMEM_TO_WIN_SCALE;</span><br><span class="line"></span><br><span class="line">			do_div(val, skb-&gt;truesize);</span><br><span class="line">			tcp_sk(sk)-&gt;scaling_ratio = val ? val : <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新rcv_mss，被通告mss钳制</span></span><br><span class="line">		icsk-&gt;icsk_ack.rcv_mss = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, len,</span><br><span class="line">					       tcp_sk(sk)-&gt;advmss);</span><br><span class="line">		<span class="comment">/* Account for possibly-removed options */</span></span><br><span class="line">		<span class="comment">//len太大的情况</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(len &gt; icsk-&gt;icsk_ack.rcv_mss +</span><br><span class="line">				   MAX_TCP_OPTION_SPACE))</span><br><span class="line">			tcp_gro_dev_warn(sk, skb, len);</span><br><span class="line">		<span class="comment">/* If the skb has a len of exactly 1*MSS and has the PSH bit</span></span><br><span class="line"><span class="comment">		 * set then it is likely the end of an application write. So</span></span><br><span class="line"><span class="comment">		 * more data may not be arriving soon, and yet the data sender</span></span><br><span class="line"><span class="comment">		 * may be waiting for an ACK if cwnd-bound or using TX zero</span></span><br><span class="line"><span class="comment">		 * copy. So we set ICSK_ACK_PUSHED here so that</span></span><br><span class="line"><span class="comment">		 * tcp_cleanup_rbuf() will send an ACK immediately if the app</span></span><br><span class="line"><span class="comment">		 * reads all of the data and is not ping-pong. If len &gt; MSS</span></span><br><span class="line"><span class="comment">		 * then this logic does not matter (and does not hurt) because</span></span><br><span class="line"><span class="comment">		 * tcp_cleanup_rbuf() will always ACK immediately if the app</span></span><br><span class="line"><span class="comment">		 * reads data and there is more than an MSS of unACKed data.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果有psh 则尽快ack</span></span><br><span class="line">		<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;tcp_flags &amp; TCPHDR_PSH)</span><br><span class="line">			icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//这里应该是小包的i情况</span></span><br><span class="line">		<span class="comment">/* Otherwise, we make more careful check taking into account,</span></span><br><span class="line"><span class="comment">		 * that SACKs block is variable.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * &quot;len&quot; is invariant segment length, including TCP header.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//加上一个tcp的头部长度</span></span><br><span class="line">		len += skb-&gt;data - skb_transport_header(skb);</span><br><span class="line">		<span class="comment">//是否基本大于536？</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt;= TCP_MSS_DEFAULT + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) ||</span><br><span class="line">		    <span class="comment">/* If PSH is not set, packet should be</span></span><br><span class="line"><span class="comment">		     * full sized, provided peer TCP is not badly broken.</span></span><br><span class="line"><span class="comment">		     * This observation (if it is correct 8)) allows</span></span><br><span class="line"><span class="comment">		     * to handle super-low mtu links fairly.</span></span><br><span class="line"><span class="comment">		     */</span></span><br><span class="line">		    (len &gt;= TCP_MIN_MSS + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) &amp;&amp;</span><br><span class="line">		     !(tcp_flag_word(tcp_hdr(skb)) &amp; TCP_REMNANT))) &#123;</span><br><span class="line">			<span class="comment">/* Subtract also invariant (if peer is RFC compliant),</span></span><br><span class="line"><span class="comment">			 * tcp header plus fixed timestamp option length.</span></span><br><span class="line"><span class="comment">			 * Resulting &quot;len&quot; is MSS free of SACK jitter.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			len -= tcp_sk(sk)-&gt;tcp_header_len;</span><br><span class="line">			icsk-&gt;icsk_ack.last_seg_size = len;</span><br><span class="line">			<span class="comment">//注意：上次和这次长度一致 更新mss</span></span><br><span class="line">			<span class="keyword">if</span> (len == lss) &#123;</span><br><span class="line">				icsk-&gt;icsk_ack.rcv_mss = len;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_PUSHED)</span><br><span class="line">			icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED2;</span><br><span class="line">		icsk-&gt;icsk_ack.pending |= ICSK_ACK_PUSHED;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述<strong>tcp_measure_rcv_mss的核心目的就是估算对端实际在发的段大小（通过gso_size 或者数据包的长度），并把结果放到 <code>icsk-&gt;icsk_ack.rcv_mss</code></strong>，后续给 后续<strong>延迟  ack</strong>使用，这里注意上述的<code>gso_size</code>应该是<code>GRO</code>逻辑种设置的。</p>
<p>估算<code>mss</code>之后会调用<code>tcp_rcv_rtt_measure</code>计算接收端的<code>rtt</code>估计，这里注意区分传统意义上的<code>rtt</code>，这个接收端<code>rtt</code>也主要用于压缩<code>ack</code>的计算（<strong>注意区分延迟ack</strong>），具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tcp_rcv_rtt_measure</span><span class="params">(<span class="keyword">struct</span> tcp_sock *tp)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 delta_us;</span><br><span class="line">	<span class="comment">//第一次计算</span></span><br><span class="line">	<span class="keyword">if</span> (tp-&gt;rcv_rtt_est.time == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> new_measure;</span><br><span class="line">	<span class="keyword">if</span> (before(tp-&gt;rcv_nxt, tp-&gt;rcv_rtt_est.seq))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//计算rtt</span></span><br><span class="line">	delta_us = tcp_stamp_us_delta(tp-&gt;tcp_mstamp, tp-&gt;rcv_rtt_est.time);</span><br><span class="line">	<span class="keyword">if</span> (!delta_us)</span><br><span class="line">		delta_us = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//这里表示不用时间戳来计算rtt</span></span><br><span class="line">	tcp_rcv_rtt_update(tp, delta_us, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">new_measure:</span><br><span class="line">    <span class="comment">//这里是一个窗口的大小</span></span><br><span class="line">	tp-&gt;rcv_rtt_est.seq = tp-&gt;rcv_nxt + tp-&gt;rcv_wnd;</span><br><span class="line">	tp-&gt;rcv_rtt_est.time = tp-&gt;tcp_mstamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_rcv_rtt_measure()</code> <strong>测的是接收数据到我窗口被填满这一轮所经历的时</strong>间！！！，用于指导接收侧 delayed ACK策略，而不是端到端链路 <code>RTT</code>。如果支持时间戳选项，可以发现外面也会使用时间戳选项计算<code>rtt</code>但是和这个是一个目的，都是为了指导压缩<code>ack</code></p>
<p>估算对端<code>mss</code>和<code>rtt</code>后，如果没有初始化过延迟<code>ack</code>的超时时间或者超过<code>rto</code>的时间内没有收到数据包，**则会调用<code>tcp_incr_quickack</code>**计算应当立即回复<code>ack</code>多少次，具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_incr_quickack</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> max_quickacks)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">	<span class="comment">//需要多少个ack可以把接收窗口填满</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> quickacks = tcp_sk(sk)-&gt;rcv_wnd / (<span class="number">2</span> * icsk-&gt;icsk_ack.rcv_mss);</span><br><span class="line">	<span class="comment">//最小是2个</span></span><br><span class="line">	<span class="keyword">if</span> (quickacks == <span class="number">0</span>)</span><br><span class="line">		quickacks = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//钳制一下</span></span><br><span class="line">	quickacks = min(quickacks, max_quickacks);</span><br><span class="line">	<span class="comment">//更新，这里是只增不减</span></span><br><span class="line">	<span class="keyword">if</span> (quickacks &gt; icsk-&gt;icsk_ack.quick)</span><br><span class="line">		icsk-&gt;icsk_ack.quick = quickacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_incr_quickack</code>的主要目的是根据当前接收能力动态计算需要多少次立即 <code>ACK</code>，在连接的关键阶段主动加速 <code>ACK</code> 反馈，从而加快对端 cwnd 增长。</p>
<p><code>tcp_event_data_recv</code>处理完上述逻辑后，如果数据包足够大(&gt;128)，<strong>则会尝试调用<code>tcp_grow_window</code>扩大接接收窗口</strong>，具体代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/05/TCPtcp_rcv_established%E8%BE%93%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangm">
      <meta itemprop="description" content="协议栈源码学习">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日拱一卒">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/" class="post-title-link" itemprop="url">TCP输入 快速路径（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-03 22:00:00" itemprop="dateCreated datePublished" datetime="2026-01-03T22:00:00+08:00">2026-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-04 23:57:09" itemprop="dateModified" datetime="2026-01-04T23:57:09+08:00">2026-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">网络协议栈源码学习</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前文说到<code>tcp_v4_rcv</code>为<code>tcp</code>报文接收的总入口。本篇文章则进一步介绍建立连接状态下的<code>	TCP</code>报文接收的处理函数<code>tcp_rcv_established</code>。</p>
<p><code>tcp_rcv_established()</code> 负责处理 <strong>已建立连接</strong> 上收到的每一个 TCP报文，并分为<code>fast path</code>和 <code>slow path</code>两种情况进行处理，核心逻辑是完成以下工作：</p>
<ul>
<li>校验（校验和、<code>PAWS</code>、<code>seq</code> 是否可接受、<code>RST</code>&#x2F;<code>SYN</code> <code>防</code>注入）</li>
<li>处理 ACK（推进 <code>snd_una</code>，清理重传队列，拥塞控制&#x2F;速率采样等）</li>
<li>处理数据（按序入队、乱序队列、合并 <code>skb</code>、唤醒用户态）</li>
<li>决定何时发 <code>ACK</code>（立即&#x2F;延迟&#x2F;压缩 <code>ACK</code>）</li>
</ul>
<p><code>tcp_rcv_established</code>具体代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_rcv_established</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">skb_drop_reason</span> <span class="title">reason</span> =</span> SKB_DROP_REASON_NOT_SPECIFIED;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span> =</span> (<span class="type">const</span> <span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> len = skb-&gt;len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TCP congestion window tracking */</span></span><br><span class="line">	trace_tcp_probe(sk, skb);</span><br><span class="line">	<span class="comment">//更新时间戳，后面ack会用到吧</span></span><br><span class="line">	tcp_mstamp_refresh(tp);</span><br><span class="line">	<span class="comment">//检查以下是否有关联的dst</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!rcu_access_pointer(sk-&gt;sk_rx_dst)))</span><br><span class="line">		inet_csk(sk)-&gt;icsk_af_ops-&gt;sk_rx_dst_set(sk, skb);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Header prediction.</span></span><br><span class="line"><span class="comment">	 *	The code loosely follows the one in the famous</span></span><br><span class="line"><span class="comment">	 *	&quot;30 instruction TCP receive&quot; Van Jacobson mail.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	Van&#x27;s trick is to deposit buffers into socket queue</span></span><br><span class="line"><span class="comment">	 *	on a device interrupt, to call tcp_recv function</span></span><br><span class="line"><span class="comment">	 *	on the receive process context and checksum and copy</span></span><br><span class="line"><span class="comment">	 *	the buffer to user space. smart...</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	Our current scheme is not silly either but we take the</span></span><br><span class="line"><span class="comment">	 *	extra cost of the net_bh soft interrupt processing...</span></span><br><span class="line"><span class="comment">	 *	We do checksum and copy also but from device to kernel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//还没有时间戳选项</span></span><br><span class="line">	tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*	pred_flags is 0xS?10 &lt;&lt; 16 + snd_wnd</span></span><br><span class="line"><span class="comment">	 *	if header_prediction is to be made</span></span><br><span class="line"><span class="comment">	 *	&#x27;S&#x27; will always be tp-&gt;tcp_header_len &gt;&gt; 2</span></span><br><span class="line"><span class="comment">	 *	&#x27;?&#x27; will be 0 for the fast path, otherwise pred_flags is 0 to</span></span><br><span class="line"><span class="comment">	 *  turn it off	(when there are holes in the receive</span></span><br><span class="line"><span class="comment">	 *	 space for instance)</span></span><br><span class="line"><span class="comment">	 *	PSH flag is ignored.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//命中首部预测（头部长度不变吧，窗口不为零），序列号正好是下一个待接收的，不能确认到还没发送的数据！</span></span><br><span class="line">	<span class="keyword">if</span> ((tcp_flag_word(th) &amp; TCP_HP_BITS) == tp-&gt;pred_flags &amp;&amp;</span><br><span class="line">	    TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt &amp;&amp;</span><br><span class="line">	    !after(TCP_SKB_CB(skb)-&gt;ack_seq, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">		<span class="type">int</span> tcp_header_len = tp-&gt;tcp_header_len; <span class="comment">//获取头部长度</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Timestamp header prediction: tcp_header_len</span></span><br><span class="line"><span class="comment">		 * is automatically equal to th-&gt;doff*4 due to pred_flags</span></span><br><span class="line"><span class="comment">		 * match.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check timestamp */</span></span><br><span class="line">		<span class="comment">//只有一个时间戳选项</span></span><br><span class="line">		<span class="keyword">if</span> (tcp_header_len == <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &#123;</span><br><span class="line">			<span class="comment">/* No? Slow path! */</span></span><br><span class="line">			<span class="comment">//提取时间戳选项，到两个字段中</span></span><br><span class="line">			<span class="keyword">if</span> (!tcp_parse_aligned_timestamp(tp, th))</span><br><span class="line">				<span class="keyword">goto</span> slow_path;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* If PAWS failed, check it more carefully in slow path */</span></span><br><span class="line">			<span class="comment">//paws 判断时间戳是否倒退？，新的时间戳比我们之前记录要小</span></span><br><span class="line">			<span class="keyword">if</span> ((s32)(tp-&gt;rx_opt.rcv_tsval - tp-&gt;rx_opt.ts_recent) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> slow_path;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* DO NOT update ts_recent here, if checksum fails</span></span><br><span class="line"><span class="comment">			 * and timestamp was corrupted part, it will result</span></span><br><span class="line"><span class="comment">			 * in a hung connection since we will drop all</span></span><br><span class="line"><span class="comment">			 * future packets due to the PAWS test.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//没有负载的情况</span></span><br><span class="line">		<span class="keyword">if</span> (len &lt;= tcp_header_len) &#123;</span><br><span class="line">			<span class="comment">/* Bulk data transfer: sender */</span></span><br><span class="line">			<span class="comment">//纯ack包</span></span><br><span class="line">			<span class="keyword">if</span> (len == tcp_header_len) &#123;</span><br><span class="line">				<span class="comment">/* Predicted packet is in window by definition.</span></span><br><span class="line"><span class="comment">				 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span></span><br><span class="line"><span class="comment">				 * Hence, check seq&lt;=rcv_wup reduces to:</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (tcp_header_len ==</span><br><span class="line">				    (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &amp;&amp;</span><br><span class="line">				    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)</span><br><span class="line">					<span class="comment">//这里是数据包有时间戳选项，把时间戳保存到tp字段中，注意和上面进行区分！</span></span><br><span class="line">					tcp_store_ts_recent(tp);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* We know that such packets are checksummed</span></span><br><span class="line"><span class="comment">				 * on entry.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="comment">//对ack进行处理</span></span><br><span class="line">				tcp_ack(sk, skb, <span class="number">0</span>);</span><br><span class="line">				__kfree_skb(skb);</span><br><span class="line">				<span class="comment">//检查是否有需要发送的数据</span></span><br><span class="line">				tcp_data_snd_check(sk);</span><br><span class="line">				<span class="comment">/* When receiving pure ack in fast path, update</span></span><br><span class="line"><span class="comment">				 * last ts ecr directly instead of calling</span></span><br><span class="line"><span class="comment">				 * tcp_rcv_rtt_measure_ts()</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tp-&gt;rcv_rtt_last_tsecr = tp-&gt;rx_opt.rcv_tsecr;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">//非法，直接丢弃</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">/* Header too small */</span></span><br><span class="line">				reason = SKB_DROP_REASON_PKT_TOO_SMALL;</span><br><span class="line">				TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);</span><br><span class="line">				<span class="keyword">goto</span> discard;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//有负载的情况</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> eaten = <span class="number">0</span>;</span><br><span class="line">			<span class="type">bool</span> fragstolen = <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//计算校验和</span></span><br><span class="line">			<span class="keyword">if</span> (tcp_checksum_complete(skb))</span><br><span class="line">				<span class="keyword">goto</span> csum_error;</span><br><span class="line">			<span class="comment">//内存压力检查，这里几乎不可能把</span></span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">int</span>)skb-&gt;truesize &gt; sk-&gt;sk_forward_alloc)</span><br><span class="line">				<span class="keyword">goto</span> step5;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Predicted packet is in window by definition.</span></span><br><span class="line"><span class="comment">			 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span></span><br><span class="line"><span class="comment">			 * Hence, check seq&lt;=rcv_wup reduces to:</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//和上面一样跟新ts_recent</span></span><br><span class="line">			<span class="keyword">if</span> (tcp_header_len ==</span><br><span class="line">			    (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcphdr) + TCPOLEN_TSTAMP_ALIGNED) &amp;&amp;</span><br><span class="line">			    tp-&gt;rcv_nxt == tp-&gt;rcv_wup)</span><br><span class="line">				tcp_store_ts_recent(tp);</span><br><span class="line">			<span class="comment">//这里使用时间戳回显计算rtt,和tcpack里面计算的rtt的区别是什么？用途不一样？</span></span><br><span class="line">			tcp_rcv_rtt_measure_ts(sk, skb);</span><br><span class="line"></span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPHPHITS);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Bulk data transfer: receiver */</span></span><br><span class="line">			skb_dst_drop(skb);</span><br><span class="line">			__skb_pull(skb, tcp_header_len);</span><br><span class="line">			<span class="comment">//数据包入队，这里更新了rcv_nxt</span></span><br><span class="line">			eaten = tcp_queue_rcv(sk, skb, &amp;fragstolen);</span><br><span class="line">			<span class="comment">//估计发送端mss 接收端rtt，调整接收慢启动阈值！！！</span></span><br><span class="line">			tcp_event_data_recv(sk, skb);</span><br><span class="line">			<span class="comment">//处理ack</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;ack_seq != tp-&gt;snd_una) &#123;</span><br><span class="line">				<span class="comment">/* Well, only one small jumplet in fast path... */</span></span><br><span class="line">				tcp_ack(sk, skb, FLAG_DATA);</span><br><span class="line">				<span class="comment">//是否需要发送数据</span></span><br><span class="line">				tcp_data_snd_check(sk);</span><br><span class="line">				<span class="comment">//判断是否需要发送ack</span></span><br><span class="line">				<span class="keyword">if</span> (!inet_csk_ack_scheduled(sk))</span><br><span class="line">					<span class="keyword">goto</span> no_ack;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//处理ack没有推进的情况</span></span><br><span class="line">				tcp_update_wl(tp, TCP_SKB_CB(skb)-&gt;seq);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//决定是上面时候发送ack</span></span><br><span class="line">			__tcp_ack_snd_check(sk, <span class="number">0</span>);</span><br><span class="line">no_ack:</span><br><span class="line">			<span class="keyword">if</span> (eaten)</span><br><span class="line">				kfree_skb_partial(skb, fragstolen);</span><br><span class="line">			<span class="comment">//唤醒用户态的read/recv</span></span><br><span class="line">			tcp_data_ready(sk);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//快速路径</span></span><br><span class="line">slow_path:</span><br><span class="line">	<span class="comment">//计算校验和</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; (th-&gt;doff &lt;&lt; <span class="number">2</span>) || tcp_checksum_complete(skb))</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line">	<span class="comment">//合法性检查</span></span><br><span class="line">	<span class="keyword">if</span> (!th-&gt;ack &amp;&amp; !th-&gt;rst &amp;&amp; !th-&gt;syn) &#123;</span><br><span class="line">		reason = SKB_DROP_REASON_TCP_FLAGS;</span><br><span class="line">		<span class="keyword">goto</span> discard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Standard slow path.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tcp_validate_incoming(sk, skb, th, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">step5:</span><br><span class="line">	reason = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT);</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">int</span>)reason &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		reason = -reason;</span><br><span class="line">		<span class="keyword">goto</span> discard;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//处理接收端rtt</span></span><br><span class="line">	tcp_rcv_rtt_measure_ts(sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Process urgent data. */</span></span><br><span class="line">	<span class="comment">//处理紧急数据</span></span><br><span class="line">	tcp_urg(sk, skb, th);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step 7: process the segment text */</span></span><br><span class="line">	tcp_data_queue(sk, skb);</span><br><span class="line">	<span class="comment">//检查是否有待发送的数据</span></span><br><span class="line">	tcp_data_snd_check(sk);</span><br><span class="line">	<span class="comment">//决定什么时候发送ack</span></span><br><span class="line">	tcp_ack_snd_check(sk);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">csum_error:</span><br><span class="line">	reason = SKB_DROP_REASON_TCP_CSUM;</span><br><span class="line">	trace_tcp_bad_csum(skb);</span><br><span class="line">	TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);</span><br><span class="line">	TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">	tcp_drop_reason(sk, skb, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcp_rcv_established</code>主要分为快速路径和慢速路径进行处理，快速路径下数据包会直接入队，同时唤醒用户进程（网上说百分之90都会走快速路径），首先介绍快速路径的处理逻辑：</p>
<p>进入快速路径的前提是满足首部预测条件，在三次握手和<code>tcp_ack</code>的处理逻辑中会设置首部预测标记位，当数据包到来时，<strong>如果命中了首部预测，且数据包的序列号正是接收端所预期的，同时确认号合法，则进入快速路径的处理流程</strong>，这里注意，即使进入到快速路径的处理流程中，也可能会<code>fall back</code>到慢速路径中处理。</p>
<p>快速路径中首先解析数据包的时间戳选项，之后判断是否能通过<code>PAWS</code>机制（这里就是判断时间戳是否合法），之后快速路径中针对数据包是否有负载进行处理。</p>
<p><strong>如果不存在负载</strong>，则会尝试提取记录时间戳选项，调用<code>tcp_ack</code>进行处理(前面有分析过)之后调用<code>tcp_data_snd_check</code>判断发送路径上是否有数据需要发送,，然后直接返回了！</p>
<p>如果存在负载，则首先计算校验和，之后提取时间戳选项，<strong>并调用<code>tcp_rcv_rtt_measure_ts</code>计算接受侧<code>rtt</code>(注意区分这个和传统<code>rtt</code>的区别这个貌似时用来计算延迟<code>ack</code>用到的</strong>)，<code>tcp_rcv_rtt_measure_ts</code>代码如下所示：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2026/01/03/TCPtcp_rcv_established%E8%BE%93%E5%85%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangm</p>
  <div class="site-description" itemprop="description">协议栈源码学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '1c6PW2umhmoCGypfQhPNnfLk-gzGzoHsz',
      appKey     : 'nbVvMAfQXEdOeKD1tmvI3qrQ',
      placeholder: "畅所欲言!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://1c6pw2um.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
